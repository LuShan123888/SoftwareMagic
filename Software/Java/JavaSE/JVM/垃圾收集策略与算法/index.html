

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/LuShan123888/SoftwareMagic@gh-pages/img/logo.png">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/LuShan123888/SoftwareMagic@gh-pages/img/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#0a5fff">
  <meta name="description" content="">
  <meta name="author" content="Cian">
  <meta name="keywords" content="software computer programmer otes Cloud personal">
  <meta name="description" content="JVM 垃圾收集策略与算法  程序计数器,虚拟机栈,本地方法栈随线程而生,也随线程而灭,栈帧随着方法的开始而入栈,随着方法的结束而出栈,这几个区域的内存分配和回收都具有确定性,在这几个区域内不需要过多考虑回收的问题,因为方法结束或者线程结束时,内存自然就跟随着回收了 而对于 Java 堆和方法区,我们只有在程序运行期间才能知道会创建哪些对象,这部分内存的分配和回收都是动态的,垃圾收集器所关注的正是">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM 垃圾收集策略与算法">
<meta property="og:url" content="https://softwaremagic.lushan.tk/Software/Java/JavaSE/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5%E4%B8%8E%E7%AE%97%E6%B3%95/">
<meta property="og:site_name" content="SoftwareMagic">
<meta property="og:description" content="JVM 垃圾收集策略与算法  程序计数器,虚拟机栈,本地方法栈随线程而生,也随线程而灭,栈帧随着方法的开始而入栈,随着方法的结束而出栈,这几个区域的内存分配和回收都具有确定性,在这几个区域内不需要过多考虑回收的问题,因为方法结束或者线程结束时,内存自然就跟随着回收了 而对于 Java 堆和方法区,我们只有在程序运行期间才能知道会创建哪些对象,这部分内存的分配和回收都是动态的,垃圾收集器所关注的正是">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-09-21T15:13:03.000Z">
<meta property="article:modified_time" content="2021-09-21T15:13:03.000Z">
<meta property="article:author" content="Cian">
<meta property="article:tag" content="software computer programmer otes Cloud personal">
<meta name="twitter:card" content="summary_large_image">
  
  <title>JVM 垃圾收集策略与算法 - SoftwareMagic</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LuShan123888/SoftwareMagic@gh-pages/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LuShan123888/SoftwareMagic@gh-pages/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"softwaremagic.lushan.tk","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"https://cdn.jsdelivr.net/gh/LuShan123888/SoftwareMagic@gh-pages/local-search.xml"};
  </script>
  <script  src="https://cdn.jsdelivr.net/gh/LuShan123888/SoftwareMagic@gh-pages/js/utils.js" ></script>
  <script  src="https://cdn.jsdelivr.net/gh/LuShan123888/SoftwareMagic@gh-pages/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 50vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>SoftwareMagic</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://cdn.jsdelivr.net/gh/LuShan123888/SoftwareMagic@gh-pages/img/background.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JVM 垃圾收集策略与算法">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-09-21 23:13" pubdate>
        2021年9月21日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.9k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      15 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JVM 垃圾收集策略与算法</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年9月21日 晚上
                
              </p>
            
            <div class="markdown-body">
              <h1>JVM 垃圾收集策略与算法</h1>
<ul>
<li>程序计数器,虚拟机栈,本地方法栈随线程而生,也随线程而灭,栈帧随着方法的开始而入栈,随着方法的结束而出栈,这几个区域的内存分配和回收都具有确定性,在这几个区域内不需要过多考虑回收的问题,因为方法结束或者线程结束时,内存自然就跟随着回收了</li>
<li>而对于 Java 堆和方法区,我们只有在程序运行期间才能知道会创建哪些对象,这部分内存的分配和回收都是动态的,垃圾收集器所关注的正是这部分内存</li>
</ul>
<h2 id="判定对象是否存活">判定对象是否存活</h2>
<ul>
<li>若一个对象不被任何对象或变量引用,那么它就是无效对象,需要被回收</li>
</ul>
<h3 id="引用计数法">引用计数法</h3>
<ul>
<li>在对象头维护着一个 counter 计数器,对象被引用一次则计数器 +1,若引用失效则计数器 -1,当计数器为 0 时,就认为该对象无效了</li>
<li>引用计数算法的实现简单,判定效率也很高,在大部分情况下它都是一个不错的算法,但是主流的 Java 虚拟机里没有选用引用计数算法来管理内存,主要是因为它很难解决对象之间循环引用的问题</li>
</ul>
<blockquote>
<p><strong>循环引用</strong>:对象 objA 和 objB 都有字段 instance,令<code>objA.instance = objB</code>并且<code>objB.instance = objA</code>,由于它们互相引用着对方,导致它们的引用计数都不为 0,于是引用计数算法无法通知 GC 收集器回收它们</p>
</blockquote>
<h3 id="可达性分析法">可达性分析法</h3>
<ul>
<li>所有和 GC Roots 直接或间接关联的对象都是有效对象,和 GC Roots 没有关联的对象就是无效对象</li>
<li>GC Roots 是指:
<ul>
<li>Java 虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
</ul>
</li>
<li>GC Roots 并不包括堆中对象所引用的对象,这样就不会有循环引用的问题</li>
</ul>
<h5 id="三色标记算法">三色标记算法</h5>
<ul>
<li>要找出存活对象，根据可达性分析，从GC Roots开始进行遍历访问，可达的则为存活对象，我们把遍历对象图<strong>过程</strong>中遇到的对象，按“是否访问过”这个条件标记成以下三种颜色
<ul>
<li><strong>白色</strong>：本对象没有被访问过 （没有被GCRoot扫描过，有可能是为垃圾对象）</li>
<li><strong>灰色</strong>：本对象已经被访问过（被GCRoot扫描过），且本对象中的属性没有被GCRoot扫描，该对象就是为灰色对象，如果该对象的属性被扫描的情况下，从灰色变为黑色</li>
<li><strong>黑色</strong>：本对象已经被访问过（被GCRoot扫描过），且本对象中的属性已经被GCRoot扫描过，该对象就是为黑色对象。</li>
</ul>
</li>
<li>由于标记是在并发环境下进行的，无法一次遍历所有节点，所以引入灰色节点代表下一次遍历的开始节点，而黑色节点不再遍历</li>
<li><strong>标记过程</strong>
<ul>
<li>在初始阶段的时候，所有的对象都是存放在白色容器中。</li>
<li>初始标记阶段，GCRoot标记直接关联对象置为灰色</li>
<li>并发标记阶段，从灰色容器中获取对象，扫描整个引用链，有子节点的话，则当前节点变为黑色，所有子节点变为灰色</li>
<li>在白色盒子剩下的对象都是为没有被GCRoot关联的对象，可能会被垃圾回收机制清理。</li>
<li>下次GCRoot起点从灰色节点开始计算</li>
</ul>
</li>
<li><strong>三色标记算法缺陷</strong>：在并发标记阶段的时候，因为用户线程与GC线程同时运行，有可能会产生多标记（浮动垃圾）或漏标记
<ul>
<li><strong>浮动垃圾</strong>
<ul>
<li>并发标记阶段用户与GC线程同时运行，假设已经遍历到A（变为灰色了），此时应用执行了 <code>A.B = null</code>，此刻之后，对象C是应该被回收的。然而因为<strong>已经变为灰色</strong>了，其仍会被<strong>当作存活对象</strong>继续遍历下去。</li>
<li>针对并发标记开始后的<strong>新对象</strong>，通常的做法是直接全部<strong>当成黑色</strong>，本轮不会进行清除。这部分对象期间可能会变为垃圾，这也算是浮动垃圾的一部分</li>
</ul>
</li>
<li><strong>漏标问题</strong>
<ul>
<li>用户线程先执行<code>B.C=null</code>，GC线程的GcRoot就扫描不到C。GC就认为C对象就是为垃圾对象，不可达对象</li>
<li>用户线程然后执行<code>A.C=C</code>,此时C对象就是应该为可达对象。因为GCRoot是从灰色节点B开始，不会从黑色的A开始，就会导致漏标的情况发生。</li>
<li>漏标只有<strong>同时满足</strong>以下两个条件时才会发生
<ol>
<li>灰色对象断开了白色对象的引用（直接或间接的引用），即灰色对象原来成员变量的引用发生了变化</li>
<li>黑色对象重新引用了该白色对象，即黑色对象成员变量增加了新的引用</li>
</ol>
</li>
<li><strong>CMS解决漏标问题—写屏障+增量更新方式</strong>
<ul>
<li>当满足条件（灰色对象与白色对象断开连接），在并发标记阶段当我们黑色对象（A）引用关联白色对象（C），记录下黑色对象，即写屏障</li>
<li>在重新标记阶段（所有用户线程暂停），重新扫描被记录的黑色对象，增量更新</li>
<li><strong>缺点</strong>：遍历黑色节点整个链的效率非常低，有可能会导致用户线程等待的时间非常长</li>
<li><strong>写屏障</strong>：其实就是指在赋值操作前后，加入一些处理（可以参考AOP的概念）</li>
</ul>
</li>
<li><strong>G1解决漏标问题—原始快照方式</strong>
<ul>
<li>在灰色对象断开白色对象的时候，会记录原始快照，在重新标记阶段的时候以白色对象变为灰色为起始点扫描整个链，本次GC是不会被清理。</li>
<li><strong>优点</strong>：如果假设黑色对象引入该白色对象的时候，无需做任何遍历效率是非常高。</li>
<li><strong>缺点</strong>：如果假设黑色对象没有引入该白色对象的时候，该白色对象在本次GC继续存活，只能放在下一次GC在做并发标记的时候清理。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="引用的种类">引用的种类</h2>
<ul>
<li>判定对象是否存活与&quot;引用”有关,在 JDK 1.2 以前,Java 中的引用定义很传统,一个对象只有被引用或者没有被引用两种状态,我们希望能描述这一类对象:当内存空间还足够时,则保留在内存中,如果内存空间在进行垃圾收集后还是非常紧张,则可以抛弃这些对象,很多系统的缓存功能都符合这样的应用场景</li>
<li>在 JDK 1.2 之后,Java 对引用的概念进行了扩充,将引用分为了以下四种,不同的引用类型,主要体现的是对象不同的可达性状态<code>reachable</code>和垃圾收集的影响</li>
</ul>
<h3 id="强引用-Strong-Reference">强引用(Strong Reference)</h3>
<p>类似<code>Object obj = new Object()</code>这类的引用,就是强引用,只要强引用存在,垃圾收集器永远不会回收被引用的对象,但是,如果我们<strong>错误地保持了强引用</strong>,比如:赋值给了 static 变量,那么对象在很长一段时间内不会被回收,会产生内存泄漏</p>
<h3 id="软引用-Soft-Reference">软引用(Soft Reference)</h3>
<p>软引用是一种相对强引用弱化一些的引用,可以让对象豁免一些垃圾收集,只有当 JVM 认为内存不足时,才会去试图回收软引用指向的对象,JVM 会确保在抛出<code>OutOfMemoryError</code>之前,清理软引用指向的对象,软引用通常用来<strong>实现内存敏感的缓存</strong>,如果还有空闲内存,就可以暂时保留缓存,当内存不足时清理掉,这样就保证了使用缓存的同时,不会耗尽内存</p>
<h3 id="弱引用-Weak-Reference">弱引用(Weak Reference)</h3>
<p>弱引用的<strong>强度比软引用更弱</strong>一些,当 JVM 进行垃圾回收时,<strong>无论内存是否充足,都会回收</strong>只被弱引用关联的对象</p>
<h3 id="虚引用-Phantom-Reference">虚引用(Phantom Reference)</h3>
<p>虚引用也称幽灵引用或者幻影引用,它是<strong>最弱</strong>的一种引用关系,一个对象是否有虚引用的存在,完全不会对其生存时间构成影响,它仅仅是提供了一种确保对象被 finalize 以后,做某些事情的机制,比如,通常用来做所谓的 Post-Mortem 清理机制</p>
<h2 id="回收堆中无效对象">回收堆中无效对象</h2>
<p>对于可达性分析中不可达的对象,也并不是没有存活的可能</p>
<h3 id="判定-finalize-是否有必要执行">判定 finalize() 是否有必要执行</h3>
<ul>
<li>当垃圾回收机制回收某个对象所占用的内存之前,通常要求程序调用适当的方法来清理资源,在没有明确指定资源清理的情况下,Java提供了默认机制来清理资源,即调用finalize方法,它是Object类的方法,原型为:<code>protected void finalize() throws Throwable</code>,任何Java类都可以覆盖Object类的finalize方法,它可以抛出任何类型的异常,垃圾回收机制何时调用对象的finalize方法是完全透明的,只有当程序需要更多额外内存时,才会进行垃圾回收</li>
<li>JVM 会判断此对象是否有必要执行<code>finalize()</code>方法,如果对象没有覆盖<code>finalize()</code>方法,或者<code>finalize()</code>方法已经被虚拟机调用过,那么视为&quot;没有必要执行”,那么对象基本上就真的被回收了</li>
<li>如果对象被判定为有必要执行<code>finalize()</code>方法,那么对象会被放入一个 F-Queue 队列中,虚拟机会以较低的优先级执行这些<code>finalize()</code>方法,但不会确保所有的<code>finalize()</code>方法都会执行结束,如果<code>finalize()</code>方法出现耗时操作,虚拟机就直接停止指向该方法,将对象清除</li>
</ul>
<h3 id="对象重生或死亡">对象重生或死亡</h3>
<p>如果在执行<code>finalize()</code>方法时,将 this 赋给了某一个引用,那么该对象就重生了,如果没有,那么就会被垃圾收集器清除</p>
<blockquote>
<p>任何一个对象的<code>finalize()</code>方法只会被系统自动调用一次,如果对象面临下一次回收,它的<code>finalize()</code>方法不会被再次执行,想继续在 <code>finalize()</code>中自救就失效了</p>
</blockquote>
<h2 id="回收方法区内存">回收方法区内存</h2>
<p>方法区中存放生命周期较长的类信息,常量,静态变量,每次垃圾收集只有少量的垃圾被清除,方法区中主要清除两种垃圾:</p>
<ul>
<li>废弃常量</li>
<li>无用的类</li>
</ul>
<h3 id="判定废弃常量">判定废弃常量</h3>
<p>只要常量池中的常量不被任何变量或对象引用,那么这些常量就会被清除掉,比如,一个字符串 “bingo” 进入了常量池,但是当前系统没有任何一个 String 对象引用常量池中的 “bingo” 常量,也没有其它地方引用这个字面量,必要的话,&quot;bingo&quot;常量会被清理出常量池</p>
<h3 id="判定无用的类">判定无用的类</h3>
<p>判定一个类是否是&quot;无用的类”,条件较为苛刻</p>
<ul>
<li>该类的所有对象都已经被清除</li>
<li>加载该类的<code>ClassLoader</code>已经被回收</li>
<li>该类的<code>java.lang.Class</code>对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法</li>
</ul>
<blockquote>
<p>一个类被虚拟机加载进方法区,那么在堆中就会有一个代表该类的对象:<code>java.lang.Class</code>,这个对象在类被加载进方法区时创建,在方法区该类被删除时清除</p>
</blockquote>
<h2 id="垃圾收集算法">垃圾收集算法</h2>
<p>学会了如何判定无效对象,无用类,废弃常量之后,剩余工作就是回收这些垃圾,常见的垃圾收集算法有以下几个:</p>
<h3 id="标记-清除算法">标记-清除算法</h3>
<ul>
<li><strong>标记</strong>的过程是:遍历所有的 <code>GC Roots</code>,然后将所有 <code>GC Roots</code> 可达的对象<strong>标记为存活的对象</strong></li>
<li><strong>清除</strong>的过程将遍历堆中所有的对象,将没有标记的对象全部清除掉,与此同时,清除那些被标记过的对象的标记,以便下次的垃圾回收</li>
<li>这种方法有两个<strong>不足</strong>:
<ul>
<li>效率问题:标记和清除两个过程的效率都不高</li>
<li>空间问题:标记清除之后会产生大量不连续的内存碎片,碎片太多可能导致以后需要分配较大对象时,无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
</ul>
</li>
</ul>
<h3 id="标记-复制算法">标记-复制算法</h3>
<ul>
<li>标记复制算法将可用内存按容量划分为大小相等的两块,每次只使用其中的一块,当这一块内存用完,需要进行垃圾收集时,就将存活者的对象复制到另一块上面,然后将第一块内存全部清除,这种算法有优有劣:</li>
<li>优点:不会有内存碎片的问题</li>
<li>缺点:内存缩小为原来的一半,浪费空间</li>
<li>为了解决空间利用率问题,可以将内存分为三块:Eden,From Survivor,To Survivor,比例是 8:1:1,每次使用 Eden 和其中一块 Survivor,回收时,将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上,最后清理掉 Eden 和刚才使用的 Survivor 空间,这样只有 10% 的内存被浪费</li>
<li>但是我们无法保证每次回收都只有不多于 10% 的对象存活,当 Survivor 空间不够,需要依赖其他内存(指老年代)进行分配担保</li>
<li><strong>分配担保</strong>：为对象分配内存空间时,如果 Eden+Survivor 中空闲区域无法装下该对象,会触发 MinorGC 进行垃圾收集,但如果 Minor GC 过后依然有超过 10% 的对象存活,这样存活的对象直接通过分配担保机制进入老年代,然后再将新对象存入 Eden 区</li>
</ul>
<h3 id="标记-整理算法">标记-整理算法</h3>
<ul>
<li><strong>标记</strong>:它的第一个阶段与<strong>标记-清除算法</strong>是一模一样的,均是遍历 <code>GC Roots</code>,然后将存活的对象标记</li>
<li><strong>整理</strong>:移动所有<strong>存活的对象</strong>,且按照内存地址次序依次排列,然后将末端内存地址以后的内存全部回收,因此,第二阶段才称为整理阶段</li>
<li>这是一种老年代的垃圾收集算法,老年代的对象一般寿命比较长,因此每次垃圾回收会有大量对象存活,如果采用复制算法,每次需要复制大量存活的对象,效率很低</li>
</ul>
<h3 id="分代收集算法">分代收集算法</h3>
<ul>
<li>根据对象存活周期的不同,将内存划分为几块,一般是把 Java 堆分为新生代和老年代,针对各个年代的特点采用最适当的收集算法
<ul>
<li>新生代:标记-复制算法</li>
<li>老年代:标记-清除算法,标记-整理算法</li>
</ul>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Software/">Software</a>
                    
                      <a class="hover-with-bg" href="/categories/Software/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/categories/Software/Java/JavaSE/">JavaSE</a>
                    
                      <a class="hover-with-bg" href="/categories/Software/Java/JavaSE/JVM/">JVM</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/Software/Backend/SpringFramework/SpringMVC/WebMvcConfigurer/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Spring MVC WebMvcConfigurer</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Software/Java/JavaSE/JVM/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/">
                        <span class="hidden-mobile">JVM 性能调优</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/gh/LuShan123888/SoftwareMagic@gh-pages/js/events.js" ></script>
<script  src="https://cdn.jsdelivr.net/gh/LuShan123888/SoftwareMagic@gh-pages/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="https://cdn.jsdelivr.net/gh/LuShan123888/SoftwareMagic@gh-pages/js/local-search.js" ></script>



  
    <script  src="https://cdn.jsdelivr.net/gh/LuShan123888/SoftwareMagic@gh-pages/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="https://cdn.jsdelivr.net/gh/LuShan123888/SoftwareMagic@gh-pages/js/boot.js" ></script>


</body>
</html>
