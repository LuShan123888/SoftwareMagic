---
title: HTTP Cookie&Session&Token
categories:
- Internet
- HTTP
---
# HTTP Cookie&Session&Token

## Cookie

- `cookie`是一个非常具体的东西,指的就是浏览器里面能永久存储的一种数据,仅仅是浏览器实现的一种数据存储功能
- `cookie`由服务器生成,发送给浏览器,浏览器把`cookie`以kv键值对形式保存到某个目录下的文本文件内,下一次请求同一网站时会把该`cookie`发送给服务器
- 由于cookie是存在客户端上的,所以浏览器加入了一些限制确保cookie不会被恶意使用,同时不会占据太多磁盘空间,所以每个域的cookie数量是有限的

## Session

- `session`从字面上讲,就是会话,这个就类似于你和一个人交谈,你怎么知道当前和你交谈的是张三而不是李四呢?对方肯定有某种特征(长相等)表明他就是张三
- `session`也是类似的道理,服务器要知道当前发请求给自己的是谁,为了做这种区分,服务器就要给每个客户端分配不同的"身份标识”,然后客户端每次向服务器发请求的时候,都带上这个"身份标识”,服务器就知道这个请求来自于谁了,至于客户端怎么保存这个"身份标识”,可以有很多种方式,对于浏览器客户端,大家都默认采用`cookie`的方式
- 服务器使用`session`把用户的信息临时保存在了服务器上,用户离开网站后`session`会被销毁,这种用户信息存储方式相对`cookie`来说更安全,可是`session`有一个缺陷:如果web服务器做了负载均衡,那么下一个操作请求到了另一台服务器的时候`session`会丢失

## Token

- Token 也称作令牌,由uid+time+sign[+固定参数]
    - uid: 用户唯一身份标识
    - time: 当前时间的时间戳
    - sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串,以防止第三方恶意拼接
    - 固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库
- token 的认证方式类似于**临时的证书签名**, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据
- token在客户端一般存放于localStorage,cookie,或sessionStorage中,在服务器一般存于数据库中

### 基于Token的验证原理

> 1. 用户通过用户名和密码发送请求
> 2. 程序验证
> 3. 程序返回一个签名的token给客户端
> 4. 客户端储存token,并且每次用于每次发送请求
> 5. 服务端验证token并返回数据

- 每一次请求都需要token, token应该在HTTP的头部发送从而保证了Http请求无状态
- 我们同样通过设置服务器属性`AccessControl-Allow-Origin:*`,让服务器能接受到来自所有域的请求
- 最主要的是,在ACAO头部标明(designating)*时,不得带有像HTTP认证,客户端SSL证书和cookies的证书
- 我们甚至能基于创建一个基于权限的token传给第三方应用程序,这些第三方程序能够获取到我们的数据(当然只有在我们允许的特定的token)

## session与token的区别

### token可以抵抗csrf,cookie+session不行

假如用户正在登陆银行网页,同时登陆了攻击者的网页,并且银行网页未对csrf攻击进行防护,攻击者就可以在网页放一个表单,该表单提交src为`http://www.bank.com/api/transfer`,body为`count=1000&to=Tom`,倘若是session+cookie,用户打开网页的时候就已经转给Tom1000元了.因为form 发起的 POST 请求并不受到浏览器同源策略的限制,因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求,形成 CSRF 攻击,在post请求的瞬间,cookie会被浏览器自动添加到请求头中,但token不同,token是开发者为了防范csrf而特别设计的令牌,浏览器不会自动添加到headers里,攻击者也无法访问用户的token,所以提交的表单无法通过服务器过滤,也就无法形成攻击

### 分布式情况下的session和token

- 我们已经知道session是有状态的,一般存于服务器内存或硬盘中,当服务器采用分布式或集群时,session就会面对负载均衡问题
- 负载均衡多服务器的情况,不好确认当前用户是否登录,因为多服务器不共享session,这个问题也可以将session存在一个服务器中来解决,但是就不能完全达到负载均衡的效果
- 而token是无状态的,token字符串里就保存了所有的用户信息
- 客户端登陆传递信息给服务端,服务端收到后把用户信息加密(token)传给客户端,客户端将token存放于localStroage等容器中,客户端每次访问都传递token,服务端解密token,就知道这个用户是谁了,通过cpu加解密,服务端就不需要存储session占用存储空间,就很好的解决负载均衡多服务器的问题了,这个方法叫做JWT