---
title: Linux 文件系统
categories:
- Software
- System
- Linux
---
# Linux 文件系统

## 系统目录结构

|    路径     |                             描述                             |
| :---------: | :----------------------------------------------------------: |
|    /bin     |      bin是Binary的缩写,,这个目录存放着最经常使用的命令       |
|    /boot    | 这里存放的是启动Linux时使用的一些核心文件,包括一些连接文件以及镜像文件 |
|    /dev     | dev是Device(设备)的缩写,,存放的是Linux的外部设备,在Linux中访问设备的方式和访问文件的方式是相同的 |
|    /etc     |    这个目录用来存放所有的系统管理所需要的配置文件和子目录    |
|    /home    | 用户的主目录,在Linux中,每个用户都有一个自己的目录,一般该目录名是以用户的账号命名的 |
|    /lib     | 这个目录里存放着系统最基本的动态连接共享库,其作用类似于Windows里的DLL文件 |
| /lost+found | 这个目录一般情况下是空的,当系统非法关机后,这里就存放了一些文件,(存放,突然关机的一些文件) |
|   /media    | linux系统会自动识别一些设备,例如U盘,光驱等等,当识别后,linux会把识别的设备,挂载到这个目录下 |
|    /mnt     | 系统提供该目录是为了让用户临时挂载别的文件系统的,我们可以将光驱挂载在/mnt/上,,然后进入该目录就可以查看光驱里的内容了 |
|    /opt     | 这是给主机额外安装软件所摆放的目录,比如你安装一个ORACLE数据库则就可以放到这个,目录下,默认是空的 |
|    /proc    | 这个目录是一个虚拟的目录,它是系统内存的映射,我们可以通过直接访问这个目录来获取系统信息 |
|    /root    |       该目录为系统管理员,也称作超级权限者的用户主目录        |
|    /sbin    | s就是Super,User的意思,这里存放的是系统管理员使用的系统管理程序 |
|    /srv     |           该目录存放一些服务启动之后需要提取的数据           |
|    /sys     | 这是linux2.6内核的一个很大的变化,该目录下安装了2.6内核中新出现的一个文件系统,sysfs |
|    /tmp     | 这个目录是用来存放一些临时文件的,用完即丢的文件,可以放在这个目录下,安装包 |
|    /usr     | 这是一个非常重要的目录,用户的很多应用程序和文件都放在这个目录下,类似于windows,下的programfiles目录 |
|  /usr/bin   |                    系统用户使用的应用程序                    |
|  /usr/sbin  |     超级用户使用的比较高级的管理程序和系统守护程序,Super     |
|  /usr/src   |                   内核源代码默认的放置目录                   |
|    /var     | 这个目录中存放着在不断扩充着的东西,我们习惯将那些经常被修改的目录放在这个目录,下,包括各种日志文件 |
|    /run     | 是一个临时文件系统,存储系统启动以来的信息,当系统重启时,这个目录下的文件应该被,删掉或清除 |
|    /www     |           存放服务器网站相关的资源,环境,网站的项目           |

## 目录管理

### cd

```shell
cd 路径 #切换目录命令
cd ./  #当前目录
cd ../ #返回上一级目录
cd ~ #用户目录
cd / #根路径
```

### ls

```shell
ls
```

- -s #文件大小
- -k #以k字节的形式表示文件的大小
- -a 显示所有文件及目录 (`.`开头的隐藏文件也会列出)
- -l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出
- -r 将文件以相反次序显示(原定依英文字母次序)
- -t 将文件依建立时间之先后次序列出
- -A 同 -a ，但不列出 "." (目前目录) 及 ".." (父目录)
- -F 在列出的文件名称后加一符号；例如可执行档则加 "*", 目录则加 "/"
- -R 若目录下有文件，则以下之文件亦皆依序列出

```
$ ls -ahl
total 28K
dr-xr-x---.  2 root root  135 Dec 16 02:34 .
dr-xr-xr-x. 17 root root  224 Dec 14 01:38 ..
-rw-------.  1 root root 1.3K Dec 14 01:38 anaconda-ks.cfg
-rw-------.  1 root root 1.2K Dec 16 02:34 .bash_history
-rw-r--r--.  1 root root   18 Dec 28  2013 .bash_logout
-rw-r--r--.  1 root root  176 Dec 28  2013 .bash_profile
-rw-r--r--.  1 root root  176 Dec 28  2013 .bashrc
-rw-r--r--.  1 root root  100 Dec 28  2013 .cshrc
-rw-r--r--.  1 root root  129 Dec 28  2013 .tcshrc
```

- 从上面可以看到，每一行都有7列，分别是：
- 第一列共10位，第1位表示文档类型，d表示目录，-表示文件，l表示链接文件，d表示可随机存取的设备，如U盘等，c表示一次性读取设备，如鼠标、键盘等。后9位，依次对应三种身份所拥有的权限，身份顺序为：owner、group、others，权限顺序为：readable、writable、excutable。如：-r-xr-x---的含义为当前文档是一个文件，拥有者可读、可执行，同一个群组下的用户，可读、可写，其他人没有任何权限。
- 第二列表示链接数，表示有多少个文件链接到inode号码。
- 第三列表示拥有者
- 第四列表示所属群组
- 第五列表示文档容量大小，单位字节
- 第六列表示文档最后修改时间，注意不是文档的创建时间哦
- 第七列表示文档名称。以点(.)开头的是隐藏文档

### lsattr

- Linux lsattr命令用于显示文件属性。
- 用chattr执行改变文件或目录的属性，可执行lsattr指令查询其属性。

```
lsattr [-adlRvV][文件或目录...]
```

- -a 　显示所有文件和目录，包括以"."为名称开头字符的额外内建，现行目录"."与上层目录".."。
- -d 　显示，目录名称，而非其内容。
- -l 　此参数目前没有任何作用。
- -R 　递归处理，将指定目录下的所有文件及子目录一并处理。
- -v 　显示文件或目录版本。
- -V 　显示版本信息。

### pwd

```shell
pwd #显示当前的路径(绝对路径)
```

### mkdir

```shell
mkdir test1 #创建目录
mkdir -p test2/test3/test4 #创建多级目录
```

### rmdir

- rmdir 仅能删除空的目录,如果下面存在文件,需要先删除文件

```shell
rmdir test1 #删除目录
```

- `-p`:当子目录被删除后使它也成为空目录的话，则顺便一并删除


```shell
rmdir -p BBB/Test
```

- 在工作目录下的 BBB 目录中，删除名为 Test 的子目录。若 Test 删除后，BBB 目录成为空目录，则 BBB 亦予删除。

### cp

```shell
cp [options] source dest
或
cp [options] source... directory
```

- -a:此选项通常在复制目录时使用,它保留链接,文件属性,并复制目录下的所有内容,其作用等于dpR参数组合
- -d:复制时保留链接,这里所说的链接相当于Windows系统中的快捷方式
- -f:覆盖已经存在的目标文件而不给出提示
- -i:与-f选项相反,在覆盖目标文件之前给出提示,要求用户确认是否覆盖,回答"y"时目标文件将被覆盖
- -p:除复制文件的内容外,还把修改时间和访问权限也复制到新文件中
- -r:若给出的源文件是一个目录文件,此时将复制该目录下所有的子目录和文件
- -l:不复制文件,只是生成链接文件

**实例**

```shell
cp -ri ./* ../
```

- 将当前目录下的所有文件复制到上层目录中

### rm

- 删除一个文件或者目录

```shell
rm [options] name...
```

- -i:删除前逐一询问确认
- -f:即使原档案属性设为唯读,亦直接删除,无需逐一确认
- -r:将目录及以下之档案亦逐一删除

### mv

- 移动文件或者目录,重命名文件

```shell
mv (原路径)/原文件名 (新路径)/新文件名
-f 强制
-u 只替换已经更新过的文件
```

### touch

- 创建文件

```shell
touch ~/1.txt
```

## 查找文件

### which

- which指令会在环境变量$PATH设置的目录里查找符合条件的文件。

```
which [文件...]
```

- `-n<文件名长度> `:指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
- `-p<文件名长度>`:与-n参数相同，但此处的<文件名长度>包括了文件的路径。
- `-w`:指定输出时栏位的宽度。
- `-a:可以返回所有匹配结果`

### whereis

- 该指令会在特定目录中查找符合条件的文件,这些文件应属于原始代码,二进制文件,或是帮助文件
- 该指令只能用于查找二进制文件,源代码文件和man手册页

```
whereis [-bfmsu][-B <目录>...][-M <目录>...][-S <目录>...][文件...]
```

**参数**:

- `-b`:只查找二进制文件
- `-B<目录>`:只在设置的目录下查找二进制文件
- `-f`:不显示文件名前的路径名称
- `-m`:只查找说明文件
- `-M<目录>`:只在设置的目录下查找说明文件
- `-s`:只查找原始代码文件
- `-S<目录>`:只在设置的目录下查找原始代码文件
- `-u`:查找不包含指定类型的文件

**实例**

- 使用指令"whereis"查看指令"bash"的位置,输入如下命令:

```
$ whereis bash
```

- 上面的指令执行后,输出信息如下所示:

```
bash:/bin/bash/etc/bash.bashrc/usr/share/man/man1/bash.1.gz
```

- **注意**:以上输出信息从左至右分别为查询的程序名,bash路径,bash的man 手册页路径
- 如果用户需要单独查询二进制文件或帮助文件,可使用如下命令:

```
$ whereis -b bash
$ whereis -m bash
```

- 输出信息如下:

```
$ whereis -b bash               #显示bash 命令的二进制程序
bash: /bin/bash /etc/bash.bashrc /usr/share/bash    # bash命令的二进制程序的地址
$ whereis -m bash               #显示bash 命令的帮助文件
bash: /usr/share/man/man1/bash.1.gz  #bash命令的帮助文件地址
```

### locate

Linux locate命令用于查找符合条件的文档，他会去保存文档和目录名称的数据库内，查找合乎范本样式条件的文档或目录。

```
locate [-d ][--help][--version][范本样式...]
```

- -b, --basename -- 仅匹配路径名的基本名称
- -c, --count -- 只输出找到的数量
- -d, --database DBPATH -- 使用 DBPATH 指定的数据库，而不是默认数据库 /var/lib/mlocate/mlocate.db
- -e, --existing -- 仅打印当前现有文件的条目
- -1 -- 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。
- -0, --null -- 在输出上带有NUL的单独条目
- -S, --statistics -- 不搜索条目，打印有关每个数据库的统计信息
- -q -- 安静模式，不会显示任何错误讯息。
- -P, --nofollow, -H -- 检查文件存在时不要遵循尾随的符号链接
- -l, --limit, -n LIMIT -- 将输出（或计数）限制为LIMIT个条目
- -n -- 至多显示 n个输出。
- -m, --mmap -- 被忽略，为了向后兼容
- -r, --regexp REGEXP -- 使用基本正则表达式
- --regex -- 使用扩展正则表达式
- -q, --quiet -- 安静模式，不会显示任何错误讯息
- -s, --stdio -- 被忽略，为了向后兼容
- -o -- 指定资料库存的名称。
- -h, --help -- 显示帮助
- -i, --ignore-case -- 忽略大小写
- -V, --version -- 显示版本信息

**实例**

- 查找 passwd 文件，输入以下命令：

```
locate passwd
```

- 搜索 etc 目录下所有以 sh 开头的文件 ：

```
locate /etc/sh
```

- 忽略大小写搜索当前用户目录下所有以 r 开头的文件 ：

```
locate -i ~/r
```

> **附加说明**
>
> - locate 与 find 不同: find 是去硬盘找，locate 只在 /var/lib/slocate 资料库中找。
> - locate 的速度比 find 快，它并不是真的查找，而是查数据库，一般文件数据库在 /var/lib/slocate/slocate.db 中，所以 locate 的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库 ，命令为：
>
> ```
> updatedb
> ```
>
> - 默认情况下 updatedb 每天执行一次。

### find

Linux find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。

```
find [path] <option>
```

- `-name,-iname` : 文件名称符合 name 的文件。iname 会忽略大小写
- `-type` : 指定文件类型
  - d: 目录
  - c: 字型装置文件
  - b: 区块装置文件
  - p: 具名贮列
  - f: 一般文件
  - l: 符号连结
  - s: socket
-  -size [+-]SIZE：搜寻比 SIZE 还要大（+）或小（-）的文件。这个 SIZE 的规格有：c: 代表 Byte， k: 代表 1024Bytes。所以，要找比 50KB还要大的文件，就是“ -size +50k ”
- -perm mode  ：搜寻文件权限“刚好等于” mode 的文件，这个 mode 为类似 chmod的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！
-  -perm -mode ：搜寻文件权限“必须要全部囊括 mode 的权限”的文件，举例来说，我们要搜寻 -rwxr--r-- ，亦即 0744 的文件，使用 -perm -0744，
- 当一个文件的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来，因为 -rwsr-xr-x 的属性已经囊括了 -rwxr--r-- 的属性了。
-  -perm /mode ：搜寻文件权限“包含任一 mode 的权限”的文件，举例来说，我们搜 -rwxr-xr-x ，亦即 -perm /755 时，但一个文件属性为 -rw------- 也会被列出来，因为他有 -rw.... 的属性存在！
- -mtime  n ：n 为数字，意义为在 n 天之前的“一天之内”被更动过内容的文件
- -mtime +n ：列出在 n 天之前（不含 n 天本身）被更动过内容的文件文件名
- -mtime -n ：列出在 n 天之内（含 n 天本身）被更动过内容的文件文件名
- -newer file ：file 为一个存在的文件，列出比 file 还要新的文件文件名
- -uid n ：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在/etc/passwd 里面与帐号名称对应的数字。
-  -gid n ：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在/etc/group
-  -user name ：name 为使用者帐号名称喔！例如 dmtsai 
-  -group name：name 为群组名称喔，例如 users 
-  -nouser    ：寻找文件的拥有者不存在 /etc/passwd 的人
-  -nogroup   ：寻找文件的拥有群组不存在于 /etc/group 的文件                当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者，这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。

**实例**

- 将当前目录及其子目录下所有文件后缀为`.c`的文件列出来:

```
$ find . -name "*.c"
```

- 将当前目录及其子目录下所有src 目录列出来:

```
$ find . -name src -type d
```

- 将过去系统上面 24 小时内有更动过内容 （mtime） 的文件列出

```
$ find / -mtime 0
```

- 过去系统上面三天前 24 小时内有更动过内容 （mtime） 的文件列出

```
$ find / -mtime 3
```

- 寻找 /etc 下面的文件，如果文件日期比 /etc/passwd 新就列出

```
$ find /etc -newer /etc/passwd
```

## 文件属性

```shell
$ ll
total 264
drwx------@   3 cian  staff    96B Mar 13 17:38 Applications
drwxr-xr-x@   7 cian  staff   224B Jul 28 15:49 Code
drwx------@   9 cian  staff   288B Jul 29 14:06 Desktop
drwx------@  12 cian  staff   384B Jul 29 22:29 Documents
drwx------+   7 cian  staff   224B Jul 29 20:18 Downloads
drwx------@  75 cian  staff   2.3K Jun 12 10:19 Library
drwx------+   8 cian  staff   256B Jun  2 08:35 Movies
drwx------+   7 cian  staff   224B Mar 14 10:24 Music
drwx------+   7 cian  staff   224B Jun  5 13:26 Pictures
drwxr-x---+   5 cian  staff   160B Jul  9 11:04 Public
drwxr-xr-x    7 cian  staff   224B Jun 19 00:08 Virtual Machines.localized
drwx------   11 cian  staff   352B May  2 16:01 iCloud Drive (Archive)
drwxr-xr-x  305 cian  staff   9.5K Jul 11 20:19 node_modules
-rw-r--r--@   1 cian  staff   129K Jul 11 20:19 package-lock.json
```

- 在Linux中第一个字符代表这个文件是目录,文件或链接文件等等:
  - 当为[ **d** ]则是目录
  - 当为[ **-** ]则是文件
  - 若是[ **l** ]则表示为链接文档 ( link file )
  - 若是[ **b** ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )
  - 若是[ **c** ]则表示为装置文件里面的串行端口设备,例如键盘,鼠标 ( 一次性读取装置 )
- 接下来的字符中,以三个为一组,且均为『rwx』 的三个参数的组合
  - [ r ]代表可读(read)
  - [ w ]代表可写(write)
  - [ x ]代表可执行(execute)
  - [ - ]无权限
- 每个文件的属性由左边第一部分的10个字符来确定(如下图):

![image-20200729223243490](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-vZfXuBbAkPIRg2J.png)

- 从左至右用0-9这些数字来表示
  - 第0位确定文件类型
  - 第1-3位确定属主(该文件的所有者)拥有该文件的权限
  - 第4-6位确定属组(所有者的同组用户)拥有该文件的权限
  - 第7-9位确定其他用户拥有该文件的权限
- 其中
  - 第1,4,7位表示读权限,如果用"r"字符表示,则有读权限,如果用"-"字符表示,则没有读权限
  - 第2,5,8位表示写权限,如果用"w"字符表示,则有写权限,如果用"-"字符表示没有写权限
  - 第3,6,9位表示可执行权限,如果用"x"字符表示,则有执行权限,如果用"-"字符表示,则没有执行权限
- 对于文件来说,它都有一个特定的所有者,也就是对该文件具有所有权的用户, 同时,在Linux系统中,用户是按组分类的,一个用户属于一个或多个组, 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户,因此,Linux系统按文件所有者,文件所有者同组用户和其他用户来规定了不同的文件访问权限
- 在以上实例中,属主为cian和属组为staff

### chgrp

- 更改文件属组

```shell
chgrp [-R] 属组名 文件名
-R #递归更改文件属组
```

### chown

- 更改文件属主,也可以同时更改文件属组

```shell
chown [–R] 属主名 文件名
chown [-R] 属主名:属组名 文件名
```

- -c 显示更改的部分的信息
- -f 忽略错误信息
- -h 修复符号链接
- -R 处理指定目录以及其子目录下的所有文件
- -v 显示详细的处理信息
- -deference 作用于符号链接的指向,而不是链接文件本身

### chmod

- Linux文件属性有两种设置方法,一种是数字(常用的是数字),一种是符号
- Linux文件的基本权限就有九个,分别是owner/group/others三种身份各有自己的read/write/execute 权限

```
chmod [-R] xyz <path>
```

- u 表示该文件的拥有者,g 表示与该文件的拥有者属于同一个群体(group)者,o 表示其他以外的人,a 表示这三者皆是
- \+ 表示增加权限,- 表示取消权限,= 表示唯一设定权限
- r 表示可读取,w 表示可写入,x 表示可执行,X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行
- -c : 若该文件权限确实已经更改,才显示其更改动作
- -f : 若该文件权限无法被更改也不要显示错误讯息
- -v : 显示权限变更的详细资料
- -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)
- --help : 显示辅助说明
- --version : 显示版本

- 此外chmod也可以用数字来表示权限如 :

```
chmod abc file
```

其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。

> r=4，w=2，x=1
>
> - 若要 rwx 属性则 4+2+1=7；
> - 若要 rw- 属性则 4+2=6；
> - 若要 r-x 属性则 4+1=5。

- 将文件 file1.txt 设为所有人皆可读取 :

```
chmod a+r file1.txt
```

- 将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :

```
chmod ug+w,o-w file1.txt file2.txt
```

- 为 ex1.py 文件拥有者增加可执行权限:

```
chmod u+x ex1.py
```

### chattr

- Linux chattr命令用于改变文件属性

> 这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式：
>
> 1. a：让文件或目录仅供附加用途。
> 2. b：不更新文件或目录的最后存取时间。
> 3. c：将文件或目录压缩后存放。
> 4. d：将文件或目录排除在倾倒操作之外。
> 5. i：不得任意更动文件或目录。
> 6. s：保密性删除文件或目录。
> 7. S：即时更新文件或目录。
> 8. u：预防意外删除。

```
chattr [-RV][-v<版本编号>][+/-/=<属性>][文件或目录...]
```

- -R 递归处理，将指定目录下的所有文件及子目录一并处理
- -v<版本编号> 设置文件或目录版本
- -V 显示指令执行过程
- +<属性> 开启文件或目录的该项属性
- -<属性> 关闭文件或目录的该项属性
- =<属性> 指定文件或目录的该项属性

**实例**

- 用chattr命令防止系统中某个关键文件被修改：

```
chattr +i /etc/resolv.conf
```

- 查看属性

```
$ lsattr /etc/resolv.conf
----i-------- /etc/resolv.conf
```

- 让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件：

```
chattr +a /var/log/messages
```

### file

- 查看文件的类型

```
file filename
```

## 文件内容

### cat

- 由第一行开始显示文件内容

``` 
cat filename
```

- `-n`:显示行号

### tac

-  从最后一行开始显示,可以看出 tac 是 cat 的倒着写

### nl

-  显示的时候输出行号

### more

- 一页一页的显示文件内容
- 空格代表翻页
- `enter` 代表向下看一行
- ` :f` 查看行号

### less

- 空格下翻页
- `pageDown`,`pageUp`键代表翻动页面
- `q`退出
- 查找字符串
    - `/` 向下查询
    - `?` 向上查询
- 要查询的字符串
    - `n` 继续搜寻下一个
    - `N` 上寻找

### head

- 查看文件前几行
- `-n`:控制显示的行数

### tail

- 查看文件后几行
- `-n`"控制显示的行数

### wc

- 利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为"-"，则wc指令会从标准输入设备读取数据。

```
wc [-clw][--help][--version][文件...]
```

- `-c,--bytes,--chars`:只显示Bytes数。
- `-l,--lines`:显示行数。
- `-w,--words`:只显示字数。

### grep

- Linux grep 命令用于查找文件里符合条件的字符串

```shell
grep [正则表达式] [文件或目录...]
```

- **-v 或 --invert-match** : 显示不包含匹配文本的所有行

## 文件压缩

### zip

```
zip -q -r html.zip /home/html
```

- -q 不显示指令执行过程。
- -r 递归处理，将指定目录下的所有文件和子目录一并处理。

### gzip

```
gzip test.tar.gz
```

### tar

```
tar -zcvf filename ~/tar
```

- z: gzip压缩格式
- j: bzip2压缩格式
- J:xz压缩格式
- Z:Z 压缩格式
- -c或--create:建立新的备份文件
- v: verbose详细信息
- f:file(file=archieve)文件

## 文件解压

### unzip

```
unzip filename.zip -d /usr/local/
```

- -d<目录> 指定文件解压缩后所要存储的目录。

### gunzip

```
gunzip test.targz 
```

### tar

```
tar -zxvf filename.tar.gz -C ~/tar
```

- z: gzip压缩格式
- j: bzip2压缩格式
- J:xz压缩格式
- Z:Z 压缩格式
- -x或--extract或--get:从备份文件中还原文件
- v: verbose详细信息
- f:file(file=archieve)文件
- -C<目的目录>或--directory=<目的目录>:切换到指定的目录

- **事实上, 从1.15版本开始tar就可以自动识别压缩的格式,故不需人为区分压缩格式就能正确解压**

```
tar -xvf filename.tar.gz
tar -xvf filename.tar.bz2
tar -xvf filename.tar.xz
tar -xvf filename.tar.Z
```

## 传输文件

### sftp

#### 登陆

```shell
sftp user@ip
```

#### 帮助

```shell
help
```

建立连接后, linux shell中的$编程了sftp>,  这也对, 现在执行以下help, 可以看看sftp支持哪些命令

#### 查看当前目录的路径

```shell
pwd
lpwd
```

pwd是看远端服务器的目录, 即sftp服务器默认的当前目录,  lpwd是查看本地目录

#### 查看当前目录的文件

```shell
ls
lls
```

ls是看sftp服务器下当前目录下的东东, lls是查看本地当前目录下

#### 上传

```shell
put a.txt
```

把linux本地目录下的a.txt文件上传到sftp服务器的当前目录下

#### 下载

```shell
get b.txt
```

把sftp服务器当前目录下的b.txt文件下载到本地当前目录下

#### 本地执行

```shell
!command
```

- 这个是指在本地上执行command这个命令, 比如!ls是列举本地当前目录下的东东, !rm a.txt是删除本地当前目录下的a.txt文件
- 这个命令非常非常有用, 因为在sftp> 后输入命令, 默认值针对sftp服务器的, 所以执行rm a.txt删除的是sftp服务器上的a.txt文件, 而非本地的linux上的a.txt文件

#### 退出

```shell
exit
quit
```

### scp

- Linux scp 命令用于 Linux 之间复制文件和目录
- scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令
- scp 是加密的,rcp是不加密的,scp 是 rcp 的加强版

#### 语法

```bash
scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]
[-l limit] [-o ssh_option] [-P port] [-S program]
[[user@]host1:]file1 [...] [[user@]host2:]file2
```

简易写法:

```
scp [可选参数] file_source file_target
```

**参数说明**:

- -1:强制scp命令使用协议ssh1
- -2:强制scp命令使用协议ssh2
- -4:强制scp命令只使用IPv4寻址
- -6:强制scp命令只使用IPv6寻址
- -B:使用批处理模式(传输过程中不询问传输口令或短语)
- -C:允许压缩,(将-C标志传递给ssh,从而打开压缩功能)
- -p:保留原文件的修改时间,访问时间和访问权限
- -q:不显示传输进度条
- -r:递归复制整个目录
- -v:详细方式显示输出,scp和ssh会显示出整个过程的调试信息,这些信息用于调试连接,验证和配置问题
- -c cipher:以cipher将数据传输进行加密,这个选项将直接传递给ssh
- -F ssh_config:指定一个替代的ssh配置文件,此参数直接传递给ssh
- -i identity_file:从指定文件中读取传输时使用的密钥文件,此参数直接传递给ssh
- -l limit:限定用户所能使用的带宽,以Kbit/s为单位
- -o ssh_option:如果习惯于使用ssh_config中的参数传递方式
- -P port:注意是大写的P, port是指定数据传输用到的端口号
- -S program:指定加密传输时所使用的程序,此程序必须能够理解ssh的选项

#### 复制文件

```shell
scp local_file remote_username@remote_ip:remote_folder
# OR
scp local_file remote_username@remote_ip:remote_file
# OR
scp local_file remote_ip:remote_folder
# OR
scp local_file remote_ip:remote_file
```

- 第1,2个指定了用户名,命令执行后需要再输入密码,第1个仅指定了远程的目录,文件名字不变,第2个指定了文件名
- 第3,4个没有指定用户名,命令执行后需要输入用户名和密码,第3个仅指定了远程的目录,文件名字不变,第4个指定了文件名

**实例**

```shell
scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music
scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music/001.mp3
scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music
scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music/001.mp3
```

#### 复制目录

```shell
scp -r local_folder remote_username@remote_ip:remote_folder
# OR
scp -r local_folder remote_ip:remote_folder
```

- 第1个指定了用户名,命令执行后需要再输入密码
- 第2个没有指定用户名,命令执行后需要输入用户名和密码

**实例**

```
scp -r /home/space/music/ root@www.runoob.com:/home/root/others/
scp -r /home/space/music/ www.runoob.com:/home/root/others/
```

- 上面命令将本地 music 目录复制到远程 others 目录下

#### 说明

- 从远程复制到本地,只要将从本地复制到远程的命令的后2个参数调换顺序即可
- 如果远程服务器防火墙有为scp命令设置了指定的端口,我们需要使用 -P 参数来设置命令的端口号,命令格式如下:

```shell
#scp 命令使用端口号 4588
scp -P 4588 remote@www.runoob.com:/usr/local/sin.sh /home/administrator
```

- 使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限,否则scp命令是无法起作用的

## 链接

**硬链接**

- A---B,假设B是A的硬链接,那么他们两个指向了同一个文件,即允许一个文件拥有多个路径,用户可以通过这种机制建立硬链接到一些重要文件上,防止误删

**软链接**

- 类似Window下的快捷方式,删除的源文件,快捷方式也访问不了

### ln

> **软链接**：
>
> - 软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式
> - 软链接可以 跨文件系统 ，硬链接不可以
> - 软链接可以对一个不存在的文件名进行链接
> - 软链接可以对目录进行链接
>
> **硬链接**：
>
> - 硬链接，以文件副本的形式存在。但不占用实际空间。
> - 不允许给目录创建硬链接
> - 硬链接只有在同一个文件系统中才能创建

```
 ln [参数][源文件或目录][目标文件或目录]
```

- -b 删除，覆盖以前建立的链接
- -d 允许超级用户制作目录的硬链接
- -f 强制执行
- -i 交互模式，文件存在则提示用户是否覆盖
- -n 把符号链接视为一般目录
- -s 软链接(符号链接)
- -v 显示详细的处理过程

## 磁盘管理

### df

- 列出文件系统整体的磁盘使用量

```shell
df
/dev/disk1s1                                      373871240 239508040  105521744    70%   1710292 1867645908    0%   /System/Volumes/Data

-h #进制换算
```

### du

- 检查当前目录空间的使用量

```shell
du
248	./.config/ranger
24	./.config/configstore
7944	./.config/clash
104	./.config/filezilla
8344	./.config

-a #包括隐藏文件
-h #进制换算
-sm #查看本目录所占用的容量
-sm 目录 #查看指定目录所占的容量
-sm 目录/* #查看指定目录下的所有目录所占的容量
```

### mount

- 挂载本地磁盘或者文件

```shell
mount 外部设备路径 目标目录
mount /dev/usb /mnt/usb
```

### unmount

- 卸载本地磁盘或者文件

```shell
umount 挂载位置
-f #
```