---
title: Java JMM 与 volatile
categories:
  - Software
  - Language
  - Java
  - JavaSE
  - 多线程
---
# Java JMM 与 volatile

## JMM

- Java虚拟机规范中定义了一种Java内存模型（Java Memory Model，即JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，Java内存模型的主要目标就是**定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的细节**
- JMM中规定所有的变量都存储在主内存（Main Memory）中，每条线程都有自己的工作内存（Work Memory)，线程的工作内存中保存了该线程所使用的变量的从主内存中拷贝的副本，线程对于变量的读，写都必须在工作内存中进行，而不能直接读，写主内存中的变量，同时，本线程的工作内存的变量也无法被其他线程直接访问，必须通过主内存完成。

### JMM模型下的线程间通信

- 线程间通信必须要经过主内存，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤：
    1. 线程A把本地内存A中更新过的共享变量刷新到主内存中去。
    2. 线程B到主内存中去读取线程A之前已更新过的共享变量。

![](C:\Users\lushan11\AppData\Roaming\Typora\typora-user-images\image-20210611095441923.png)

- 关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：
    1. **lock（锁定）**：作用于主内存的变量，把一个变量标识为一条线程独占状态。
    2. **unlock（解锁）**：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
    3. **read（读取）**：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。
    4. **load（载入）**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
    5. **use（使用）**：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
    6. **assign（赋值）**：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
    7. **store（存储）**：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
    8. **write（写入）**：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。
- Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：
    - 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作，但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。
    - 不允许read和load,store和write操作之一单独出现。
    - 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。
    - 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
    - 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
    - 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁，lock和unlock必须成对出现。
    - 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。
    - 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。
    - 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）

## volatile

- volatile关键字是用来保证有序性和可见性的。

### 可见性

> - 据Java内存模型中的规定，可以总结出以下几条happens-before规则，Happens-before的前后两个操作不会被重排序且后者对前者的内存可见。
>     - 程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。
>     - 监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。
>     - volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。
>     - 线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。
>     - 线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结，或者从Thread.join调用中成功返回，或Thread.isAlive返回false
>     - 中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。
>     - 终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。
>     - 传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C
> - Happens-before关系只是对Java内存模型的一种近似性的描述，它并不够严谨，但便于日常程序开发参考使用，关于更严谨的Java内存模型的定义和描述，请阅读JSR-133原文或Java语言规范章节17.4

- 对于普通共享变量，线程A将变量修改后，体现在此线程的工作内存，在尚未同步到主内存时，若线程B使用此变量，从主内存中获取到的是修改前的值，便发生了共享变量值的不一致，也就是出现了**线程的可见性问题**
- 当对volatile变量执行写操作后，JMM会把工作内存中的最新变量值强制刷新到主内存。
- 写操作会导致其他线程中的缓存无效。
- 这样，其他线程使用缓存时，发现本地工作内存中此变量无效，便从主内存中获取，这样获取到的变量便是最新的值，实现了线程的可见性。

### 有序性

> - **as-if-serial语义**：不管怎么重排序（编译器和处理器为了提高并行度）,（单线程）程序的执行结果不能被改变，（编译器，runtime和处理器都必须遵守as-if-serial语义）
>
> - **指令重排序**：在Java中，JVM能够根据处理器特性（CPU多级缓存系统，多核处理器等）适当对机器指令进行重排序，最大限度发挥机器性能，Java中的指令重排序有两次，第一次发生在将字节码编译成机器码的阶段，第二次发生在CPU执行的时候，也会适当对指令进行重排。
>
> - **内存访问重排序**：计算机系统中，为了尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存（cache）以提高性能，其模型如下图所示：
>
>     <img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/20210611123727.png" alt="处理器Cache模型" style="zoom:50%;" />
>
> - 在这种模型下会存在一个现象，即缓存中的数据与主内存的数据并不是实时同步的，各CPU（或CPU核心）间缓存的数据也不是实时同步的，这导致在同一个时间点，各CPU所看到同一内存地址的数据的值可能是不一致的，从程序的视角来看，就是在同一个时间点，各个线程所看到的共享变量的值可能是不一致的。
>
> - 有的观点会将这种现象也视为重排序的一种，命名为"内存系统重排序”，因为这种内存可见性问题造成的结果就好像是内存访问指令发生了重排序一样。

- `volatile`是通过编译器在生成字节码时，在指令序列中添加**内存屏障**来禁止指令重排序的。
- 硬件层面的"**内存屏障**”:
    - **sfence**：即写屏障（Store Barrier)，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存，以保证写入的数据立刻对其他线程可见。
    - **lfence**：即读屏障（Load Barrier)，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据，以保证读取的是最新的数据。
    - **mfence**：即全能屏障（modify/mix Barrier )，兼具sfence和lfence的功能。
    - **lock 前缀**:lock不是内存屏障，而是一种锁，执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU
- JMM层面的"**内存屏障**”:
    - **LoadLoad屏障**：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
    - **StoreStore屏障**：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
    - **LoadStore屏障**：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
    - **StoreLoad屏障**：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。
- JVM的实现会在volatile读写前后均加上内存屏障，在一定程度上保证有序性，如下所示：

> LoadLoadBarrier
> volatile 读操作。
> LoadStoreBarrier
>
> StoreStoreBarrier
> volatile 写操作。
> StoreLoadBarrier