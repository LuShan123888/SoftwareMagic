---
title: Shell 特殊符号
categories:
- Software
- Language
- Shell
---
# Shell 特殊符号

## \#

- 用于指定执行shell的命令,常出现在一行的开头

```
#!/bin/bash
```

- 表示符号后面的是注解文字,不会被执行

```
# This line is comments.
echo "a = $a" # a = 0
```

**注意**:如果被用在指令中,或者引号双引号括住的话,或者在倒斜线的后面,那他就变成一般符号,不具上述的特殊功能

## ~

- 代表使用者的 home 目录

```shell
cd ~
#也可以直接在符号后加上某帐户的名称
cd ~user
#或者当成是路径的一部份
~/bin
```

- `~+`:当前的工作目录,这个符号代表当前的工作目录,和内建指令 pwd的作用是相同的

```shell
echo ~+/var/log
```

- `~-`:上次的工作目录,这个符号代表上次的工作目录

```shell
echo ~-/etc/httpd/logs
```

## ;

- 连续指令功能

```
cd ~/backup ; mkdir startup ;cp ~/.* startup/.
```

## .

- 当前shell执行脚本命令

```shell
./test.sh # 执行当前路径下的shell脚本test.sh
```

- 表示当前目录

```shell
cd ./bgk # 进入当前目录下的bgk目录下
```

- 连续使用两个`.`表示上层目录

```shell
cd ../bgk # 进入上层目录下的bgk目录下
```

## `

- 命令行替换,相当于`$()`

```shell
fdv=`date +%F`echo \"Today $fdv\" # 在倒引号内的 date +%F 会被视为指令,执行的结果会存入fdv中
```

## /

- 在路径表示时,代表目录

```
cd /etc/rc.dcd ../..cd /
```

- 单一的`/`代表 root 根目录的意思

```
cd /
```

## \

- 在交互模式下的escape 字元
- 放在指令前,有取消 aliases的作用

```shell
type rmrm is aliased to `rm -i` # \rm ./*.log
# 在 rm 指令前加上 escape 字元,作用是暂时取消别名的功能,将 rm 指令还原
```

- 放在特殊符号前,则该特殊符号的作用消失
- 放在指令的最末端,表示指令连接下一行

## :

- 在 bash 中,这是一个内建指令:\"什么事都不干\",但返回状态值 0

```
:
echo $? # 回应为 0
: > f.$$ # 相当于cat /dev/null >f.$$
```

## ?

- 在文件名扩展(Filename expansion)上扮演的角色是匹配一个任意的字元,但不包含 null 字元,可以做比较精确的档名匹配

```
ls a?a1
```

## *

- 在文件名扩展(Filename expansion)上,用来代表任何字元,包含 null 字元

```
ls *.xml
```

## (  )

- **命令组**:新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号,各命令和括号之间不必有空格,括号中的变量不能够被脚本余下的部分使用
- **用于初始化数组**,如:`array=(a b c d)`

## { }

- **大括号拓展**:(通配(globbing))将对大括号中的文件名做扩展,在大括号中,不允许有空白,除非这个空白被引用或转义
    - 对大括号中的以`.`分割的文件列表进行拓展
    - 对大括号中以`..`分割的顺序文件列表起拓展作用
    - 对大括号中以`-`分割的顺序文件列表起拓展作用

```shell
ls {ex1,ex2}.sh
ex1.sh  ex2.sh

ls {ex{1..3},ex4}.sh
ex1.sh  ex2.sh  ex3.sh  ex4.sh

ls {ex[1-3],ex4}.sh
ex1.sh  ex2.sh  ex3.sh  ex4.sh
```

- **代码块**:又被称为内部组,这个结构事实上创建了一个匿名函数,与小括号中的命令不同,大括号内的命令不会新开一个子shell运行,即脚本余下部分仍可使用括号内变量,括号内的命令间用分号隔开,最后一个也必须有分号,`{}`的第一个命令和左括号之间必须要有一个空格

## &

- 单一个`&`符号,且放在完整指令列的最后端,即表示将该指令列放入后台中工作

```
tar cvfz data.tar.gz data > /dev/null&
```

### &&

前面命令返回值为0才执行后面的命令

```
ls && echo "ok"
```

### ||

前面命令返回值为非0才执行后面的命令

```
lls || echo "ok"
```