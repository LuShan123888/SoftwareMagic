---
title: DataStruct
categories:
- Software
- DataStruct
---
# DataStruct

##  数组

- 数组可以说是最基本最常见的数据结构，数组一般用来存储相同类型的数据，可通过数组名和下标进行数据的访问和更新，数组中元素的存储是按照先后顺序进行的，同时在内存中也是按照这个顺序进行连续存放，数组相邻元素之间的内存地址的间隔一般就是数组数据类型的大小

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617182831788.jpeg" alt="img" style="zoom: 67%;" />

## 链表

- 链表相较于数组，除了数据域，还增加了指针域用于构建链式的存储数据，链表中每一个节点都包含此节点的数据和指向下一节点地址的指针，由于是通过指针进行下一个数据元素的查找和访问，使得链表的自由度更高
- 这表现在对节点进行增加和删除时，只需要对上一节点的指针地址进行修改，而无需变动其它的节点，不过事物皆有两极，指针带来高自由度的同时，自然会牺牲数据查找的效率和多余空间的使用
- 一般常见的是有头有尾的单链表，对指针域进行反向链接，还可以形成双向链表或者循环链表

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617182831817.jpeg" alt="img" style="zoom: 67%;" />

### 链表与数组对比

- 链表和数组在实际的使用过程中需要根据自身的优劣势进行选择，链表和数组的异同点也是面试中高频的考察点之一，这里对单链表和数组的区别进行了对比和总结

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617182831699.png" alt="img" style="zoom: 67%;" />

## 跳表

- 从上面的对比中可以看出，链表虽然通过增加指针域提升了自由度，但是却导致数据的查询效率恶化，特别是当链表长度很长的时候，对数据的查询还得从头依次查询，这样的效率会更低，跳表的产生就是为了解决链表过长的问题，通过增加链表的多级索引来加快原始链表的查询效率，这样的方式可以让查询的时间复杂度从O(n)提升至O(logn)

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617183436621.jpeg" alt="img" style="zoom: 67%;" />

- 跳表通过增加的多级索引能够实现高效的动态插入和删除，其效率和红黑树和平衡二叉树不相上下，目前Redis和levelDB都有用到跳表
- 从上图可以看出，索引级的指针域除了指向下一个索引位置的指针，还有一个down指针指向低一级的链表位置，这样才能实现跳跃查询的目的

## 栈

- 栈是一种比较简单的数据结构，常用一句话描述其特性，后进先出，栈本身是一个线性表，但是在这个表中只有一个入口允许数据的进出
- 栈的常用操作包括入栈push和出栈pop,对应于数据的压入和压出，还有访问栈顶数据，判断栈是否为空和判断栈的大小等，由于栈后进先出的特性，常可以作为数据操作的临时容器，对数据的顺序进行调控，与其它数据结构相结合可获得许多灵活的处理

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617183612558.gif" alt="img" style="zoom: 67%;" />

##  队列

- 队列是栈的兄弟结构，与栈的后进先出相对应，队列是一种先进先出的数据结构，顾名思义，队列的数据存储是如同排队一般，先存入的数据先被压出，常与栈一同配合，可发挥最大的实力

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617183643300.gif" alt="img" style="zoom:67%;" />

## 树

- 树作为一种树状的数据结构，其数据节点之间的关系也如大树一样，将有限个节点根据不同层次关系进行排列，从而形成数据与数据之间的父子关系
- 树的数据存储在结点中，每个结点有零个或者多个子结点，没有父结点的结点在最顶端，成为根节点，没有非根结点有且只有一个父节点，每个非根节点又可以分为多个不相交的子树，这意味着树是具备层次关系的，父子关系清晰，家庭血缘关系明朗，这也是树与图之间最主要的区别

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617183706636.jpeg" alt="img" style="zoom: 67%;" />

- 树其实可看作是链表的高配版，树的实现就是对链表的指针域进行了扩充，增加了多个地址指向子结点，同时将"链表”竖起来，从而凸显了结点之间的层次关系，更便于分析和理解
- 树可以衍生出许多的结构，若将指针域设置为双指针，那么即可形成最常见的二叉树，即每个结点最多有两个子树的树结构，二叉树根据结点的排列和数量还可进一度划分为完全二叉树，满二叉树，平衡二叉树，红黑树等
- **完全二叉树**:除了最后一层结点，其它层的结点数都达到了最大值，同时最后一层的结点都是按照从左到右依次排布
- **满二叉树**:除了最后一层，其它层的结点都有两个子结点

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617183755908.jpeg" alt="img" style="zoom:67%;" />

### 平衡二叉树

- **二叉排序树**:是一棵空树，或者：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值，若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值，它的左，右子树也分别为二叉排序树
- 平衡二叉树又被称为AVL树，它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1,并且左右两个子树都是一棵平衡二叉树
- **树的高度**:结点层次的最大值
- **平衡因子**:左子树高度 - 右子树高度

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617184021192.jpeg" alt="img" style="zoom:67%;" />

- 平衡二叉树的产生是为了解决二叉排序树在插入时发生线性排列的现象，由于二叉排序树本身为有序，当插入一个有序程度十分高的序列时，生成的二叉排序树会持续在某个方向的字数上插入数据，导致最终的二叉排序树会退化为链表，从而使得二叉树的查询和插入效率恶化

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617182831807.jpeg" alt="img" style="zoom: 67%;" />

- 平衡二叉树的出现能够解决上述问题，但是在构造平衡二叉树时，却需要采用不同的调整方式，使得二叉树在插入数据后保持平衡，主要的四种调整方式有LL(左旋),RR(右旋),LR(先左旋再右旋),RL(先右旋再左旋)
- 在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理，从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用**单旋转**进行平衡化，如果这三个结点位于一条折线上，则采用**双旋转**进行平衡化

#### 左旋

- S为当前需要左旋的结点,E为当前结点的父节点

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617182831842.jpeg" alt="img" style="zoom: 67%;" />

- 将当前结点S的左孩子旋转为当前结点父结点E的右孩子，同时将父结点E旋转为当前结点S的左孩子

![](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617182831758.gif)

#### 右旋

- S为当前需要左旋的结点,E为当前结点的父节点，右单旋是左单旋的镜像旋转

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640.jpeg" alt="img" style="zoom:67%;" />

- 将当前结点S的左孩子E的右孩子旋转为当前结点S的左孩子，同时将当前结点S旋转为左孩子E的右孩子

![](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640.gif)

### 红黑树

- 平衡二叉树(AVL)为了追求高度平衡，需要通过平衡处理使得左右子树的高度差必须小于等于1,高度平衡带来的好处是能够提供更高的搜索效率，其最坏的查找时间复杂度都是O(logN),但是由于需要维持这份高度平衡，所付出的代价就是当对树种结点进行插入和删除时，需要经过多次旋转实现复衡，这导致AVL的插入和删除效率并不高，而红黑树能够兼顾搜索和插入删除的效率
- **性质**
    1. 每个结点要么是红的要么是黑的
    2. 根结点是黑的
    3. 父子节点之间不能出现两个连续的红节点，即如果一个结点是红的，那么它的两个子节点都是黑的
    4. 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点
    5. 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的
- 红黑树通过将结点进行红黑着色，使得原本高度平衡的树结构被稍微打乱，平衡程度降低，红黑树不追求完全平衡，只要求达到部分平衡，这是一种折中的方案，大大提高了结点删除和插入的效率

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617184239702.jpeg" alt="img" style="zoom:67%;" />

### 红黑树与平衡二叉树对比

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617184218702.png" alt="img" style="zoom: 80%;" />

##  堆

- 堆是一种特殊的完全二叉树(complete binary tree),完全二叉树的一个"优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示),每一个结点对应数组中的一个元素
- 对于给定的某个结点的下标 i,可以很容易的计算出这个结点的父结点和孩子结点的下标

    - Parent(i) = floor(i/2),i 的父节点下标
    - Left(i) = 2i,i 的左子节点下标
    - Right(i) = 2i + 1,i 的右子节点下标
- 不仅如此，堆还有一个性质：堆中某个节点的值总是不大于或不小于其父节点的值，将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617184702880.jpeg" alt="img" style="zoom:67%;" />

##  Hash表

- Hash表是一种通过键值对直接访问数据的机构，在初中，我们就学过一种能够将一个x值通过一个函数获得对应的一个y值的操作，叫做映射,Hash表的实现原理正是映射的原理，通过设定的一个关键字和一个映射函数，就可以直接获得访问数据的地址，实现O(1)的数据访问效率，在映射的过程中，事先设定的函数就是一个映射表,Hash函数

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617184731169.jpeg" alt="img" style="zoom:67%;" />

> **Hash函数**
>
> - **直接寻址法**:取关键字或关键字的某个线性函数值为散列地址
>
>     **数字分析法**:通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址，例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址
>
>     **平方取中法**:当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址，这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址
>
>     **取随机数法**:使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合
>
>     **除留取余法**:取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址，这种方式也可以在用过其他方法后再使用，该函数对 m 的选择很重要，一般取素数或者直接用 n

- 确定好散列函数之后，通过某个`key`值的确会得到一个唯一的`value`地址，但是却会出现一些特殊情况，即通过不同的`key`值可能会访问到同一个地址，这个现象称之为Hash冲突

> **Hash冲突处理**
>
> - **开放地址法**:出现冲突后按照一定算法查找一个空位置存放
>     - **线性探测再散列**:线性探测方法就是线性探测空白单元，当数据通过Hash函数计算应该放在700这个位置，但是700这个位置已经有数据了，那么接下来就应该查看701位置是否空闲，再查看702位置，依次类推
>     - **二次探测再散列**:二次探测是过程是x+1,x+4,x+9,以此类推,**二次探测的步数是原始位置相隔的步数的平方**
>     - **再哈希法**:出现冲突后采用其他的Hash函数计算，直到不再冲突为止
> - **链地址法（拉链法)**:不同与前两种方法，他是在出现冲突的地方存储一个链表，所有的同义词记录都存在其中
> - **建立公共溢出区**:建立公共溢出区的基本思想是：假设Hash函数的值域是[1,m-1],则设向量HashTable[0...m-1]为基本表，每个分量存放一个记录，另外设向量OverTable[0...v]为溢出表，所有关键字和基本表中关键字为同义词的记录，不管它们由Hash函数得到的Hash地址是什么，一旦发生冲突，都填入溢出表

- 目前比较常用的Hash冲突解决方法是链地址法，一般可以通过数组和链表的结合达到冲突数据缓存的目的

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617182831753.jpeg" alt="img" style="zoom:67%;" />

- 左侧数组的每个成员包括一个指针，指向一个链表的头，每发生一个冲突的数据，就将该数据作为链表的节点链接到链表尾部，这样一来，就可以保证冲突的数据能够区分并顺利访问
- 考虑到链表过长造成的问题，还可以使用红黑树替换链表进行冲突数据的处理操作，来提高散列表的查询稳定性

##  图

- 图相较于上文的几个结构可能接触的不多，但是在实际的应用场景中却经常出现，比方说交通中的线路图，常见的思维导图都可以看作是图的具体表现形式
- 图结构一般包括顶点和边，顶点通常用圆圈来表示，边就是这些圆圈之间的连线，边还可以根据顶点之间的关系设置不同的权重，默认权重相同皆为1,此外根据边的方向性，还可将图分为有向图和无向图

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617182831763.jpeg" alt="img" style="zoom:67%;" />

- 图结构用抽象的图线来表示十分简单，顶点和边之间的关系非常清晰明了，但是在具体的代码实现中，为了将各个顶点和边的关系存储下来，却不是一件易事

### 邻接矩阵

- 目前常用的图存储方式为邻接矩阵，通过所有顶点的二维矩阵来存储两个顶点之间是否相连，或者存储两顶点间的边权重

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617185053231.jpeg" alt="img" style="zoom:67%;" />

- 无向图的邻接矩阵是一个对称矩阵，是因为边不具有方向性，若能从此顶点能够到达彼顶点，那么彼顶点自然也能够达到此顶点，此外，由于顶点本身与本身相连没有意义，所以在邻接矩阵中对角线上皆为0

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617182831786.jpeg" alt="img" style="zoom:67%;" />

- 有向图由于边具有方向性，因此彼此顶点之间并不能相互达到，所以其邻接矩阵的对称性不再

- 用邻接矩阵可以直接从二维关系中获得任意两个顶点的关系，可直接判断是否相连，但是在对矩阵进行存储时，却需要完整的一个二维数组，若图中顶点数过多，会导致二维数组的大小剧增，从而占用大量的内存空间

- 而根据实际情况可以分析得，图中的顶点并不是任意两个顶点间都会相连，不是都需要对其边上权重进行存储，那么存储的邻接矩阵实际上会存在大量的0,虽然可以通过稀疏表示等方式对稀疏性高的矩阵进行关键信息的存储，但是却增加了图存储的复杂性

  因此，为了解决上述问题，一种可以只存储相连顶点关系的邻接表应运而生

### 邻接表

- 在邻接表中，图的每一个顶点都是一个链表的头节点，其后连接着该顶点能够直接达到的相邻顶点，相较于无向图，有向图的情况更为复杂，因此这里采用有向图进行实例分析

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617182831790.jpeg" alt="img" style="zoom:67%;" />

- 在邻接表中，每一个顶点都对应着一条链表，链表中存储的是顶点能够达到的相邻顶点，存储的顺序可以按照顶点的编号顺序进行，比如上图中对于顶点B来说，其通过有向边可以到达顶点A和顶点E,那么其对应的邻接表中的顺序即B->A->E,其它顶点亦如此
- 通过邻接表可以获得从某个顶点出发能够到达的顶点，从而省去了对不相连顶点的存储空间，然而，这还不够，对于有向图而言，图中有效信息除了从顶点"指出去”的信息，还包括从别的顶点"指进来”的信息，这里的"指出去”和"指进来”可以用出度和入度来表示

> 入度：有向图的某个顶点作为终点的次数和
>
> 出度：有向图的某个顶点作为起点的次数和

- 由此看出，在对有向图进行表示时，邻接表只能求出图的出度，而无法求出入度，这个问题很好解决，那就是增加一个表用来存储能够到达某个顶点的相邻顶点，这个表称作逆邻接表

### 逆邻接表

- 逆邻接表与邻接表结构类似，只不过图的顶点链接着能够到达该顶点的相邻顶点，也就是说，邻接表时顺着图中的箭头寻找相邻顶点，而逆邻接表时逆着图中的箭头寻找相邻顶点

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617182831798.jpeg" alt="img" style="zoom:67%;" />

- 邻接表和逆邻接表的共同使用下，就能够把一个完整的有向图结构进行表示，可以发现，邻接表和逆邻接表实际上有一部分数据时重合的，因此可以将两个表合二为一，从而得到了所谓的十字链表

### 十字链表

- 十字链表似乎很简单，只需要通过相同的顶点分别链向以该顶点为终点和起点的相邻顶点即可

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617182831810.jpeg" alt="img" style="zoom:67%;" />

- 但这并不是最优的表示方式，虽然这样的方式共用了中间的顶点存储空间，但是邻接表和逆邻接表的链表节点中重复出现的顶点并没有得到重复利用，反而是进行了再次存储，因此，上图的表示方式还可以进行进一步优化
- 十字链表优化后，可通过扩展的顶点结构和边结构来进行正逆邻接表的存储:(下面的弧头可看作是边的箭头那端，弧尾可看作是边的圆点那端)

> **data**:用于存储该顶点中的数据
>
> **firstin指针**:用于连接以当前顶点为弧头的其他顶点构成的链表，即从别的顶点指进来的顶点
>
> **firstout指针**:用于连接以当前顶点为弧尾的其他顶点构成的链表，即从该顶点指出去的顶点

- 边结构通过存储两个顶点来确定一条边，同时通过分别代表这两个顶点的指针来与相邻顶点进行链接:

> **tailvex**:用于存储作为弧尾的顶点的编号
>
> **headvex**:用于存储作为弧头的顶点的编号
>
> **headlink** **指针**:用于链接下一个存储作为弧头的顶点的节点
>
> **taillink** **指针**:用于链接下一个存储作为弧尾的顶点的节点

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-640-20200617182831803.jpeg" alt="img" style="zoom:67%;" />

- 以上图为例子，对于顶点A而言，其作为起点能够到达顶点E,因此在邻接表中顶点A要通过边`AE`(即边04)指向顶点E,顶点A的`firstout`指针需要指向边04的`tailvex`,同时，从B出发能够到达A,所以在逆邻接表中顶点A要通过边`AB`(即边10)指向B,顶点A的`firstin`指针需要指向边10的弧头，即`headlink`指针，依次类推
- 十字链表采用了一种看起来比较繁乱的方式对边的方向性进行了表示，能够在尽可能降低存储空间的情况下增加指针保留顶点之间的方向性，具体的操作可能一时间不好弄懂，建议多看几次上图，弄清指针指向的意义，明白正向和逆向邻接表的表示