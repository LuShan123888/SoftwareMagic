---
title: 数据结构 树
categories:
- Software
- DataStruct
---
# 数据结构 树

## 平衡二叉树

- 在计算机科学中，**AVL树**是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为**高度平衡树**。查找、插入和删除在平均和最坏情况下的时间复杂度都是Logn
- 增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL 树得名于它的发明者 G. M. Adelson-Velsky 和 Evgenii Landis，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。

### 为什么要有平衡二叉树

- 二叉搜索树一定程度上可以提高搜索效率，但是当原序列有序时，例如序列 A = {1，2，3，4，5，6}，构造二叉搜索树如下图。依据此序列构造的二叉搜索树为右斜树，同时二叉树退化成单链表，搜索效率降低为 O(n)。

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-image-20210324180421470.png" alt="image-20210324180421470" style="zoom:50%;" />

- 在此二叉搜索树中查找元素 6 需要查找 6 次。
- 二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。同样的序列 A，将其改为下图的方式存储，查找元素 6 时只需比较 3 次，查找效率提升一倍。

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-image-20210324180354661.png" alt="image-20210324180354661" style="zoom:50%;" />

- 可以看出当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。
- **这种左右子树的高度相差不超过 1 的树为平衡二叉树。**

### 定义

- **平衡二叉查找树**：简称平衡二叉树。由前苏联的数学家 **A**delse-**V**elskil 和 **L**andis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。它具有如下几个性质：
  - 可以是空树。
  - 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。
- 平衡之意，如天平，即两边的分量大约相同。
- 下图不是平衡二叉树，因为结点 60 的左子树不是平衡二叉树。

![image-20210324112550093](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-2021-03-24-image-20210324112550093.png)

- 下图也不是平衡二叉树，因为虽然任何一个结点的左子树与右子树都是平衡二叉树，但高度之差已经超过 1 。

![image-20210324112610932](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-image-20210324112610932.png)

### 平衡因子

- **定义：**某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。
- 在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-image-20210324142814256.png" alt="image-20210324142814256" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-image-20210324142840944.png" alt="image-20210324142840944" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-image-20210324142854039.png" alt="image-20210324142854039" style="zoom:50%;" />

### 节点结构

- 定义平衡二叉树的节点结构

```cpp
typedef struct AVLNode *Tree;

typedef int ElementType;

struct AVLNode{

  int depth; //深度，这里计算每个结点的深度，通过深度的比较可得出是否平衡

  Tree parent; //该结点的父节点

  ElementType val; //结点值

  Tree lchild;

  Tree rchild;

  AVLNode(int val=0) {
    parent = NULL;
    depth = 0;
    lchild = rchild = NULL;
    this->val=val;
  }
};
```

### AVL树插入时的失衡与调整

- 下图是一颗平衡二叉树

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-image-20210324142921354.png" alt="image-20210324142921354" style="zoom:67%;" />

- 在此平衡二叉树插入节点 99 ，树结构变为： 

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-v2-2ddb0f9b832fff594e294dffc299b373_b.gif)

- 在上图中，节点 66 的左子树高度为 1，右子树高度为 3，此时平衡因子为 -2，树失去平衡。
- 在上图中，以节点 66 为父节点的那颗树就称为 **最小失衡子树**。
- **最小失衡子树**：在新插入的结点向上查找，以第一个平衡因子的**绝对值**超过 1 的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。
- **平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的**。根据旋转的方向有两种处理方式，**左旋** 与 **右旋** 。
- 旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。

#### 左旋

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-image-20210324180518280.png" alt="image-20210324180518280" style="zoom:50%;" />

- 以上图为例，加入新节点 99 后， 节点 66 的左子树高度为 1，右子树高度为 3，此时平衡因子为 -2。为保证树的平衡，此时需要对节点 66 做出旋转，因为右子树高度高于左子树，对节点进行左旋操作，流程如下：
  - 节点的右孩子替代此节点位置
  - 右孩子的左子树变为该节点的右子树
  - 节点本身变为右孩子的左子树
- 整个操作流程如下图所示。

![img](https://pic4.zhimg.com/v2-db1cdb0da952a71f9b6d64b2608467eb_b.gif)

- 节点的右孩子替代此节点位置 —— 节点 66 的右孩子是节点 77 ，将节点 77 代替节点 66 的位置
- 右孩子的左子树变为该节点的右子树 —— 节点 77 的左子树为节点 75，将节点 75 挪到节点 66 的右子树位置
- 节点本身变为右孩子的左子树 —— 节点 66 变为了节点 77 的左子树

#### 右旋

- 右旋操作与左旋类似，操作流程为：
  - 节点的左孩子代表此节点
  - 节点的左孩子的右子树变为节点的左子树
  - 将此节点作为左孩子节点的右子树。

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-v2-05246384c1c16537ca6176983bdb2627_b.gif)

### AVL树的四种插入节点方式

- 在所有的不平衡情况中，都是按照先 **寻找最小不平衡树**，然后 **寻找所属的不平衡类别**，再 **根据 4 种类别进行固定化程序的操作**。
- 假设一颗 AVL 树的某个节点为 A，有四种操作会使 A 的左右子树高度差大于 1，从而破坏了原有 AVL 树的平衡性。平衡二叉树插入节点的情况分为以下四种：

| 插入方式 | 描述 | 旋转方式 |
| -------- | ------------------------------------------------------- | ------------ |
| LL | 在 A 的**左子树**根节点的**左子树**上插入节点而破坏平衡 | 右旋转 |
| RR | 在 A 的**右子树**根节点的**右子树**上插入节点而破坏平衡 | 左旋转 |
| LR | 在A的**左子树**根节点的**右子树**上插入节点而破坏平衡 | 先左旋后右旋 |
| RL | 在 A 的**右子树**根节点的**左子树**上插入节点而破坏平衡 | 先右旋后左旋 |

#### A的左孩子的左子树插入节点(LL)

- 只需要执行一次右旋即可。

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-v2-373766641d1c03a78f3d7eac803d1f57_b.gif)

- 实现代码如下：

```cpp
//LL型调整函数
//返回:新父节点
Tree LL_rotate(Tree node){
  //node为离操作结点最近的失衡的结点
  Tree parent=NULL,son;
  //获取失衡结点的父节点
  parent=node->parent;
  //获取失衡结点的左孩子
  son=node->lchild;
  //设置son结点右孩子的父指针
  if (son->rchild!=NULL)  son->rchild->parent=node;
  //失衡结点的左孩子变更为son的右孩子
  node->lchild=son->rchild;
  //更新失衡结点的高度信息
  update_depth(node);
  //失衡结点变成son的右孩子
  son->rchild=node;
  //设置son的父结点为原失衡结点的父结点
  son->parent=parent;
  //如果失衡结点不是根结点，则开始更新父节点
  if (parent!=NULL){
    //如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son
    if (parent->lchild==node){
      parent->lchild=son;
    }else{
      //父节点的右孩子是失衡结点
      parent->rchild=son;
    }
  }
  //设置失衡结点的父亲
  node->parent=son;
  //更新son结点的高度信息
  update_depth(son);
  return son;
}
```

#### A的右孩子的右子树插入节点(RR)

- 只需要执行一次左旋即可。

![img](https://pic1.zhimg.com/v2-e7044e4965ba640ee9ef35beac407cdc_b.gif)

- 实现代码如下：

```cpp
//RR型调整函数
//返回新父节点
Tree RR_rotate(Tree node){
  //node为离操作结点最近的失衡的结点
  Tree parent=NULL,son;
  //获取失衡结点的父节点
  parent=node->parent;
  //获取失衡结点的右孩子
  son=node->rchild;
  //设置son结点左孩子的父指针
  if (son->lchild!=NULL){
    son->lchild->parent=node;
  }
  //失衡结点的右孩子变更为son的左孩子
  node->rchild=son->lchild;
  //更新失衡结点的高度信息
  update_depth(node);
  //失衡结点变成son的左孩子
  son->lchild=node;
  //设置son的父结点为原失衡结点的父结点
  son->parent=parent;
  //如果失衡结点不是根结点，则开始更新父节点
  if (parent!=NULL){
    //如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son
    if (parent->lchild==node){
      parent->lchild=son;
    }else{
      //父节点的右孩子是失衡结点
      parent->rchild=son;
    } 
  }
  //设置失衡结点的父亲
  node->parent=son;
  //更新son结点的高度信息
  update_depth(son);
  return son;
}
```

#### A的左孩子的右子树插入节点(LR)

- 若 A 的左孩子节点 B 的右子树 E 插入节点 F ，导致节点 A 失衡

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-image-20210324181119234.png" alt="image-20210324181119234" style="zoom:50%;" />

- A 的平衡因子为 2 ，若仍按照右旋调整，则变化后的图形如下

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-image-20210324181037018.png" alt="image-20210324181037018" style="zoom:50%;" />

- 经过右旋调整发现，调整后树仍然失衡，说明这种情况单纯的进行右旋操作不能使树重新平衡。那么这种插入方式需要执行两步操作，使得旋转之后为 **原来根结点的左孩子的右孩子作为新的根节点** 。
  - 对失衡节点 A 的左孩子 B 进行左旋操作，即上述 RR 情形操作
  - 对失衡节点 A 做右旋操作，即上述 LL 情形操作。
- 调整过程如下

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-image-20210324181137082.png" alt="image-20210324181137082" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-image-20210324181149918.png" alt="image-20210324181149918" style="zoom:50%;" />

- 也就是说，经过这两步操作，使得 **原来根节点的左孩子的右孩子 E 节点成为了新的根节点**。
- 代码实现

```cpp
//LR型，先左旋转，再右旋转
//返回：新父节点
Tree LR_rotate(Tree node){
  RR_rotate(node->lchild);
  return LL_rotate(node);
}
```

#### A的右孩子的左子树插入节点(RL)

- 右孩子插入左节点的过程与左孩子插入右节点过程类似，也是需要执行两步操作，使得旋转之后为 **原来根结点的右孩子的左孩子作为新的根节点** 。
  - 对失衡节点 A 的右孩子 C 进行右旋操作，即上述 LL 情形操作
  - 对失衡节点 A 做左旋操作，即上述 RR 情形操作。

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-image-20210324181436877.png" alt="image-20210324181436877" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-04-28-image-20210324181332677.png" alt="image-20210324181332677" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-image-20210324181500470.png" alt="image-20210324181500470" style="zoom:50%;" />

- 也就是说，经过这两步操作，使得 **原来根节点的右孩子的左孩子 D 节点成为了新的根节点**。
- 代码实现

```cpp
//RL型，先右旋转，再左旋转
//返回:新父节点
Tree RL_rotate(Tree node){
  LL_rotate(node->rchild);
  return RR_rotate(node);
}
```

**补充**：上述四种插入方式的代码实现的辅助代码如下：

```cpp
//更新当前深度
void update_depth(Tree node){
  if (node==NULL){
    return;
  }else{
    int depth_Lchild=get_balance(node->lchild); //左孩子深度
    int depth_Rchild=get_balance(node->rchild); //右孩子深度
    node->depth=max(depth_Lchild,depth_Rchild)+1;
  }
}

//获取当前结点的深度
int get_balance(Tree node){
  if (node==NULL){
    return 0;
  }
  return node->depth;
}

//返回当前平衡因子
int is_balance(Tree node){
  if (node==NULL){
    return 0;
  }else{
    return get_balance(node->lchild)-get_balance(node->rchild); 
  }
}
```

### AVL树的四种删除节点方式

- AVL 树和二叉查找树的删除操作情况一致，都分为四种情况：
  - 删除叶子节点
  - 删除的节点只有左子树
  - 删除的节点只有右子树
  - 删除的节点既有左子树又有右子树
- 只不过 AVL 树在删除节点后需要重新检查平衡性并修正，同时，删除操作与插入操作后的平衡修正区别在于，插入操作后只需要对插入栈中的弹出的第一个非平衡节点进行修正，而删除操作需要修正栈中的所有非平衡节点。
- 删除操作的大致步骤如下：
  - 通过前三种情况为基础尝试删除节点，并将访问节点入栈。
  - 如果尝试删除成功，则依次检查栈顶节点的平衡状态，遇到非平衡节点，即进行旋转平衡，直到栈空。
  - 如果尝试删除失败，证明是第四种情况。这时先找到被删除节点的右子树最小节点并删除它，将访问节点继续入栈。
  - 再依次检查栈顶节点的平衡状态和修正直到栈空。
- 对于删除操作造成的非平衡状态的修正，可以这样理解：对左或者右子树的删除操作相当于对右或者左子树的插入操作，然后再对应上插入的四种情况选择相应的旋转

## 红黑树

- 红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：
  - 性质1：每个节点要么是黑色，要么是红色。
  - 性质2：根节点是黑色。
  - 性质3：每个叶子节点（NIL）是黑色。
  - 性质4：每个红色结点的两个子结点一定都是黑色。
  - 性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。
- 从性质5又可以推出：
  - 性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点
- 下图就是一颗简单的红黑树。其中Nil为叶子结点,并且它是黑色的。(值得提醒注意的是，在Java中，叶子结点是为null的结点。)

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-526.png)

- 红黑树并不是一个完美平衡二叉查找树，从上图可以看到，根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为**黑色完美平衡**

**约定红黑树一些结点的叫法**

![图2 结点叫法约定](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-772.png)

- 把正在处理(遍历)的结点叫做当前结点，如上图中的D，它的父亲叫做父结点，它的父亲的另外一个子结点叫做兄弟结点，父亲的父亲叫做祖父结点。

**红黑树总是通过旋转和变色达到自平衡**

- 红黑树能自平衡，通过三种操作：左旋、右旋和变色。
  - **左旋**：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。
  - **右旋**：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。
  - **变色**：结点的颜色由红变黑或由黑变红。

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-1200.png)

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-1200-20210324211433272.png)

- 上面所说的旋转结点也即旋转的支点，如上图P结点。
- 我们先忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。
  - **左旋**只影响旋转结点和其**右子树**的结构，把右子树的结点往左子树挪了。
  - **右旋**只影响旋转结点和其**左子树**的结构，把左子树的结点往右子树挪了。
- 所以旋转操作是**局部**的。另外可以看出旋转能保持红黑树平衡的一些端详了：当一边子树的结点少了，那么向另外一边子树“借”一些结点；当一边子树的结点多了，那么向另外一边子树“租”一些结点。

#### 红黑树查找

- 因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：
  1. 从根结点开始查找，把根结点设置为当前结点
  2. 若当前结点为空，返回null
  3. 若当前结点不为空，用当前结点的key跟查找key作比较
  4. 若当前结点key等于查找key，那么该key就是查找目标，返回当前结点
  5. 若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2
  6. 若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2
- 正由于红黑树总保持黑色完美平衡，所以它的查找最坏时间复杂度为O(2lgN)，也即整颗树刚好红黑相隔的时候。能有这么好的查找效率得益于红黑树自平衡的特性

#### 红黑树插入

- 插入操作包括两部分工作：一查找插入的位置,二插入后自平衡
- 查找插入的位置
  1. 从根结点开始查找
  2. 若根结点为空，那么插入结点作为根结点，结束
  3. 若根结点不为空，那么把根结点作为当前结点
  4. 若当前结点为null，返回当前结点的父结点，结束
  5. 若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束
  6. 若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4
  7. 若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4
- 插入位置已经找到，插入节点应该为红色，因为红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡
- 所有插入情景下图所示

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-1033.png)

- 另外，根据二叉树的性质，**除了情景2，所有插入操作都是在叶子结点进行的**。这点应该不难理解，因为查找插入位置时，就是在找子结点为空的父结点的。

**约定红黑树一些结点的叫法**

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-662.png)

- 上图的字母并不代表结点Key的大小。I表示插入结点，P表示插入结点的父结点，S表示插入结点的叔叔结点，PP表示插入结点的祖父结点。

##### 插入情景1：红黑树为空树

- 最简单的一种情景，直接把插入结点作为根结点就行，但注意，根据红黑树性质2：根节点是黑色。还需要把插入结点设为黑色。
- **处理方法**：把插入结点作为根结点，并把结点设置为黑色。

##### 插入情景2：插入结点的Key已存在

- 插入结点的Key已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，那么把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。
- **处理方法**
  - 把I设为当前结点的颜色
  - 更新当前结点的值为插入结点的值

##### 插入情景3：插入结点的父结点为黑结点

- 由于插入的结点是红色的，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。
- **处理方法**：直接插入。

##### 插入情景4：插入结点的父结点为红结点

- 由于红黑树的性质2：根结点是黑色。**如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点**。这点很重要，因为后续的旋转操作肯定需要祖父结点的参与。
- 情景4又分为以下子情景

###### 插入情景4.1：叔叔结点存在并且为红结点

- 从红黑树性质4可以得出，祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。如下图所示
- **处理方法**
  - 将P和S设置为黑色
  - 将PP设置为红色
  - 把PP设置为当前插入结点

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-656.png)

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-666.png)

- 可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；但如果PP的父结点是红色，根据性质4，此时红黑树已不平衡了，所以还需要把PP当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。
- 试想下PP刚好为根结点时，那么根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。**这也是唯一一种会增加红黑树黑色结点层数的插入情景**。
- 我们还可以总结出另外一个经验：**红黑树的生长是自底向上的**。这点不同于普通的二叉查找树，普通的二叉查找树的生长是自顶向下的。

###### 插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点

- 单纯从插入前来看，也即不算情景4.1自底向上处理时的情况，叔叔结点非红即为叶子结点(Nil)。因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质5。所以需要旋转操作
- 前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了。

**插入情景4.2.1：插入结点是其父结点的左子结点**

- **处理方法**
  - 将P设为黑色
  - 将PP设为红色
  - 对PP进行右旋

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-670.png)

- 由上图可得，左边两个红结点，右边不存在，那么一边一个刚刚好，并且因为为红色，肯定不会破坏树的平衡。

**插入情景4.2.2：插入结点是其父结点的右子结点**

- 这种情景显然可以转换为情景4.2.1，如下图所示
- **处理方法**
  - 对P进行左旋
  - 把P设置为插入结点，得到情景4.2.1
  - 进行情景4.2.1的处理

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-1024.png)

###### 插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点

- 该情景对应情景4.2，只是方向反转

**插入情景4.3.1：插入结点是其父结点的右子结点**

- **处理方法**
  - 将P设为黑色
  - 将PP设为红色
  - 对PP进行左旋

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-622.png)

**插入情景4.3.2：插入结点是其父结点的左子结点**

- **处理方法**
  - 对P进行右旋
  - 把P设置为插入结点，得到情景4.3.1
  - 进行情景4.3.1的处理

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-24-1016.png)

#### 红黑树删除

- 红黑树的删除操作包括两部分工作：一查找目标结点,二删除后自平衡。
- 查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作
- 当存在目标结点时，删除后就得做自平衡处理了。删除了结点后我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代
- 二叉树删除结点找替代结点有3种情景：
  - 情景1：若删除结点无子结点，直接删除
  - 情景2：若删除结点只有一个子结点，用子结点替换删除结点
  - 情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点
- **把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点**。如下图所示

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-806.png)

- **删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点**,在不看键值对的情况下，下图的红黑树最终结果是删除了Q所在位置的结点

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-1200-20210325182836579.png)

- 基于此，上面所说的3种二叉树的删除情景可以相互转换并且最终都是转换为情景1
  - 情景2：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为情景3，一直自顶向下转换，总是能转换为情景1。（对于红黑树来说，根据性质5.1，只存在一个子结点的结点肯定在树末了）
  - 情景3：删除结点用后继结点（肯定不存在左结点），如果后继结点有右子结点，那么相当于转换为情景2，否则转为为情景1。
- 二叉树删除结点情景关系图如下图所示

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-515.png)

- 综上所述，**删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。**
- 同样的，我们也是先来总体看下删除操作的所有情景，如下图所示

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-1035.png)

**约定红黑树一些结点的叫法**

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-1004.png)

- 上图的字母并不代表结点Key的大小。R表示替代结点，P表示替代结点的父结点，S表示替代结点的兄弟结点，SL表示兄弟结点的左子结点，SR表示兄弟结点的右子结点。灰色结点表示它可以是红色也可以是黑色。
- **注意**:R是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成

##### 删除情景1：替换结点是红色结点

- 把替换结点换到了删除结点的位置时，由于替换结点时红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色设为删除的结点的颜色即可重新平衡。
- **处理方法**：颜色变为删除结点的颜色

##### 删除情景2：替换结点是黑结点

- 当替换结点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换结点是其父结点的左子结点还是右子结点，来做不同的旋转操作，使树重新平衡。

###### **删除情景2.1：替换结点是其父结点的左子结点**



**删除情景2.1.1：替换结点的兄弟结点是红结点**

- 若兄弟结点是红结点，那么根据性质4，兄弟结点的父结点和子结点肯定为黑色，不会有其他子情景，我们按图下处理，得到删除情景2.1.2.3（后续讲解，这里先记住，此时R仍然是替代结点，它的新的兄弟结点SL和兄弟结点的子结点都是黑色）。
- **处理：**
  - 将S设为黑色
  - 将P设为红色
  - 对P进行左旋，得到情景2.1.2.3
  - 进行情景2.1.2.3的处理

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-1200-20210325185829223.png)

**删除情景2.1.2：替换结点的兄弟结点是黑结点**

- 当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定（如果也不考虑自底向上的情况，子结点非红即为叶子结点Nil，Nil结点为黑结点），此时又得考虑多种子情景。

**删除情景2.1.2.1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色**

- 即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1了，然而右子树存在红色结点，那么可以直接向右子树“借”个红结点来补充黑结点，此时肯定需要用旋转处理了。如下图所示。
- **处理方法**
  - 将S的颜色设为P的颜色
  - 将P设为黑色
  - 将SR设为黑色
  - 对P进行左旋

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-1200-20210325185848421.png)

- 平衡后的图怎么不满足红黑树的性质？前文提醒过，R是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以R最终可以看作是删除的。
- 另外上图是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL肯定是红色或为Nil，所以最终结果树是平衡的。如果是自底向上处理的情况，同样，每棵子树都保持平衡状态，最终整棵树肯定是平衡的。后续的情景同理，不做过多说明了。

**删除情景2.1.2.2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点**

- 兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景2.1.2.1。如下图所示
- **处理方法**
  - 将S设为红色
  - 将SL设为黑色
  - 对S进行右旋，得到情景2.1.2.1
  - 进行情景2.1.2.1的处理

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-1200-20210325220348500.png)

**删除情景2.1.2.3：替换结点的兄弟结点的子结点都为黑结点**

- 好了，此次兄弟子树都没红结点“借”了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。但为什么需要把兄弟结点设为红色呢？显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的。
- **处理方法**
  - 将S设为红色
  - 把P作为新的替换结点
  - 重新进行删除结点情景处理

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-778.png)

###### **删除情景2.2：替换结点是其父结点的右子结点**

- 右边的操作只是方向相反

**删除情景2.2.1：替换结点的兄弟结点是红结点**

- **处理方法**
  - 将S设为黑色
  - 将P设为红色
  - 对P进行右旋，得到情景2.2.2.3
  - 进行情景2.2.2.3的处理

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-1200-20210325220417566.png)

**删除情景2.2.2：替换结点的兄弟结点是黑结点**

**删除情景2.2.2.1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色**

- **处理方法**
  - 将S的颜色设为P的颜色
  - 将P设为黑色
  - 将SL设为黑色
  - 对P进行右旋

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-1200-20210325224636290.png)

**删除情景2.2.2.2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点**

- **处理方法**
  - 将S设为红色
  - 将SR设为黑色
  - 对S进行左旋，得到情景2.2.2.1
  - 进行情景2.2.2.1的处理

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-1200-20210325224715522.png)

**删除情景2.2.2.3：替换结点的兄弟结点的子结点都为黑结点**

- **处理方法**
  - 将S设为红色
  - 把P作为新的替换结点
  - 重新进行删除结点情景处理

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-748.png)

**习题**

- **请画出下图的插入自平衡处理过程**

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-1200-20210325230912027.png)

- **请画出下图的删除自平衡处理过程**

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-03-25-1200-20210325230921871.png)





975人点赞



[程序园](https://www.jianshu.com/nb/5651126)