---
title: MySQL 锁
categories:
- Software
- BackEnd
- Database
- MySQL
---
# MySQL 锁

## 两段锁

- 数据库遵循的是两段锁协议,将事务分成两个阶段,加锁阶段和解锁阶段(所以叫两段锁)
- **加锁阶段**:在该阶段可以进行加锁操作,在对任何数据进行读操作之前要申请并获得S锁(共享锁,其它事务可以继续加共享锁,但不能加排它锁),在进行写操作之前要申请并获得X锁(排它锁,其它事务不能再获得任何锁),加锁不成功,则事务进入等待状态,直到加锁成功才继续执行
- **解锁阶段**:当事务释放了一个封锁以后,事务进入解锁阶段,在该阶段只能进行解锁操作不能再进行加锁操作

| 事务                 | 加锁/解锁处理                                      |
| :------------------- | :------------------------------------------------- |
| begin;|                                                    |
| insert into test ... | 加insert对应的锁                                   |
| update test set ...     | 加update对应的锁                                   |
| delete from test…| 加delete对应的锁                                   |
| commit;              | 事务提交时,同时释放insert,update,delete对应的锁 |

- 这种方式虽然无法避免死锁,但是两段锁协议可以保证事务的并发调度是串行化(串行化很重要,尤其是在数据恢复和备份的时候)的

## 锁的分类

- 按照锁的使用方式可分为:共享锁,排它锁,意向共享锁,意向排他锁
    - **共享锁/读锁(S)**:允许一个事务去读一行,阻止其他事务获得相同数据集的排他锁,(其他事务可以读但不能写该数据集)
    - **排他锁/写锁(X)**:允许获得排他锁的事务更新数据,阻止其他事务取得相同数据集的共享读锁和排他写锁,(其他事务不能读和写该数据集)
    - **意向共享锁(IS)**:通知数据库接下来需要施加什么锁并对表加锁,如果需要对记录A加共享锁,那么此时innodb会先找到这张表,对该表加意向共享锁之后,再对记录A添加共享锁
    - **意向排他锁(IX)**:通知数据库接下来需要施加什么锁并对表加锁,如果需要对记录A加排他锁,那么此时innodb会先找到这张表,对该表加意向排他锁之后,再对记录A添加排他锁
- 按照锁的粒度可分为:行锁,页锁(间隙锁),表锁
    - **表级锁**:开锁小,加锁快,不会出现死锁,锁的粒度大,发生锁冲突的概率最高,并发量最低
    - **行级锁**:开销大,加锁慢,会出现死锁,锁的粒度小,容易发生冲突的概率小,并发度最高
        - 行锁直接加在索引记录上面,无索引项时演变成表锁(因为如果一个条件无法通过索引快速过滤,存储引擎层面就会将所有记录加锁后返回,再由MySQL Server层进行过滤)
    - **间隙锁**(Gap Lock):锁定索引记录间隙,确保索引记录的间隙不变,在无索引的情况下是锁全表,间隙锁是针对事务隔离级别为可重复读或以上级别的
    - **Next-Key Lock**:行锁和间隙锁组合起来就是 Next-Key Lock
- 意向共享锁和意向排它锁是数据库主动加的,不需要我们手动处理
- 对于UPDATE,DELETE和INSERT语句,InnoDB会自动给涉及数据集加排他锁(X)
- 对于普通SELECT语句,InnoDB不会加任何锁,事务可以通过以下语句显示给记录集加共享锁或排他锁
    - 共享锁(S):`SELECT * FROM table_name WHERE…LOCK IN SHARE MODE`
    - 排他锁(X):`SELECT * FROM table_name WHERE…FOR UPDATE`