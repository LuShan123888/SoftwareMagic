---
title: SQL 索引
categories:
- Software
- Backend
- Database
- 关系数据库标准语言SQL
- DML
---
# SQL 索引

## EXPLAIN

- EXPLAIN可以帮助开发人员分析SQL问题，EXPLAIN显示了mysql如何使用索引来处理查询语句以及连接表，可以帮助选择更好的索引和写出更优化的查询语句。

```sql
 EXPLAIN SELECT * FROM student WHERE studentno='1000';
```

- MySQL在执行一条查询之前，会对发出的每条SQL进行分析，决定是否使用索引或全表扫描
- 如果发送一条`select * from blog where false`，MySQL是不会执行查询操作的，因为经过SQL分析器的分析后MySQL已经清楚不会有任何语句符合操作

**实例**

```sql
mysql> EXPLAIN SELECT `birday` FROM `user` WHERE `birthday` < "1990/2/2"; 
id: 1 

select_type: SIMPLE -- 查询类型（简单查询、联合查询、子查询） 

table: user -- 显示这一行的数据是关于哪张表的 。

type: range -- 区间索引（在小于1990/2/2区间的数据)，这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL,const代表一次就命中，ALL代表扫描了全表才确定结果。一般来说，得保证查询至少达到range级别,最好能达到ref。 

possible_keys: birthday  -- 指出MySQL能使用哪个索引在该表中找到行。如果是空的，没有相关的索引。这时要提高性能，可通过检验WHERE子句，看是否引用某些字段，或者检查字段不是适合索引。  

key: birthday -- 实际使用到的索引。如果为NULL，则没有使用索引。如果为primary的话，表示使用了主键。 

key_len: 4 -- 最长的索引宽度。如果键是NULL，长度就是NULL。在不损失精确性的情况下，长度越短越好。

ref: const -- 显示哪个字段或常数与key一起被使用。  

rows: 1 -- 这个数表示mysql要遍历多少数据才能找到，在innodb上是不准确的。 

Extra: Using where; Using index -- 执行状态说明，这里可以看到的坏的例子是Using temporary和Using
```

-  **id**
    - id相同时，执行顺序由上至下
    - 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
    - id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行
- select_type:显示查询中每个select子句的类型
    - SIMPLE(简单SELECT,不使用UNION或子查询等)
    - PRIMARY(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)
    - UNION(UNION中的第二个或后面的SELECT语句)
    - DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)
    - UNION RESULT(UNION的结果)
    - SUBQUERY(子查询中的第一个SELECT)
    - DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)
    - DERIVED(派生表的SELECT, FROM子句的子查询)
    - UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)
- table:显示这一行的数据是关于哪张表的，有时不是真实的表名字,看到的是derivedx(x是第x步执行的结果)
- type:表示MySQL在表中找到所需行的方式，又称“访问类型”。常用的类型有： ALL, index, range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）
    - ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行
    - index: Full Index Scan，index与ALL区别为index类型只遍历索引树
    - range:只检索给定范围的行，使用一个索引来选择行
    - ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
    - eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件
    - const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system
    - NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。
- possible_keys:指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用
    - 该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。
    - 如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询
- Key:key列显示MySQL实际决定使用的键（索引）
    - 如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。
- key_len:表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的)
    - 不损失精确性的情况下，长度越短越好 
- ref:表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
- rows:表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数
- Extra:该列包含MySQL解决查询的详细信息,有以下几种情况:
    - Using where:列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤
    - Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询
    - Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”
    - Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。
    - Impossible where：这个值强调了where语句会导致没有符合条件的行。
    - Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行

## 索引准则

- 小数据量的表建议不要加索引
- 索引一般应加在查找条件的字段
- 不要盲目的创建索引，只为查询操作频繁的列创建索引，创建索引会使查询操作变得更加快速，但是会降低增加、删除、更新操作的速度，因为执行这些操作的同时会对索引文件进行重新排序或更新
- 在大数据导入时，可以先删除索引，再批量插入数据，最后再添加索引

## 索引的数据结构

- 索引类型
    - hash类型的索引:查询单条快,范围查询慢
    - btree类型的索引:b+树,层数越多,数据量指数级增长(innodb默认支持)
- 不同的存储引擎支持的索引类型也不一样
    - InnoDB 支持事务,支持行级别锁定,支持 B-tree,Full-text 等索引,不支持 Hash 索引
    - MyISAM 不支持事务,支持表级别锁定,支持 B-tree,Full-text 等索引,不支持 Hash 索引
    - Memory 不支持事务,支持表级别锁定,支持 B-tree,Hash 等索引,不支持 Full-text 索引
    - NDB 支持事务,支持行级别锁定,支持 Hash 索引,不支持 B-tree,Full-text 等索引
    - Archive 不支持事务,支持表级别锁定,不支持 B-tree,Hash,Full-text 等索引

## 索引的作用

- 提高查询速度
- 确保数据的唯一性
- 可以加速表和表之间的连接 , 实现表与表之间的参照完整性
- 使用分组和排序子句进行数据检索时 , 可以显著减少分组和排序的时间
- 全文检索字段进行搜索优化

## 索引的分类

- 主键索引 (Primary Key)
- 唯一索引 (Unique)
- 常规索引 (Index)
- 全文索引 (FullText)

### 主键索引

- **主键** : 某一个属性组能唯一标识一条记录,不可以出现相同的值，但可以有NULL值
- **特点** 
    - 最常见的索引类型
    - 确保数据记录的唯一性
    - 确定特定数据记录在数据库中的位置

### 唯一索引

- **作用** : 避免同一个表中某数据列中的值重复
- **特点**
    - 不允许出现相同的值，且不能为NULL值，一个表只能有一个`primary_key`索引

### 常规索引

- **作用** : 快速定位特定数据
- **注意**
    - 允许出现相同的索引内容
    - `INDEX`和`KEY`关键字都可以设置常规索引
    - 应加在查询找条件的字段
    - 不宜添加太多常规索引,影响数据的插入,删除和修改操作

### 全文索引

- **作用** : 快速定位特定数据
- **注意** :
    - 适合大型数据集
    - MySQL 5.6 以前的版本,只有 MyISAM 存储引擎支持全文索引
    - MySQL 5.6 及以后的版本,MyISAM 和 InnoDB 存储引擎均支持全文索引
    - 只有字段的数据类型为 char,varchar,text 及其系列才可以建全文索引

**使用全文索引**

- 全文搜索通过 `MATCH()` 函数完成
- 搜索字符串作为`AGAINST()`的参数被给定,搜索以忽略字母大小写的方式执行,对于表中的每个记录行,`MATCH()` 返回一个相关性值,即,在搜索字符串与记录行在 `MATCH()` 列表中指定的列的文本之间的相似性尺度

```mysql
EXPLAIN SELECT *FROM student WHERE MATCH(studentname) AGAINST('love');
```

## 创建索引

**CREATE TABLE**

- 创建表时添加索引

```mysql
CREATE TABLE 表名 (
    字段名1 数据类型 [完整性约束条件...],
    字段名2 数据类型 [完整性约束条件...],
    [PRIMARY | UNIQUE | FULLTEXT ]  KEY
    [索引名] (字段名[(长度)] [ASC |DESC])
);
```

```sql
CREATE TABLE `test1` ( 
    `id` smallint(5) UNSIGNED AUTO_INCREMENT NOT NULL, -- 注意，下面创建了主键索引，这里就不用创建了 
    `username` varchar(64) NOT NULL COMMENT '用户名', 
    `nickname` varchar(50) NOT NULL COMMENT '昵称/姓名', 
    `intro` text, 
    PRIMARY KEY (`id`),  
    UNIQUE KEY `unique1` (`username`),
    KEY `index1` (`nickname`), 
    FULLTEXT KEY `intro` (`intro`) 
) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='后台用户表';
```

**CREATE INDEX**

- 在已存在的表上创建索引

```mysql
 CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名
                    ON 表名 (字段名[(长度)] [ASC |DESC]) ;
```

```sql
CREATE INDEX index_name ON table_name (column_list) 
CREATE UNIQUE INDEX index_name ON table_name (column_list)
```

**ALTER TABLE**

- 在已存在的表上创建索引

```mysql
ALTER TABLE 表名 ADD 索引类型 (UNIQUE,PRIMARY KEY,FULLTEXT KEY,INDEX) 索引名 (字段名[(长度)] [ASC |DESC]) ;
```

```sql
ALTER TABLE `table_name` ADD INDEX `index_name` (`column_list`) 
ALTER TABLE `table_name` ADD UNIQUE (`column_list`) 
ALTER TABLE `table_name` ADD PRIMARY KEY (`column_list`) 
ALTER TABLE `table_name` ADD FULLTEXT KEY (`column_list`)
```

**注意**:

- 索引名可省略，即当前的索引名就是该字段名
- `<表名>`是要建索引的基本表的名字,索引可以建立在该表的一列或多列上,各`<列名>`之间用逗号分隔,每个`<列名>`后面还可以用`<次序>`指定索引值的排列次序,可选ASC(升序)或DESC(降序),默认值为ASC
- `UNIQUE`表明此索引的每一个索引值只对应唯一的数据记录
- `CLUSTER`表示要建立的索引是聚簇索引

## 删除索引

**删除索引**

```mysql
DROP INDEX 索引名 ON 表名;
```

**删除主键索引**

- 主键索引只能用这种方式删除

```mysql
ALTER TABLE 表名 DROP PRIMARY KEY;
```

## 查看索引

```mysql
SHOW INDEX FROM 表名;
```

## 修改索引

**修改索引名**

```sql
ALTER INDEX <旧索引名> RENAME TO<新索引名>;
```

```sql
ALTER INDEX SCno RENAME TO SCSno;
```

## 组合索引与前缀索引

-  这两种称呼是对建立索引技巧的一种称呼，并非索引的类型

### 组合索引

- MySQL单列索引和组合索引究竟有何区别呢？
- 为了形象地对比两者，先建一个表：

```sql
CREATE TABLE `myIndex` ( 
    `i_testID` INT NOT NULL AUTO_INCREMENT,  
    `vc_Name` VARCHAR(50) NOT NULL,  
    `vc_City` VARCHAR(50) NOT NULL,  
    `i_Age` INT NOT NULL,  
    `i_SchoolID` INT NOT NULL,  
    PRIMARY KEY (`i_testID`)  
);
```

- 假设表内已有1000条数据，在这 10000 条记录里分布了 5 条 `vc_Name=”erquan”`的记录，只不过`city,age,school`的组合各不相同。来看这条语句：

```sql
SELECT `i_testID` FROM `myIndex` WHERE `vc_Name`='erquan' AND `vc_City`='郑州' AND `i_Age`=25; -- 关联搜索;
```

- 首先考虑建MySQL单列索引：
- 在`vc_Name`列上建立了索引。执行SQL时，MYSQL 很快将目标锁定在了 `vc_Name=erquan`的 5 条记录上，取出来放到一中间结果集。在这个结果集里，先排除掉`vc_City`不等于”郑州”的记录，再排除`i_Age`不等于 25 的记录，最后筛选出唯一的符合条件的记录。虽然在`vc_Name`上建立了索引，查询时MYSQL不用扫描整张表，效率有所提高，但离我们的要求还有一定的距离。同样的,在`vc_City`和`i_Age`分别建立的MySQL单列索引的效率相似
- 为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。就是将 `vc_Name`,`vc_City`,`i_Age`建到一个索引里：

```sql
ALTER TABLE `myIndex` ADD INDEX `name_city_age` (vc_Name(10),vc_City,i_Age);
```

- 建表时，`vc_Name`长度为 50，这里为什么用 10 呢？这就是下文要说到的前缀索引，因为一般情况下名字的长度不会超过 10，这样会加速索引查询速度，还会减少索引文件的大小，提高 INSERT 的更新速度。
- 执行SQL时，MySQL 无须扫描任何记录就到找到唯一的记录
- 如果分别在`vc_Name`,`vc_City`,`i_Age`上建立单列索引，让该表有 3 个单列索引，查询时和上述的组合索引效率一样吗？答案是大不一样，远远低于我们的组合索引。虽然此时有了三个索引，但 MySQL 只能用到其中的那个它认为似乎是最有效率的单列索引，另外两个是用不到的，也就是说还是一个全表扫描的过程
- 建立这样的组合索引，其实是相当于分别建立了：
    - vc_Name,vc_City,i_Age
    - vc_Name,vc_City
    - vc_Name
- 这样的三个组合索引,为什么没有`vc_City`,`i_Age`等这样的组合索引呢？这是因为 MySQL 组合索引 “最左前缀” 的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个 SQL 会用到：

```sql
SELECT * FROM myIndex WHREE vc_Name=”erquan” AND vc_City=”郑州” SELECT * FROM myIndex WHREE vc_Name=”erquan”
```

- 而下面几个则不会用到：

```sql
SELECT * FROM myIndex WHREE i_Age=20 AND vc_City=”郑州”
SELECT * FROM myIndex WHREE vc_City=”郑州”
```

- 也就是，`name_city_age(vc_Name(10),vc_City,i_Age)` 从左到右进行索引，如果没有左前索引MySQL不执行索引查询。

### 前缀索引

- 如果索引列长度过长，这种列索引时将会产生很大的索引文件，不便于操作
- 可以使用前缀索引方式进行索引前缀索引应该控制在一个合适的点，控制在0.31黄金值即可（大于这个值就可以创建）

```sql
SELECT COUNT(DISTINCT(LEFT(`title`,10)))/COUNT(*) FROM Arctic; 
```

- 这个值大于0.31就可以创建前缀索引
- Distinct去重复 

```sql
ALTER TABLE `user` ADD INDEX `uname`(title(10)); 
```

- 增加前缀索引SQL，将人名的索引建立在10，这样可以减少索引文件大小，加快索引查询速度

## 使用索引的注意事项

**要尽量避免这些不走索引的sql**

```sql
SELECT `sname` FROM `stu` WHERE `age`+10=30; -- 不会使用索引，因为所有索引列参与了计算 

SELECT `sname` FROM `stu` WHERE LEFT(`date`,4) <1990; -- 不会使用索引，因为使用了函数运算，原理与上面相同 

SELECT * FROM `houdunwang` WHERE `uname` LIKE'后盾%' ; -- 走索引 

SELECT * FROM `houdunwang` WHERE `uname` LIKE "%后盾%";  -- 不走索引 

-- 正则表达式不使用索引，这应该很好理解，所以为什么在SQL中很难看到regexp关键字的原因 

-- 字符串与数字比较不使用索引; 
CREATE TABLE `a` (`a` char(10)); 
EXPLAIN SELECT * FROM `a` WHERE `a`="1"; -- 走索引 
EXPLAIN SELECT * FROM `a` WHERE `a`=1; -- 不走索引 

SELECT * FROM dept  WHERE dname='xxx' OR loc='xx' OR deptno=45; -- 如果条件中有OR，即使其中有条件带索引也不会使用。换言之，就是要求使用的所有字段，都必须建立索引，我们建议大家尽量避免使用OR关键字 

-- 如果mysql估计使用全表扫描要比使用索引快，则不使用索引
```

**多表关联时的索引效率**

- 假设数据库中有 3 个表A,B,C,每个表都有一列分别为a,b,c,每列中有 6 行,为数字 1,2,3,4,5,6

```sql
SELECT A.a,B.b,C.c FROM A JOIN B JOIN C ON A.a=B.b AND B.b=C.c;
```

- 在没有添加索引时会执行 `6*6*6=216`次查询,如果数据量很大,例如每个表都有 2000 条记录,结果会是 80 亿次查询,这个结果是很糟糕的
- 所以建议在多表join的时候尽量少join几张表，因为一不小心就是一个笛卡尔乘积的恐怖扫描
- 另外建议尽量使用left join，以少关联多。因为使用join 的话，第一张表是必须的全扫描的，以少关联多就可以减少这个扫描次数