---
title: SpringBoot 日志
categories:
- Software
- Backend
- Java
- SpringFramework
- SpringBoot
- 整合
---
# SpringBoot 日志

## Logback

- Spring Boot默认使用的日志框架

### 配置

#### 控制台输出

- 日志级别从低到高分为TRACE < DEBUG < INFO < WARN < ERROR < FATAL,如果设置为WARN,则低于WARN的信息都不会输出
- Spring Boot中默认配置`ERROR`,`WARN`和`INFO`级别的日志输出到控制台,您还可以通过启动您的应用程序–debug标志来启用"调试”模式(开发的时候推荐开启),以下两种方式皆可:
    - 在运行命令后加入`--debug`标志,如:`$ java -jar springTest.jar --debug`
    - 在`application.properties`中配置`debug=true`,该属性置为true的时候,核心Logger(包含嵌入式容器,hibernate,spring)会输出更多内容,但是你自己应用的日志并不会输出为DEBUG级别

#### 文件输出

默认情况下,Spring Boot将日志输出到控制台,不会写到日志文件,如果要编写除控制台输出之外的日志文件,则需在`application.properties`中设置logging.file或logging.path属性

- logging.file,设置文件,可以是绝对路径,也可以是相对路径,如:`logging.file=my.log`
- logging.path,设置目录,会在该目录下创建spring.log文件,并写入日志内容,如:`logging.path=/var/log`

**注意**

- 如果只配置 logging.path,在 /var/log文件夹生成一个日志文件为 spring.log
- 如果只配置 logging.file,会在项目的当前路径下生成一个 xxx.log 日志文件
- 二者不能同时使用,如若同时使用,则只有logging.file生效
- 默认情况下,日志文件的大小达到10MB时会切分一次,产生新的日志文件,默认级别为:ERROR,WARN,INFO

#### 级别控制

- 所有支持的日志记录系统都可以在Spring环境中设置记录级别
- 格式:`logging.level.* = LEVEL`
    - `logging.level`:日志级别控制前缀,`*`为包名或Logger名
    - `LEVEL`:选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF

**实例**

- `logging.level.com.example=DEBUG`:`com.example`包下所有class以DEBUG级别输出
- `logging.level.root=WARN`:root日志以WARN级别输出

#### 日志配置

除了上面介绍的配置属性外,还有其他一些属性,例如:

- `logging.config`:日志配置
- `logging.file.max-size`:最大日志文件大小
- `logging.file.max-history`:最大归档文件数量
- `logging.pattern.console`:控制台输出的日志模式
- `logging.pattern.dateformat`:日志的日期格式
- `logging.pattern.file`:默认使用日志模式
- `logging.pattern.level`:日志级别

#### 配置文件

##### xml

- Spring Boot 中的 logback 默认使用 `src/main/resources` 文件夹下的 `logback.xml` 或 `logback-spring.xml` 作为日志配置,Spring Boot 官方推荐优先使用带有 `-spring` 的文件名作为日志配置文件,因为如果命名为 `logback-spring.xml` 日志配置,就可以在日志输出的时候引入一些 Spring Boot 特有的配置项,也可以通过自定义的方式指定配置文件:`logging.config=classpath:logback-confg.xml`
- `application.properities` 配置:

```properties
# 日志配置信息
## 这个路径其实不指定也可以,因为 logback-spring.xml 是默认配置文件名之一
logging.config=classpath:logback-spring.xml
## 这里的配置是为了在 xml 配置中应用的
log.level=info
```

- 一个简单的控制台输出配置:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <!-- application.properities中配置的变量 -->
  <springProperty scope="context" name="logLevel" source="log.level"/>
  <springProperty scope="context" name="logPath" source="log.path"/>
  <springProperty scope="context" name="logName" source="log.name"/>

  <appender name="Console" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logger{80} - %msg%n</pattern>
      <charset>UTF-8</charset>
    </encoder>
  </appender>
  <root level="${logLevel}}">
    <appender-ref ref="Console"/>
  </root>
</configuration>
```

- `appender` 的 `name` 其实只是取的名字,你也可以叫它 `STDOUT`
- `%d` 表示时间,用 `%d{yyyy-MM-dd HH:mm:ss.SSS}` 定义了格式化时间,也可以使用 `%date`
- `%-5level` 表示显示日志级别,并且用 5 个字符靠左对齐,也可以用 `%p` 表示日志级别
- `%thread` 表示显示日志进程名字
- `%logger{80}` 表示日志输出者的名字,常常是类名
- `%msg` 日志消息
- `%n` 平台的换行符
- `%c` 用来在日志上输出类的全名
- `%L` 表示行号
- `charset` 设置日志编码格式为 UTF-8,避免中文乱码
- `root` 标签内设置日志级别 `level`,等同于在配置文件中设置 `logging.pattern.level`

- Logback 配置文件可以使用 property 标签自定义属性,然后在配置文件中使用,下面附上一个较复杂的配置:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <!-- application.properities中配置的变量 -->
  <springProperty scope="context" name="logProfile" source="log.profile"/>
  <springProperty scope="context" name="logFileLevel" source="log.file.level"/>
  <!-- 定义日志 pattern -->
  <property name="logPattern"
            value="%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logger{36} - %c - %L{4} - %msg%n"/>
  <!-- 定义日志文件名称 -->
  <property name="appName" value="logback-demo"></property>
  <property name="logPath" value="log"></property>


  <!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 -->
  <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
    <!--
        日志输出格式:
            %d表示日期时间
            %thread表示线程名
            %-5level:级别从左显示5个字符宽度
            %logger{50} 表示logger名字最长50个字符,否则按照句点分割
            %L 表示行号
            %msg:日志消息
            %n是换行符
        -->
    <encoder>
      <!--<pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>-->
      <pattern>${logPattern}</pattern>
      <charset>UTF-8</charset>
    </encoder>
  </appender>

  <!-- 滚动记录文件,先将日志记录到指定文件,当符合某个条件时,将日志记录到其他文件 -->
  <appender name="appLogFileAppender" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <encoder>
      <pattern>${logPattern}</pattern>
      <charset>UTF-8</charset>
    </encoder>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
      <!--
            滚动时产生的文件的存放位置及文件名称 %d{yyyy-MM-dd}:按天进行日志滚动
            %i:当文件大小超过maxFileSize时,按照i进行文件滚动
            -->
      <fileNamePattern>${logPath}/${appName}/%d{yyyy-MM-dd}-%i.log</fileNamePattern>
      <!--
            可选节点,控制保留的归档文件的最大数量,超出数量就删除旧文件,假设设置每天滚动
            且maxHistory是365,则只保存最近365天的文件,删除之前的旧文件,注意,删除旧文件是
            那些为了归档而创建的目录也会被删除
            -->
      <MaxHistory>365</MaxHistory>
      <!--
            当日志文件超过maxFileSize指定的大小是,根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的,必须配置timeBasedFileNamingAndTriggeringPolicy
            -->
      <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
        <maxFileSize>50MB</maxFileSize>
      </timeBasedFileNamingAndTriggeringPolicy>
    </rollingPolicy>
    <!--下面通过两个 Filter,记录了 WARN 和 Error 级别的日志,其实用 logger 来定义level,更方便-->
    <!--<filter class="ch.qos.logback.classic.filter.LevelFilter">-->
    <!--<level>warn</level>-->
    <!--<onMatch>ACCEPT</onMatch>-->
    <!--<onMismatch>NEUTRAL</onMismatch>-->
    <!--</filter>-->
    <!--<filter class="ch.qos.logback.classic.filter.LevelFilter">-->
    <!--<level>error</level>-->
    <!--<onMatch>ACCEPT</onMatch>-->
    <!--<onMismatch>DENY</onMismatch>-->
    <!--</filter>-->
  </appender>


  <!--<root level="error">-->
  <!--<appender-ref ref="console"/>-->
  <!--</root>-->
  <!--<logger name="com.michael.springbootlogback" >-->
  <!--<appender-ref ref="appLogFileAppender"/>-->
  <!--</logger>-->
  <springProfile name="${logProfile}">
    <!--<logger name="org.springframework" level="info" additivity="false"></logger>-->
    <logger name="com.michael" level="info">
      <appender-ref ref="console"/>
    </logger>
    <logger name="com.michael" level="${logFileLevel}">
      <appender-ref ref="appLogFileAppender"/>
    </logger>
  </springProfile>
</configuration>
```

- 输出到 console:
    - `ConsoleAppender` 需要设置这样的一个 apppender,否则日志不会打印到控制台
- 输出到文件:
    - `RollingFileAppender` 可以实现日志的切分
    - `rollingPolicy` 设置滚动切分的规则
    - `totalSizeCap` 用来指定日志文件的上限大小,这个设置在 `maxFileSize` 之后起效,也就是说,如果你文件上限设置的是 1MB,但是 `maxFileSize` 设置的是 10MB,那么,这个日志文件也会保存为 10MB,假设你 `maxFileSize` 设置的是 1MB,`totalSizeCap` 设置的是 2MB,那么你日志文件的个数最多也就 2 个
    - `MaxHistory` 可选节点,控制保留的归档文件的最大数量,超出数量就删除旧文件,假设设置每天滚动,且maxHistory是365,则只保存最近365天的文件,我还是喜欢这个设置,比 `totalSizeCap` 意义更清晰
- `<root>` 可以包含零个或多个 `<appender-ref>` 元素,标识这个 appender 将会添加到这个 loger,logger 的属性:
    - name: 用来指定受此 loger 约束的某一个包或者具体的某一个类,没写的时候会报错
    - level:日志打印级别,如果未设置此属性,那么当前 logger 会继承上级的级别,也就是 root 的级别
    - addtivity:是否向上级 loger 传递打印信息,默认是 true,设置为 false 表示该日志打印设置(控制台打印还是文件打印等具体设置)不会向根 root 标签传递,也就是说该 logger 里怎么设置的那就会怎么打印,跟 root 无关
- root 是根 logger,所以他两是一回事,只不过 root 中不能有 name 和 additivity 属性,是有一个 level
- appender 是一个日志打印的组件,这里组件里面定义了打印过滤的条件,打印输出方式,滚动策略,编码方式,打印格式等等,但是它仅仅是一个打印组件,如果我们不使用一个 logger 或者 root 的 appender-ref 指定某个具体的 appender 时,它就没有什么意义

##### properties

`application.properties`

```properties
logging.level.root=INFO
logging.level.org.springframework.web=DEBUG
#logging.path=/home/user/log
logging.file=/home/user/log/spring.log
```

### 使用日志

```java
@GetMapping("/all")
public String all() {
  try {
    log.debug("logger: debug");
    log.info("logger: info");
    log.warn("logger: warn");
    System.out.println(1 / 0);
  } catch (Exception e) {
    log.error("log:error", e);
    throw e;
  }
  return "all";
}
```

## Log4j

### pom.xml

过滤掉自带的`spring-boot-starter-logging`,然后添加`spring-boot-starter-log4j`依赖包 

```xml
<!-- log4j -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter</artifactId>
  <exclusions>
    <exclusion>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-logging</artifactId>
    </exclusion>
  </exclusions>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-log4j</artifactId>
  <version>1.3.8.RELEASE</version>
</dependency>
```

### 配置

#### 配置根Logger

```properties
log4j.rootLogger = [ level ] , appenderName, appenderName,…
```

- `level`:是日志记录的优先级,分为OFF,FATAL,ERROR,WARN,INFO,DEBUG,ALL或者您定义的级别
    - Log4j建议只使用四个级别,优先级从高到低分别是ERROR,WARN,INFO,DEBUG
    - 通过在这里定义的级别,您可以控制到应用程序中相应级别的日志信息的开关,比如在这里定义了INFO级别,则所有高于INFO级别的日志信息将不被打印出来
- `appenderName`:指把日志信息输出到哪个地方,您可以同时指定多个输出目的地

#### 配置Appender

- 文件的输出目的地

```properties
log4j.appender.appenderName = fully.qualified.name.of.appender.class
log4j.appender.appenderName.option1 = value1
…
log4j.appender.appenderName.option = valueN
```

- `appenderName`:Log4j提供的appender有以下几种:
    - org.apache.log4j.ConsoleAppender(控制台)
    - org.apache.log4j.FileAppender(文件)
    - org.apache.log4j.DailyRollingFileAppender(每天产生一个日志文件)
    - org.apache.log4j.RollingFileAppender(文件大小到达指定尺寸的时候产生一个新的文件)
    - org.apache.log4j.WriterAppender(将日志信息以流格式发送到任意指定的地方)

#### 配置日志信息的格式

```properties
log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class
log4j.appender.appenderName.layout.option1 = value1
…
log4j.appender.appenderName.layout.option = valueN
```

- `layout`
    - org.apache.log4j.HTMLLayout(以HTML表格形式布局)
    - org.apache.log4j.PatternLayout(可以灵活地指定布局模式)
    - ConversionPattern
        - %m 输出代码中指定的消息
        - %p 输出优先级,即DEBUG,INFO,WARN,ERROR,FATAL
        - %r 输出自应用启动到输出该log信息耗费的毫秒数
        - %c 输出所属的类目,通常就是所在类的全名
        - %t 输出产生该日志事件的线程名
        - %n 输出一个回车换行符,Windows平台为`rn`,Unix平台为`n`
        - %d 输出日志时间点的日期或时间,默认格式为ISO8601,也可以在其后指定格式,比如:%d{yyy MMM dd HH:mm:ss,SSS},输出类似:2002年10月18日 22:10:28,921
        - %l 输出日志事件的发生位置,包括类目名,发生的线程,以及在代码中的行数,举例:Testlog4.main(TestLog4.java:10)
    - org.apache.log4j.SimpleLayout(包含日志信息的级别和信息字符串)
    - org.apache.log4j.TTCCLayout(包含日志产生的时间,线程,类别等等信息)

### 配置文件

`application.properties`

```properties
#将等级为DEBUG的日志信息输出到console和file这两个目的地, console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file

#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=[%c]-%m%n

#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/example.log
log4j.appender.file.MaxFileSize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n

#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG
```

### 使用日志

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Log4JTest {
  private static final Logger logger = LoggerFactory.getLogger(Log4JTest.class);

  public static void main(String[] args) {
    Logger.debug ( Object message ) ;
    Logger.info ( Object message );
    Logger.warn ( Object message );
    Logger.error ( Object message );
  }
}
```

