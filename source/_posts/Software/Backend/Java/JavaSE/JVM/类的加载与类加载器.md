---
title: Java 类的加载与类加载器
categories:
- Software
- Backend
- Java
- JavaSE
- JVM
---
# Java 类的加载与类加载器

## Java 内存分析

- **堆**
    - 存放new的对象和数组
    - 可以被所有的线程共享,不会存放别的对象引用
    - **方法区**(堆中特殊的区域)
        - 可以被所有的线程共享
        - 包含了所有的class和static变量
- **栈**
    - 存放基本变量类型(会包含这个基本类型的基本数值)
    - 引用对象的变量(会存放这个引用在堆里面的具体地址)

## 类的加载过程

- 当程序主动使用某个类时,如果该类还未被加载到内存中,则系统会通过如下三个步骤来对该类进行初始化
    - **类的加载(Load)**
        - 将类的class文件字节码内容加载到内存中,并将这些静态数据转换成方法区的运行时数据结构,然后在堆中生成一个代表这个类的`java.lang.Class`对象,作为方法区中类数据的访问入口此过程由类加载器完成
    - **类的链接(Link)**:将Java类的二进制数据合并到JVM的运行状态之中的过程
        - 验证:确保加载的类信息符合JVM规范,没有安全方面的问题
        - 准备:正式为类变量(static)分配内存并设置类变量默认初始值的阶段,这些内存都将在方法区中进行分配
        - 解析:虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程
    - **类的初始化(Initialize)**
        - 执行类构造器`<clinit>()`方法的过程,类构造器`<clinit>()`方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句按照先后顺序合并产生的(类构造器是构造类信息的,不是构造该类对象的构造器)
        - 当初始化一个类的时候,如果发现其父类还没有进行初始化,则需要先触发其父类的初始化
        - 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确加锁和同步

> **什么时候会发生类初始化?**
>
> - **类的主动引用**(一定会发生类的初始化)
>     - 当虚拟机启动,先初始化main方法所在的类
>     - new一个类的对象
>     - 调用类的静态成员(除final常量)和静态方法
>     - 使用`java.lang.reflect`包的方法对类进行反射调用
>     - 当初始化一个类,如果其父类没有被初始化,则会先初始化它的父类
> - **类的被动引用**(不会发生类的初始化)
>     - 当访问一个静态域时,只有真正声明这个域的类才会被初始化,如:当通过子类引用父类的静态变量,不会导致子类初始化
>     - 通过数组定义类引用,不会触发此类的初始化
>     - 引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中)

## 类加载器的作用

- **类加载的作用**:将类的class文件字节码内容加载到内存中,并将这些静态数据转换成方法区的运行时数据结构,然后在堆中生成一个代表这个类的`java.lang.Class`对象,作为方法区中类数据的访问入口
- **类缓存**:标准的JavaSE类加载器可以按要求查找类,但一旦某个类被加载到类加载器中,它将维持加载(缓存)一段时间,不过JVM垃圾回收机制可以回收这些Class对象
- **类加载器的作用**:用来把类(Class)装载进内存的,JVM规范定义了如下类型的类加载器
    - **引导类加载器**:用C++编写,是JVM自带的类加载器,负责Java平台核心库,用来装载核心类库,该加载器无法直接获取
    - **扩展类加载器**:负责`jre/lib/ext`目录下的jar包或`-D java.ext.dirs`指定目录下的jar包装入工作库
    - **系统类加载器**;负责`java -classpath`或`-D java.class.path`所指的目录下的类与jar包装入工作,是最常用的加载器

```java
class Test {
    public static void main(String[] args) {
        //获取系统类的加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);

        //获取系统类加载器的父类加载器-->扩展类加载器
        ClassLoader extendClassLoader= systemClassLoader.getParent();
        System.out.println(extendClassLoader);

        //获取扩展类加载器的父类加载器-->引导加载器
        ClassLoader bootClassLoader = extendClassLoader.getParent();
        System.out.println(bootClassLoader);

        //测试当前类是哪个加载器加载的
        ClassLoader classLoader = Test.class.getClassLoader();
        System.out.println(classLoader);

        //测试JDK内置的类是哪个加载器加载的
        ClassLoader classLoader1 = String.class.getClassLoader();
        System.out.println(classLoader1);

        //获得系统类加载器可以加载的路径,即classpath
        System.out.println(System.getProperty("java.class.path"));
    }

}
```

- 结果如下

```bash
sun.misc.Launcher$AppClassLoader@18b4aac2
sun.misc.Launcher$ExtClassLoader@deb6432
null
sun.misc.Launcher$AppClassLoader@18b4aac2
null
/usr/local/Cellar/openjdk@8/1.8.0+282/libexec/openjdk.jdk/Contents/Home/jre/lib/charsets.jar:
/usr/local/Cellar/openjdk@8/1.8.0+282/libexec/openjdk.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:
/usr/local/Cellar/openjdk@8/1.8.0+282/libexec/openjdk.jdk/Contents/Home/jre/lib/ext/dnsns.jar:
/usr/local/Cellar/openjdk@8/1.8.0+282/libexec/openjdk.jdk/Contents/Home/jre/lib/ext/jaccess.jar:
...
```

