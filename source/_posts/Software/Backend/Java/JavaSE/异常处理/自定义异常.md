---
title: Java 自定义异常
categories:
- Software
- Backend
- Java
- JavaSE
- 异常处理
---
# Java 自定义异常

在某些应用中,编程人员也可以根据程序的特殊逻辑在用户程序里自己创建自定义的异常类和异常对象,主要用来处理用户程序中特定的逻辑运行错误

## 自定义异常类设计

创建用户自定义异常一般是通过继承Exception类来实现的,在自定义异常类中一般包括异常标识,构造方法和`toString()`方法

**[例9-3]**一个简单的自定义异常类

```java
public class MyException extends Exception{
    String id;//异常标识

    public MyException(String str){
        id = str;
    }

    public String toString(){
        return ("异常:"+id);
    }
}
```

**说明**

构造方法的作用是给异常标识赋值,`toString()`方法在需要输出异常的描述时使用,在已定义异常类的基础上也可以通过继承编写新类型类

## 抛出异常

前面看到的异常例子均是系统定义的异常,所有系统定义的运行异常都可以由系统在允许程序过程中自动抛出,而用户设计的异常,则要在程序中通过throw语句抛出,异常本质上是对象,因此throw关键词后面跟的是new运算符来创建一个异常对象

```java
public class TestException{
    public static void main(String[] args) {
        try {
            throw new MyException("一个测试异常");
        } catch (MyException e) {
            System.out.println(e);
        }
    }
}
```

**说明**

在try语句块中通过throw语句抛出创建的异常对象,在catch块中将捕获的异常输出

## 方法的异常声明

如果某一个方法中有异常抛出,有两种选择 : 一是在方法内对异常进行捕获处理,二是在方法中不处理异常,将异常处理交给外部调用程序,通常在方法头使用throws子句列出该方法可能产生哪些异常,例如以下main将获取一个输入字符并显示

```java
try{
    char c = (char)System.in.read();
    System.out.println("你输入的字符是: "+c);
}catch (java.io.IOException e) {    }
```

对于IO异常,如果在该方法中省去异常处理,则编译时将检测到未处理IO异常而提示错误,但如果在main方法头加上throws子句则是允许的,例如:

```java
public static void main(String[] args) throws java.io.IOException {
    char c = (char)System.in.read();
    System.out.println("你输入的字符是: "+c);
}
```

初学者要注意,throw语句和throws子句的差异性,一个是抛出异常,另一个是声明方法将产生某个异常,在一个实际方法中它们的位置如下:

```java
修饰符 返回类型 方法名(参数列表) throws 异常类名列表{
    ...
        throws
        ...
}
```

**[例9-4]**设计一个方法计算一元二次方程的根,并测试方法

```java
class Find_root {
    static double[] root(double a, double b, double c)
        throws IllegalArgumentException {
        double x[] = new double[2];
        if (a == 0) {
            throw new IllegalArgumentException("a 不能为零");
        } else {
            double disc = b * b - 4 * a * c;
            if (disc < 0)
                throw new IllegalArgumentException("b*b-4ac<=0");
            x[0] = (-b + Math.sqrt(disc)) / (2 * a);
            x[1] = (-b - Math.sqrt(disc)) / (2 * a);
            return x;
        }
    }

    public static void main(String[] args) {
        try {
            double x[] = root(2.0, 5, 3);
            System.out.println("方程根为:" + x[0] + "," + x[1]);
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}

方程根为:-1.0,-1.5
```

**说明**

本例抛出异常利用了系统的一个异常类,IllegalArgumentException,方法声明了异常并不代表该方法肯定产生异常,也就是说,异常的发生是有条件的,不妨修改程序,将root调用的第一个参数改为0,在编译运行程序,则结果为:

```java
java.lang.IllegalArgumentException:a不能为零
```

**注意**

在编写类继承代码时,子类在覆盖父类带throws子句的方法时,子类的方法声明的throws子句抛出的异常不能超出父类方法的异常范围,换句话说,子类方法抛出的异常可以是父类方法中抛出异常的子类,子类方法也可以不抛出异常,如果父类方法没有异常声明,则子类的覆盖方法也不能出现异常声明