---
title: Java 接口
categories:
- Software
- Backend
- Java
- JavaSE
- 抽象类和接口
---
# Java 接口

Java中不支持多重继承,而是通过接口实现比多重继承更强的功能,Java通过接口使处于不同层次,甚至互不关联的类可以具有相同的行为

## 接口定义

- 接口由常量和抽象方法组成,由关键字interface引导接口定义,具体语法如下:

```java
[public]interface 接口名 [extends 父接口名列表]{
    [public][static][final] 域类型 域名 = 常量值;
    [public][abstract] 返回值 方法名(参数列表)[throw 异常列表];
}
```

- 有关接口定义要注意以下几点:
    - 声明接口可给出访问控制符,用public修饰的是公共接口
    - 接口具有继承性,一个接口还可以继承多个父接口,父接口间用逗号分隔
    - 接口中所有属性的修饰默认是`public static final`,也就是均为静态常量
    - 接口中所有方法的修饰默认是`public abstract`
- 例如,所有的`shape`都有一个`draw()`和`area()`成员方法,可以创建一个接口:

```java
interface Shape{
    void draw();//用于绘制形状
    double area();//用于求面积
}
```

- 接口是抽象类的一种,不能用于创建对象,接口的作用在于规定一些功能框架,集体功能的实现则由遵守该接口约束的类去完成

## 接口的实现

- 接口定义了一套行为规范,一个类实现这个接口就要遵循接口中定义的规范,也就是要实现接口中定义的所有方法,换句话说,在类中要用具体方法覆盖掉接口中定义的抽象方法
- 有关接口的实现,要注意以下问题:
    - 一个类可以实现多个接口,在类的声明部分用implements关键字声明该类将要实现哪些接口,接口间用逗号分隔
    - 接口的抽象方法的访问限制符默认为public,在实现时要在方法头中显式地加上public修饰,这点很容易忽视
    - 如果实现某接口的类没有将接口的所有抽象方法具体实现,则编译时将提示该类只能为抽象类,而抽象类是不能创建对象的
- 接口的多重实现机制在很大程度上弥补了Java类单冲继承的局限性,不仅一个类可以实现多个接口,而且多个无关的类可以实现同一接口

**[例8-2]**接口应用举例

```java
interface Copyable{//定义Copyable接口
    Object copy();
}

class Book implements Copyable{//Book类实现Copyable接口
    String book_name;                   //书名
    String book_id;                         //书号

    public Book(String name,String id){
        book_name = name;
        book_id = id;
    }

    public String toString(){
        return "书名:"+book_name+",书号="+book_id;
    }

    public Object copy(){   //覆盖接口中定义的抽象方法
        return new Book(book_name,book_id);
    }

    public static void main(String[] args) {
        Book x = new Book("Java程序设计","ISBN8359012");
        System.out.println(x);
        System.out.println(x.copy());
        Book y = (Book)x.copy();    //赋值要用强制转换
        System.out.println(y);
    }
}

书名:Java程序设计,书号=ISBN8359012
    书名:Java程序设计,书号=ISBN8359012
        书名:Java程序设计,书号=ISBN8359012
```

- 本例定义了一个Copyable接口,其中包含`copy()`方法,在Book类中实现该方法,它将生成一个书名和书号相同的Book对象作为返回对象,程序中Book类的`copy()`方法类型为Object,所以第26行将返回结果赋给Book引用变量要进行强制转换,实际上,Book类的`copy()`方法也可将返回类型定义为Book类型,同样不违背接口定义,因为Book是Object的子类,那样的话,将`copy()`方法结果赋给Book引用变量就不需要强制转换
- 由于一个类可以继承某个父类同时实现多个接口,因此,也会带来多重继承上的二义性问题,例如,以下代码中Test类继承了Parent类同时实现了Frob接口,不难注意到,在接口和父类中均有变量v,这时通过Test类的一个对象直接访问v就存在二义性问题,编译将提示错误,因此,程序中通过super.v和Frob.v来具体指定是哪个v,事实上,这两个v不仅数值不同,而且性质不同,接口中的是常量,而类中定义的是属性常量

```java
interdace Frob{//接口Frob定义
    float v = 2.0f;
}

class Parent{//Parent类定义
    int v = 3;
}

class Test extends Parent implements Frob{//继承Parent类并实现Frob接口
    public static void main(String[] args){
        new Test().printV();
    }

    void printV{
        System.out.println((super.v+Frob.v)/2);
    }
}
```

