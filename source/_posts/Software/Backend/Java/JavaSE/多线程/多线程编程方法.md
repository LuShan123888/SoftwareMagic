---
title: Java 多线程编程方法
categories:
- Software
- Backend
- Java
- JavaSE
- 多线程
---
# Java 多线程编程方法

用Java编写多线程代码有两种方式:第1种是直接继承Java的线程类Thread,第二种方法是实现Runnable接口,无论采用哪种方法均需要在程序中编写`run()`方法,线程在运行时要完成的任务在该方法中实现

## Thread类简介

Thread类综合了Java程序中一个线程需要拥有的属性和方法,它的构造方法为:

```java
public Thread(ThreadGroup group,Runnable target,String name);
```

- `group`指明该线程所属的线程
- `target`为实际执行线程体的目标对象,它必须实现接口Runnable
- `name`为线程名

- 以下构造方法为缺少某些参数的情形:

```java
public Thread()
public Thread(Runnable target)
public Thread(runnable target,String name)
public Thread(String name)
public Thread(ThreadGroup group,Runnable target)
public Thread(ThreadGroup group,String name)
```

- 线程组是为了方便访问一组线程引入的,例如,通过执行线程组的`interrupt()`方法,可以中断该组所有线程的执行,但如果当前线程无权修改线程组时将产生异常,实际应用中较少用到线程组
- 下表为Thread类的主要方法简介

| 方法                 | 功能                                            |
| -------------------- | ----------------------------------------------- |
| currentThread()      | 返回当前运行的Thread对象                        |
| start()              | 启动线程                                        |
| run()                | 由调度程序调用,当run()方法返回时,该线程停止     |
| sleep(int n)         | 是线程睡眠n毫秒,n毫秒后,线程可以再次运行        |
| setPriority(int p)   | 设置线程优先级                                  |
| getPriority()        | 返回线程优先级                                  |
| join()               | 其他线程要等待调用该方法的线程结束后,再往下执行 |
| suspend()            | 使线程挂起,JDK已不建议使用的方法                |
| resume()             | 恢复挂起的线程,JDK已不建议使用的方法            |
| yield()              | 将CPU控制权主动移交到下一个可运行的线程         |
| setName(String name) | 赋予线程一个名字                                |
| getName()            | 取得代表线程名字的字符串                        |
| stop()               | 停止线程的执行                                  |

- Thread类封装了线程的行为,继承Thread类须重写`run()`方法实现线程的任务,注意,程序中不要直接调用此方法,而是调用线程对象的`start()`方法启动线程,让其进入可调度状态,线程获得调度时将自动执行`run()`方法

## 继承Thread类实现多线程

**[例12-1]**直接继承Thread类实现多线程

```java
import java.util.*;
class TimePrinter extends Thread {
    int pauseTime;    //中间休息时间
    String name;      //名称标识

    public TimePrinter(int x, String n) {
        pauseTime = x;
        name = n;
    }

    public void run() {
        while (true) {
            try {
                System.out.println(name + ": " + Calendar.getInstance().getTime());
                Thread.sleep(pauseTime);    //让线程睡眠一段时间
            } catch (InterruptedException e) {
            }
        }
    }

    public static void main(String[] args) {
        TimePrinter tp1 = new TimePrinter(1000, "Fast");
        tp1.start();
        TimePrinter tp2 = new TimePrinter(3000, "Slow");
        tp2.start();
    }
}

Fast: Sun Jan 12 11:50:24 CST 2020
Fast: Sun Jan 12 11:50:25 CST 2020
Fast: Sun Jan 12 11:50:26 CST 2020
Slow: Sun Jan 12 11:50:27 CST 2020
Fast: Sun Jan 12 11:50:27 CST 2020
Fast: Sun Jan 12 11:50:28 CST 2020
Fast: Sun Jan 12 11:50:29 CST 2020
Slow: Sun Jan 12 11:50:30 CST 2020
...
```

- 运行程序,可看到两个线程按两个不同的时间间隔显示当前时间,睡眠时间长的线程运行机会自然少
- **注意**:如果包括主线程,实际上有3个线程在运行,主线程从`mian()`方法开始执行,启动完两个新线程后首先停止,其他两个线程的`run()`方法被设计为无限循环,必须靠按Ctrl+C快捷键强行结束

## 实现Runnable接口编写多线程

- 由于Java的单重继承限制,有些类必须继承其他某个类的同时又要实现线程的特性,这时可通过实现Runnable接口的方式来满足两方面的要求,Runnable接口只有一个方法`run()`,它就是线程运行时要执行的方法,只要将具体代码 写入其中即可
- 使用Thread类的构造函数`public Thread(Runnable target)`可以将一个Runnable接口对象传递给线程,线程在调度执行其`run()`方法时将自动调用Runnable接口对象的`run()`方法
- Thread类本身实现了Runnable接口,从其`run()`方法的设计可看出线程调度时会自动执行Runnable接口对象的`run()`方法,以下为Thread类的关键代码:

```java
class Thread implements Runnable{
    private Runnable target;
    public Thread(){...}
    public Thread(Runnable target){...}
    public void run() {
        if (target != null)
            target.run();   //执行实现Runnable接口的target对象的run()方法
    }
    ...
}
```

- 将**例12-1**改用实现Runnable接口的方式实现,利用Thread类的带Runnable接口参数的构造方法创建线程,线程调度运行时,通过执行线程的`run()`方法,将转而调用TimePrinter对象的`run()`方法,不妨让`mian()`方法所在的主线程也循环执行,具体程序代码如下:

```java
class TimePrinter implements Runnable {
    int pauseTime;    //中间休息时间
    String name;      //名称标识

    public TimePrinter(int x, String n) {
        pauseTime = x;
        name = n;
    }

    public void run() {
        while (true) {
            try {
                System.out.println(name + ": " + Calendar.getInstance().getTime());
                Thread.sleep(pauseTime);    //让线程睡眠一段时间
            } catch (InterruptedException e) {
            }
        }
    }

    public static void main(String[] args) {
        Thread tp1 = new Thread(new TimePrinter(1000,"Fast"));
        tp1.start();
        Thread tp2 = new Thread(new TimePrinter(3000,"Slow"));
        tp2.start();
        for (int k=0;k<100;k++){
            System.out.println("主线程循环:  k="+k);
            try {
                Thread.sleep(500);
            }catch (InterruptedException e){
            }
        }
    }
}
```

- 运行程序,会发现有3个线程在轮流执行,其中`main()`方法所在的线程,由于设置的线程睡眠时间更短,因此,得到调度运行的机会更多

**[例12-2]**一个随机选号程序

有一组号码,让其滚动显示,随机选两个位置在一起的作为中奖号码,本应用让窗体实现Runnable接口,通过多线程的运作方式实现号码的滚动显示,在窗体中通过文本域显示滚动号码,通过一个按钮控制选号过程的开始和停止,线程的停止是通过一个标记变量flag来控制的

```java
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
class Winning extends Frame implements Runnable {
    String[] phoneNumber = {"15031204532", "13014156678", "13870953214",
                            "13943123322", "18114156528"};//用数组存一组号码
    TextArea disp = new TextArea(4, 50);    //用来显示滚动号码
    int pos = 0;    //记录滚动到的索引位置
    boolean flag = false;   //控制线程停止的标记变量
    Button onoff;   //启动停止按钮

    public static void main(String[] args) {
        new Winning();
    }

    public Winning() {
        add("Center", disp);
        onoff = new Button("begin");
        add("South", onoff);
        onoff.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                if (e.getActionCommand().equals("begin")) {
                    flag = true;
                    onoff.setLabel("end"); //更改按钮标签
                    (new Thread(Winning.this)).start(); //启动线程
                } else {
                    flag = false;   //设置线程停止标记
                    onoff.setLabel("begin");
                }
            }
        });
        setSize(200, 100);
        setVisible(true);
    }

    public void run() {
        while (flag) {
            int n = phoneNumber.length;
            pos = (int) (Math.random() * n);   //随机选位置
            String message = phoneNumber[pos] + "\n" +
                phoneNumber[(pos + 1) % n];
            disp.setText(message);     //显示位置连续的两个号码
        }
    }
}
```

- **说明**:第4行定义了Winning类头,表明了该类继承Frame并实现了Runnable接口,第25行创建线程时将Winning窗体自身对象作为实参,并启动线程,线程调度运行时将执行其run()方法

## 实现Callable接口编写多线程

> **步骤**
>
> 1. 实现Callable 接口(需要返回值类型)
> 2. 重写call方法(需要抛出异常)
> 3. 创建目标对象
> 4. 创建执行服务
> 5. 提交执行
> 6. 获取结果
> 7. 关闭服务

**特点**

- 可以定义返回值
- 可以抛出异常

**实例**

```java
import java.util.Calendar;
import java.util.concurrent.*;

class TimePrinter implements Callable<Boolean> {
    int pauseTime;    //中间休息时间
    String name;      //名称标识

    public TimePrinter(int x, String n) {
        pauseTime = x;
        name = n;
    }

    public Boolean call() throws InterruptedException {
        for (int i = 0; i < 10; i++) {
            System.out.println(name + ": " + Calendar.getInstance().getTime());
            Thread.sleep(pauseTime);    //让线程睡眠一段时间
        }
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //创建执行服务
        ExecutorService ser = Executors.newFixedThreadPool(3);

        //提交执行
        Future<Boolean> r1 = ser.submit(new TimePrinter(1000, "Fast"));
        Future<Boolean> r2 = ser.submit(new TimePrinter(3000, "Slow"));

        //获取结果
        boolean rs1 = r1.get();
        boolean rs2 = r2.get();

        System.out.println(rs1);
        System.out.println(rs2);

        //关闭服务
        ser.shutdownNow();

    }
}
```

## 停止线程

- 不推荐使用JDK提供的`stop()`和`destroy()`方法(已废弃)
- 推荐线程自己停止下来
- 建议使用一个标志位进行终止线程运行,当`flag=false`,则终止线程运行

```java
public class TestStop implements Runnable {
    //1.线程中定义线程体使用的标识
    pribate
        boolean flag = true;

    @Override
    public void run() {
        //2.线程体使用该标识
        while (flag) {
            System.out.printlb("run... Thread");
        }
    }

    //3.对外提供方法改变标识
    public void stop() {
        this.flag = false;
    }
}
```

## 线程休眠

- sleep(时间)指定当前线程阻塞的毫秒数
- sleep存在异常`InterruptedException`
- sleep时间达到后线程进入就绪状态
- sleep可以模拟网络延时,倒计时等
- 每一个对象都有一个锁,sleep不会释放锁

```java
class TestSleep implements Runnable {
    int pauseTime;    //中间休息时间
    String name;      //名称标识

    public TestSleep(int x, String n) {
        pauseTime = x;
        name = n;
    }

    public void run() {
        while (true) {
            try {
                Thread.sleep(pauseTime);    //让线程睡眠一段时间
                System.out.println(name + " Sleep" + pauseTime + " ms");
            } catch (InterruptedException e) {
            }
        }
    }

    public static void main(String[] args) {
        Thread tp1 = new Thread(new TestSleep(1000, "Thread 1"));
        tp1.start();
        for (int k = 0; k < 100; k++) {
            try {
                Thread.sleep(3000);//主线程睡眠一段时间
            } catch (InterruptedException e) {
            }
            System.out.println("Main Thread Sleep 3000ms");
        }
    }
}
```

## 线程让步

- 将线程从运行状态转为就绪状态,并让CPU重新调度

```java
class TestYield implements Runnable {

    public void run() {
        System.out.println(Thread.currentThread().getName() + "线程开始执行");
        Thread.yield();//线程让步
        System.out.println(Thread.currentThread().getName() + "线程停止执行");
    }

    public static void main(String[] args) {
        TestYield test = new TestYield();
        new Thread(test, "test1").start();
        new Thread(test, "test2").start();
    }
}
```

## 线程插入

- 其他线程要等待调用该方法的线程结束后,再往下执行
- 在该线程执行的时候,原本运行进程进入阻塞状态

```java
class TestJoin implements Runnable {

    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("测试线程: " + i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        //启动测试线程
        TestJoin test = new TestJoin();
        Thread thread = new Thread(test);
        thread.start();

        //主线程
        for (int i = 0; i < 100; i++) {
            if (i == 20) {
                thread.join();//线程插入
            }
            System.out.println("主线程: " + i);
        }
    }
}
```

## 线程状态

- `Thread.State`为线程状态,线程可以处于以下状态之一
    - `NEW`:尚未启动的线程处于此状态
    - `RUNNABLE`:在Java虚拟机中执行的线程处于此状态
    - `BLOCKED`:被阻塞等待监视器锁定的线程处于此状态
    - `WAITING`:正在等待另一个线程执行特定动作的线程处于此状态
    - `TIMED_WAITING`:正在等待另一个线程执行动作达到指定等待时间的线程处于此状态
    - `TERMINATED`:已退出的线程处于此状态
- 一个线程可以在给定时间点处于一个状态,这些状态是不反映任何操作系统线程状态的虚拟机状态

```java
class TestState implements Runnable {

    public void run() {
        for (int i = 0; i < 10; i++) {
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("测试线程: " + i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        TestState test = new TestState();
        Thread thread = new Thread(test);

        //观察线程状态
        Thread.State state = thread.getState();
        System.out.println(state);

        //启动测试线程
        thread.start();

        //只要线程不终止,就一直输出状态
        while (state != Thread.State.TERMINATED) {
            Thread.sleep(500);
            state = thread.getState();
            System.out.println(state);
        }
    }
}
```

## 线程优先级

- 线程的优先级用数字来表示,范围从1~10,主线程的默认优先级为5,其他线程的优先级与创建它的父线程的优先级相同,为了方便,Thread类提供了如下几个常量来表示优先级:
    - `Thread.MIN_PRIORITY=1`
    - `Thread.MAX_PRIORITY=10`
    - ``Thread.NORM_PRIORITY=5`
- `getPriority()`:获取线程优先级
- `setPriority()`:设置线程优先级

```java
class TestPriority implements Runnable {

    public void run() {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "-->" + Thread.currentThread().getPriority());
    }

    public static void main(String[] args) {
        TestPriority test = new TestPriority();
        Thread t1 = new Thread(test);
        Thread t2 = new Thread(test);
        Thread t3 = new Thread(test);
        Thread t4 = new Thread(test);
        Thread t5 = new Thread(test);
        //主线程的优先级
        System.out.println(Thread.currentThread().getName() + "-->" + Thread.currentThread().getPriority());

        //设置优先级
        t2.setPriority(1);
        t3.setPriority(Thread.NORM_PRIORITY);
        t4.setPriority(8);
        t5.setPriority(Thread.MAX_PRIORITY);

        t1.start();
        t2.start();
        t3.start();
        t4.start();
        t5.start();

    }
}
```

- 优先级低只是意味着获得调度的概率低,并不是优先级低就不会被调用

## 守护线程

- 线程分为用户线程和守护线程
- 虚拟机必须确保用户线程执行完毕
- 虚拟机不用等待守护线程执行完毕
- 例如:后台记录操作日志,监控内存,垃圾回收等待

```java
class TestDaemon {

    static class DaemonThread implements Runnable {
        public void run() {
            while (true) {
                System.out.println("守护进程");
            }
        }
    }

    static class UserThread implements Runnable {
        public void run() {
            for (int i = 0; i < 5; i++) {
                System.out.println("用户进程");
            }
        }
    }


    public static void main(String[] args) {
        //创建并启动守护进程
        Thread thread = new Thread(new DaemonThread());
        //默认是false表示是用户进程,设置true改为守护进程
        thread.setDaemon(true);
        thread.start();

        //创建并启动用户进程
        new Thread(new UserThread()).start();
    }
}
```

