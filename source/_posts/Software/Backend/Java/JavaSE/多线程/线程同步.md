---
title: Java 线程同步
categories:
- Software
- Backend
- Java
- JavaSE
- 多线程
---
# Java 线程同步

## 临界资源问题

- 多个线程共享的数据称为临界资源,由于是线程调度程序负责线程的调度,程序员无法精确控制多线程的交替次序,如果没有特殊控制,多线程对临界资源的访问将导致数据的不一致性
- 以堆栈操作为例,涉及出栈和进栈两个操作,程序代码如下:

```java
public class Stack {
  int idx = 0;
  char[] data = new char[10];

  public void push(char c) {
    data[idx] = c;      //存入数据
    idx++;              //改变栈顶指针
  }
}

public  char pop() {
  idx--;
  return data[idx];
}
```

- 可以想象,线程在执行方法的过程中均可能因为调度问题而中断执行,如果一个线程在执行`push()`方法时将数据存入了堆栈,但未给栈顶指针增值,这时中断执行,另一个线程则执行出栈操作,首先将栈指针减1,这样读到的数据显然不是栈顶数据,为避免此情况,可以采用`synchronized`给调用方法的对象加锁

## 同步方法与同步块(synchronized)

- `synchronized`保证一个方法处理的对象资源不会因其他方法的执行而改变,`synchronized`关键字的使用方法有如下两种:
    - **同步方法**
        - 用`synchronized`修饰的方法就是同步方法，它表示整个方法都必须用`this`实例加锁
        - 对`static`方法添加`synchronized`，锁住的是该类的`Class`实例
        - 同步方法控制对象的访问,每个对象对应一把锁,每个同步方法都必须拥有的调用该方法的对象的锁才能执行,否则线程会阻塞,方法一旦执行,就独占锁,直到该方法返回才释放锁,后面被阻塞的线程才能获得这个锁,继续执行
    - **同步块**
        - `sysnchronized(Obj){}`用在对象前面限制一段代码的执行,表示执行该段代码必需取得对象锁
- Obj称之为同步监视器
    - Obj可以是任何对象,但是推荐使用共享资源作为同步监视器,Obj是可重入,非公平的锁
    - 同步方法中无需指定同步监视器,因为同步方法的同步监视器就是this,就是这个对象本身,或者是class
- **同步监视器的执行过程**
    1. 第一个线程访问,锁定同步监视器,执行其中代码
    2. 第二个线程访问,发现同步监视器被锁定,无法访问
    3. 第一个线程访问完毕,解锁同步监视器
    4. 第二个线程访问,发现同步监视器没有锁,然后锁定并访问

```java
public class Stack {
  int idx = 0;
  char[] data = new char[10];

  public void push(char c) {
    synchronized (this) {    //执行以下一段代码锁定对象
      data[idx] = c;      //存入数据
      idx++;              //改变栈顶指针
    }
  }

  public synchronized char pop() { //执行该方法时锁定对象
    idx--;
    return data[idx];
  }
}
```

- 被加锁的对象要在`synchronized`中限制代码执行完毕才会释放对象锁,在此之前,其他线程访问正被加锁的对象时将处于资源等待状态,对象的同步代码的执行过程如下图所示:

![Component-Page-2](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-2020-11-07-Component-Page-2-4724194.svg)

- 使用`synchronized`可能带来的问题
    - 一个线程持有锁会导致其他所有需要此临界资源的线程挂起
    - 在多线程竞争下,加锁,释放锁会导致比较多的上下文切换和调度延时,引起性能问题
    - 如果一个优先级高的线程等待一个优先级低的线程释放锁,会导致优先级倒置,引起性能问题

## 死锁

- 一个线程可以获取一个锁后，再继续获取另一个锁。例如：

```java
public void add(int m) {
  synchronized(lockA) { // 获得lockA的锁
    this.value += m;
    synchronized(lockB) { // 获得lockB的锁
      this.another += m;
    } // 释放lockB的锁
  } // 释放lockA的锁
}

public void dec(int m) {
  synchronized(lockB) { // 获得lockB的锁
    this.another -= m;
    synchronized(lockA) { // 获得lockA的锁
      this.value -= m;
    } // 释放lockA的锁
  } // 释放lockB的锁
}
```

- 在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。对于上述代码，线程1和线程2如果分别执行`add()`和`dec()`方法时：
  - 线程1：进入`add()`，获得`lockA`
  - 线程2：进入`dec()`，获得`lockB`
- 随后：
  - 线程1：准备获得`lockB`，失败，等待中
  - 线程2：准备获得`lockA`，失败，等待中
- 此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。
- 死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。
- 因此，在编写多线程应用时，要特别注意防止死锁。因为死锁一旦形成，就只能强制结束进程。
- 那么我们应该如何避免死锁呢？答案是：线程获取锁的顺序要一致。即严格按照先获取`lockA`，再获取`lockB`的顺序，改写`dec()`方法如下：

```java
public void dec(int m) {
  synchronized(lockA) { // 获得lockA的锁
    this.value -= m;
    synchronized(lockB) { // 获得lockB的锁
      this.another -= m;
    } // 释放lockB的锁
  } // 释放lockA的锁
}
```

- **产生死锁的四个必要条件**
    - **互斥条件**:一个资源每次只能被一个进程使用
    - **请求与保持条件**:一个进程因请求资源而阻塞时,对已获得的资源保持不放
    - **不剥夺条件**:进程已获得的资源,在末使用完之前,不能强行剥夺
    - **循环等待条件**:若干进程之间形成一种头尾相接的循环等待资源关系
- `suspend()`和`resume()`方法天生容易发生死锁,调用`suspend()`时,目标线程会停下来,但却仍然持有在这之前获得的锁定,此时,其他任何线程都不能访问锁定的资源,除非被"挂起”的线程恢复运行,对任何线程来说,如果它们想恢复目标线程,同时又试图使用任何一个锁定的资源,就会造成令人难堪的死锁,因此从JDK1.2开始就建议不再使用`suspend()`和`resume()`,更强调`wait()`与`notify()`方法,可以在自己的线程类中置入一个标志变量,指出线程应该活动还是挂起,若标识指出线程应该挂起,便用`wait()`命其进入等待状态,若状态指出线程应当恢复,则用一个`notify()`重新启动线程

## Lock

- 从JDK5.0开始,Java提供了更强大的线程同步机制--通过显式定义同步锁对象来实现同步,同步锁使用Lock对象充当
- `java.util.concurrent.locks.Lock`接口是控制多个线程对共享资源进行访问的工具,锁提供了对共享资源的独占访问,每次只能有一个线程对Lock对象加锁,线程开 始访问共享资源之前应先获得Lock对象

> **synchronized与Lock的对比**
>
> - Lock 能完成synchronized所实现的所有功能,Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁
> - Lock可以知道是不是已经获取到锁，而synchronized无法知道
> - Lock是显式锁(手动开启和关闭锁),synchronized是隐式锁,出了作用域自动释放
> - Lock只有代码块锁,synchronized有代码块和方法锁
> - Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现,synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生,而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁
> - Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。

### ReentrantLock

- `ReentrantLock`可以替代`synchronized`进行同步
- `ReentrantLock`获取锁更安全
- 必须先获取到锁，再进入`try {...}`代码块，最后使用`finally`保证释放锁
- 可以使用`tryLock()`尝试获取锁。

```java
public class Counter {
  private int count;

  public void add(int n) {
    synchronized(this) {
      count += n;
    }
  }
}
```

- 如果用`ReentrantLock`替代，可以把代码改造为：

```java
public class Counter {
  private final Lock lock = new ReentrantLock();
  private int count;

  public void add(int n) {
    lock.lock();
    try {
      count += n;
    } finally {
      lock.unlock();
    }
  }
}
```

- 因为`synchronized`是Java语言层面提供的语法，所以我们不需要考虑异常，而`ReentrantLock`是Java代码实现的锁，我们就必须先获取锁，然后在`finally`中正确释放锁。
- 顾名思义，`ReentrantLock`是可重入锁，它和`synchronized`一样，一个线程可以多次获取同一个锁。
- 和`synchronized`不同的是，`ReentrantLock`可以尝试获取锁：

```java
if (lock.tryLock(1, TimeUnit.SECONDS)) {
  try {
    ...
  } finally {
    lock.unlock();
  }
}
```

- 上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，`tryLock()`返回`false`，程序就可以做一些额外处理，而不是无限等待下去。
- 所以，使用`ReentrantLock`比直接使用`synchronized`更安全，线程在`tryLock()`失败的时候不会导致死锁。

## 不需要同步的操作

- JVM规范定义了几种原子操作：
  - 基本类型（`long`和`double`除外）赋值，例如：`int n = m`
  - 引用类型赋值，例如：`List<String> list = anotherList`
- `long`和`double`是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把`long`和`double`的赋值作为原子操作实现的。
- 单条原子操作的语句不需要同步。例如：

```java
public void set(int m) {
  synchronized(lock) {
    this.value = m;
  }
}
```

- 就不需要同步。
- 对引用也是类似。例如：

```java
public void set(String s) {
    this.value = s;
}
```

- 上述赋值语句并不需要同步。
- 但是，如果是多行赋值语句，就必须保证是同步操作，例如：

```java
class Pair {
  int first;
  int last;
  public void set(int first, int last) {
    synchronized(this) {
      this.first = first;
      this.last = last;
    }
  }
}
```

- 有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：

```java
class Pair {
  int[] pair;
  public void set(int first, int last) {
    int[] ps = new int[] { first, last };
    this.pair = ps;
  }
}
```

- 就不再需要同步，因为`this.pair = ps`是引用赋值的原子操作。而语句：

```java
int[] ps = new int[] { first, last };
```

- 这里的`ps`是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。