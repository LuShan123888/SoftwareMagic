---
title: Java 线程同步
categories:
- Software
- Backend
- Java
- JavaSE
- 多线程
---
# Java 线程同步

## 临界资源问题

- 多个线程共享的数据称为临界资源,由于是线程调度程序负责线程的调度,程序员无法精确控制多线程的交替次序,如果没有特殊控制,多线程对临界资源的访问将导致数据的不一致性
- 以堆栈操作为例,涉及出栈和进栈两个操作,程序代码如下:

```java
public class Stack {
    int idx = 0;
    char[] data = new char[10];

    public void push(char c) {
        data[idx] = c;      //存入数据
        idx++;              //改变栈顶指针
    }
}

public  char pop() {
    idx--;
    return data[idx];
}
```

- 可以想象,线程在执行方法的过程中均可能因为调度问题而中断执行,如果一个线程在执行`push()`方法时将数据存入了堆栈,但未给栈顶指针增值,这时中断执行,另一个线程则执行出栈操作,首先将栈指针减1,这样读到的数据显然不是栈顶数据,为避免此情况,可以采用`synchronized`给调用方法的对象加锁

## 同步方法与同步块(synchronized)

- `synchronized`保证一个方法处理的对象资源不会因其他方法的执行而改变,`synchronized`关键字的使用方法有如下两种:
    - **同步方法**
        - 用`synchronized`修饰的方法就是同步方法，它表示整个方法都必须用`this`实例加锁
        - 对`static`方法添加`synchronized`，锁住的是该类的`Class`实例
        - 同步方法控制对象的访问,每个对象对应一把锁,每个同步方法都必须拥有的调用该方法的对象的锁才能执行,否则线程会阻塞,方法一旦执行,就独占锁,直到该方法返回才释放锁,后面被阻塞的线程才能获得这个锁,继续执行
    - **同步块**
        - `sysnchronized(Obj){}`用在对象前面限制一段代码的执行,表示执行该段代码必需取得对象锁
- Obj称之为同步监视器
    - Obj可以是任何对象,但是推荐使用共享资源作为同步监视器
    - 同步方法中无需指定同步监视器,因为同步方法的同步监视器就是this,就是这个对象本身,或者是class
- **同步监视器的执行过程**
    1. 第一个线程访问,锁定同步监视器,执行其中代码
    2. 第二个线程访问,发现同步监视器被锁定,无法访问
    3. 第一个线程访问完毕,解锁同步监视器
    4. 第二个线程访问,发现同步监视器没有锁,然后锁定并访问

```java
public class Stack {
  int idx = 0;
  char[] data = new char[10];

  public void push(char c) {
    synchronized (this) {    //执行以下一段代码锁定对象
      data[idx] = c;      //存入数据
      idx++;              //改变栈顶指针
    }
  }

  public synchronized char pop() { //执行该方法时锁定对象
    idx--;
    return data[idx];
  }
}
```

- 被加锁的对象要在`synchronized`中限制代码执行完毕才会释放对象锁,在此之前,其他线程访问正被加锁的对象时将处于资源等待状态,对象的同步代码的执行过程如下图所示:

![Component-Page-2](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-2020-11-07-Component-Page-2-4724194.svg)

- 使用`synchronized`可能带来的问题
    - 一个线程持有锁会导致其他所有需要此临界资源的线程挂起
    - 在多线程竞争下,加锁,释放锁会导致比较多的上下文切换和调度延时,引起性能问题
    - 如果一个优先级高的线程等待一个优先级低的线程释放锁,会导致优先级倒置,引起性能问题

## 死锁

- 一个线程可以获取一个锁后，再继续获取另一个锁。例如：

```java
public void add(int m) {
  synchronized(lockA) { // 获得lockA的锁
    this.value += m;
    synchronized(lockB) { // 获得lockB的锁
      this.another += m;
    } // 释放lockB的锁
  } // 释放lockA的锁
}

public void dec(int m) {
  synchronized(lockB) { // 获得lockB的锁
    this.another -= m;
    synchronized(lockA) { // 获得lockA的锁
      this.value -= m;
    } // 释放lockA的锁
  } // 释放lockB的锁
}
```

- 在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。对于上述代码，线程1和线程2如果分别执行`add()`和`dec()`方法时：
  - 线程1：进入`add()`，获得`lockA`
  - 线程2：进入`dec()`，获得`lockB`
- 随后：
  - 线程1：准备获得`lockB`，失败，等待中
  - 线程2：准备获得`lockA`，失败，等待中
- 此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。
- 死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。
- 因此，在编写多线程应用时，要特别注意防止死锁。因为死锁一旦形成，就只能强制结束进程。
- 那么我们应该如何避免死锁呢？答案是：线程获取锁的顺序要一致。即严格按照先获取`lockA`，再获取`lockB`的顺序，改写`dec()`方法如下：

```java
public void dec(int m) {
  synchronized(lockA) { // 获得lockA的锁
    this.value -= m;
    synchronized(lockB) { // 获得lockB的锁
      this.another -= m;
    } // 释放lockB的锁
  } // 释放lockA的锁
}
```

- **产生死锁的四个必要条件**
    - **互斥条件**:一个资源每次只能被一个进程使用
    - **请求与保持条件**:一个进程因请求资源而阻塞时,对已获得的资源保持不放
    - **不剥夺条件**:进程已获得的资源,在末使用完之前,不能强行剥夺
    - **循环等待条件**:若干进程之间形成一种头尾相接的循环等待资源关系
- `suspend()`和`resume()`方法天生容易发生死锁,调用`suspend()`时,目标线程会停下来,但却仍然持有在这之前获得的锁定,此时,其他任何线程都不能访问锁定的资源,除非被"挂起”的线程恢复运行,对任何线程来说,如果它们想恢复目标线程,同时又试图使用任何一个锁定的资源,就会造成令人难堪的死锁,因此从JDK1.2开始就建议不再使用`suspend()`和`resume()`,更强调`wait()`与`notify()`方法,可以在自己的线程类中置入一个标志变量,指出线程应该活动还是挂起,若标识指出线程应该挂起,便用`wait()`命其进入等待状态,若状态指出线程应当恢复,则用一个`notify()`重新启动线程

## Lock

- 从JDK5.0开始,Java提供了更强大的线程同步机制--通过显式定义同步锁对象来实现同步,同步锁使用Lock对象充当
- `java.util.concurrent.locks.Lock`接口是控制多个线程对共享资源进行访问的工具,锁提供了对共享资源的独占访问,每次只能有一个线程对Lock对象加锁,线程开 始访问共享资源之前应先获得Lock对象
- `ReentrantLock`类实现了Lock,,它拥有与`synchronized`相同的并发性和内存语义,在实现线程安全的控制中,比较常用的是`ReentrantLock`, 可以显式加锁,释放锁

```java
import java.util.concurrent.locks.ReentrantLock;

class TestLock implements Runnable {

    int ticketNums = 1000;
    //定义lock锁
    private final ReentrantLock lock = new ReentrantLock();

    public void run() {
        while (true) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //保证线程安全的代码
            try {
                if (ticketNums > 0) {
                    //加锁
                    lock.lock();
                    System.out.println(Thread.currentThread().getName()+"--- "+ticketNums--);
                } else {
                    break;
                }
                //如果同步代码可能有异常,要将unlock()写入finallly语句块
            } finally {
                //解锁
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        TestLock testLock = new TestLock();

        new Thread(testLock).start();
        new Thread(testLock).start();
        new Thread(testLock).start();
    }
}
```

> **syncchronized与Lock的对比**
>
> - Lock是显式锁(手动开启和关闭锁),synchronized是隐式锁,出了作用域自动释放
> - Lock只有代码块锁,synchronized有代码块和方法锁
> - 使用Lock锁,JVM将花费较少时间来调度线程,性能更好,并且具有更好的扩展性(提供更多的子类)
> - 使用优先顺序:Lock > 同步代码块 > 同步方法

## 不需要同步的操作

- JVM规范定义了几种原子操作：
  - 基本类型（`long`和`double`除外）赋值，例如：`int n = m`
  - 引用类型赋值，例如：`List<String> list = anotherList`
- `long`和`double`是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把`long`和`double`的赋值作为原子操作实现的。
- 单条原子操作的语句不需要同步。例如：

```java
public void set(int m) {
  synchronized(lock) {
    this.value = m;
  }
}
```

- 就不需要同步。
- 对引用也是类似。例如：

```java
public void set(String s) {
    this.value = s;
}
```

- 上述赋值语句并不需要同步。
- 但是，如果是多行赋值语句，就必须保证是同步操作，例如：

```java
class Pair {
  int first;
  int last;
  public void set(int first, int last) {
    synchronized(this) {
      this.first = first;
      this.last = last;
    }
  }
}
```

- 有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：

```java
class Pair {
    int[] pair;
    public void set(int first, int last) {
        int[] ps = new int[] { first, last };
        this.pair = ps;
    }
}
```

- 就不再需要同步，因为`this.pair = ps`是引用赋值的原子操作。而语句：

```java
int[] ps = new int[] { first, last };
```

- 这里的`ps`是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。