---
title: Java 线程同步
categories:
- Software
- Backend
- Java
- JavaSE
- 多线程
---
# Java 线程同步

## 临界资源问题

- 多个线程共享的数据称为临界资源,由于是线程调度程序负责线程的调度,程序员无法精确控制多线程的交替次序,如果没有特殊控制,多线程对临界资源的访问将导致数据的不一致性
- 以堆栈操作为例,涉及出栈和进栈两个操作,程序代码如下:

```java
public class Stack {
    int idx = 0;
    char[] data = new char[10];

    public void push(char c) {
        data[idx] = c;      //存入数据
        idx++;              //改变栈顶指针
    }
}

public  char pop() {
    idx--;
    return data[idx];
}
```

- 可以想象,线程在执行方法的过程中均可能因为调度问题而中断执行,如果一个线程在执行`push()`方法时将数据存入了堆栈(也即执行完第6行),但未给栈顶指针增值,这时中断执行,另一个线程则执行出栈操作,首先将栈指针减1,这样读到的数据显然不是栈顶数据,为避免此情况,可以采用`synchronized`给调用方法的对象加锁

## 同步方法与同步块(synchronized)

- `synchronized`保证一个方法处理的对象资源不会因其他方法的执行而改变,`synchronized`关键字的使用方法有如下两种:
    - 同步方法
        - 在方法前面,表示该方法为同步方法,执行该方法必须取得对象锁
        - 同步方法控制对象的访问,每个对象对应一把锁,每个同步方法都必须富哦的调用该方法的对象的锁才能执行,否则线程会阻塞,方法一旦执行,就独占锁,直到该方法返回才释放锁,后面被阻塞的线程才能获得这个锁,继续执行
    - 同步块
        - `sysnchronized(Obj){}`用在对象前面限制一段代码的执行,表示执行该段代码必需取得对象锁
- Obj称之为同步监视器
    - Obj可以是任何对象,但是推荐使用共享资源作为同步监视器
    - 同步方法中无需指定同步监视器,因为同步方法的同步监视器就是this,就是这个对象本身,或者是class
    - 同步监视器的执行过程
        1. 第一个线程访问,锁定同步监视器,执行其中代码
        2. 第二个线程访问,发现同步监视器被锁定,无法访问
        3. 第一个线程访问完毕,解锁同步监视器
        4. 第二个线程访问,发现同步监视器没有锁,然后锁定并访问

```java
public class Stack {
    int idx = 0;
    char[] data = new char[10];

    public void push(char c) {
        synchronized (this) {    //执行以下一段代码锁定对象
            data[idx] = c;      //存入数据
            idx++;              //改变栈顶指针
        }
    }

    public synchronized char pop() { //执行该方法时锁定对象
        idx--;
        return data[idx];
    }
}
```

- 被加锁的对象要在`synchronized`中限制代码执行完毕才会释放对象锁,在此之前,其他线程访问正被加锁的对象时将处于资源等待状态,对象的同步代码的执行过程如下图所示:

![Component-Page-2](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2020-12-10-2020-11-07-Component-Page-2-4724194.svg)

- 使用`synchronized`可能带来的问题
    - 一个线程持有锁会导致其他所有需要此临界资源的线程挂起
    - 在多线程竞争下,加锁,释放锁会导致比较多的上下文切换和调度延时,引起性能问题
    - 如果一个优先级高的线程等待一个优先级低的线程释放锁,会导致优先级倒置,引起性能问题

## 死锁

- 线程因等待某个条件而堵塞,而该条件因某个原因不可能发生,这时线程处于死锁状态,假设一个线程X在执行时需要获得对象a和b的独占锁定,首先它获得对象a的锁,然后试图获得对象b的锁,但假设程序在运行时有另一个线程Y已获得对象b的锁,显然线程X在线程Y释放对象b的锁之前不能继续执行,现在假设一个极端情况,如果线程Y又试图获得对象a的锁,则一切无望,线程X和线程Y双方均在等待获取对方掌握的锁才能继续执行
- 产生死锁的四个必要条件:
    - 互斥条件:一个资源每次只能被一个进程使用
    - 请求与保持条件:一个进程因请求资源而阻塞时,对已获得的资源保持不放
    - 不剥夺条件:进程已获得的资源,在末使用完之前,不能强行剥夺
    - 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系
- `suspend()`和`resume()`方法天生容易发生死锁,调用`suspend()`时,目标线程会停下来,但却仍然持有在这之前获得的锁定,此时,其他任何线程都不能访问锁定的资源,除非被"挂起”的线程恢复运行,对任何线程来说,如果它们想恢复目标线程,同时又试图使用任何一个锁定的资源,就会造成令人难堪的死锁,因此从JDK1.2开始就建议不再使用`suspend()`和`resume()`,更强调`wait()`与`notify()`方法,可以在自己的线程类中置入一个标志变量,指出线程应该活动还是挂起,若标识指出线程应该挂起,便用`wait()`命其进入等待状态,若状态指出线程应当恢复,则用一个`notify()`重新启动线程

## Lock

- 从JDK5.0开始,Java提供了更强大的线程同步机制--通过显式定义同步锁对象来实现同步,同步锁使用Lock对象充当
- `java.util.concurrent.locks.Lock`接口是控制多个线程对共享资源进行访问的工具,锁提供了对共享资源的独占访问,每次只能有一个线程对Lock对象加锁,线程开 始访问共享资源之前应先获得Lock对象
- `ReentrantLock`类实现了Lock,,它拥有与`synchronized`相同的并发性和内存语义,在实现线程安全的控制中,比较常用的是`ReentrantLock`, 可以显式加锁,释放锁

```java
import java.util.concurrent.locks.ReentrantLock;

class TestLock implements Runnable {

    int ticketNums = 1000;
    //定义lock锁
    private final ReentrantLock lock = new ReentrantLock();

    public void run() {
        while (true) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //保证线程安全的代码
            try {
                if (ticketNums > 0) {
                    //加锁
                    lock.lock();
                    System.out.println(Thread.currentThread().getName()+"--- "+ticketNums--);
                } else {
                    break;
                }
                //如果同步代码可能有异常,要将unlock()写入finallly语句块
            } finally {
                //解锁
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        TestLock testLock = new TestLock();

        new Thread(testLock).start();
        new Thread(testLock).start();
        new Thread(testLock).start();
    }
}
```

> **syncchronized与Lock的对比**
>
> - Lock是显式锁(手动开启和关闭锁),synchronized是隐式锁,出了作用域自动释放
> - Lock只有代码块锁,synchronized有代码块和方法锁
> - 使用Lock锁,JVM将花费较少时间来调度线程,性能更好,并且具有更好的扩展性(提供更多的子类)
> - 使用优先顺序:Lock > 同步代码块 > 同步方法