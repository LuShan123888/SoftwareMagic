---
title: 面试题
categories:
- Software
- Concept
---
# 面试题

## Java

### 1、面向对象的特征有哪些方面？

### 2、访问修饰符public,private,protected,以及不写（默认）时的区别？ 

| 修饰符    | 当前类 | 同 包 | 子 类 | 其他包                                                       |
| --------- | ------ | ----- | ----- | ------------------------------------------------------------ |
| public    | √      | √     | √     | √                                                            |
| protected | √      | √     | √     | ×                                                            |
| default   | √      | √     | ×     | ×                                                            |
| private   | √      | ×     | ×     | ×|
类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。 

### 3、String 是最基本的数据类型吗？

不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5以后引入的枚举类型也算是一种比较特殊的引用类型。

### 4、float f=3.4;是否正确？

不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。

### 5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？ 

对于`short s1 = 1; s1 = s1 + 1;`由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而`short s1 = 1; s1 += 1;`可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。

### 6、Java有没有goto？ 

goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）

### 7、int和Integer有什么区别？ 

- Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 
- Java 为每个原始类型提供了包装类型： 
  - 原始类型: boolean，char，byte，short，int，long，float，double 
  - 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double

```java
class AutoUnboxingTest {

  public static void main(String[] args) {
    Integer a = new Integer(3);
    Integer b = 3;                  // 将3自动装箱成Integer类型
    int c = 3;
    System.out.println(a == b);     // false 两个引用没有引用同一对象
    System.out.println(a == c);     // true a自动拆箱成int类型再和c比较
  }
}
```

- 最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：

```java
public class Test03 {

  public static void main(String[] args) {
    Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;

    System.out.println(f1 == f2);
    System.out.println(f3 == f4);
  }
}
```

- 如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。

```java
/**
     * Cache to support the object identity semantics of autoboxing for values between
     * -128 and 127 (inclusive) as required by JLS.
     *
     * The cache is initialized on first usage.  The size of the cache
     * may be controlled by the {@code -XX:AutoBoxCacheMax=<size>} option.
     * During VM initialization, java.lang.Integer.IntegerCache.high property
     * may be set and saved in the private system properties in the
     * sun.misc.VM class.
     */

private static class IntegerCache {
  static final int low = -128;
  static final int high;
  static final Integer cache[];

  static {
    // high value may be configured by property
    int h = 127;
    String integerCacheHighPropValue =
      sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
    if (integerCacheHighPropValue != null) {
      try {
        int i = parseInt(integerCacheHighPropValue);
        i = Math.max(i, 127);
        // Maximum array size is Integer.MAX_VALUE
        h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
      } catch( NumberFormatException nfe) {
        // If the property cannot be parsed into an int, ignore it.
      }
    }
    high = h;

    cache = new Integer[(high - low) + 1];
    int j = low;
    for(int k = 0; k < cache.length; k++)
      cache[k] = new Integer(j++);

    // range [-128, 127] must be interned (JLS7 5.1.7)
    assert IntegerCache.high >= 127;
  }

  private IntegerCache() {}
}
```

- 简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中`f1==f2`的结果是true，而`f3==f4`的结果是false。

### 8、&和&&的区别？ 

- &运算符有两种用法：按位与和逻辑与
- &&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。
- 很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：`username != null &&!username.equals("")`，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。
- 注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。

### 9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。

通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、"hello"和常量都是放在常量池中，常量池是方法区的一部分，。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。

```java
String str = new String("hello");
```

- 上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而"hello"这个字面量是放在方法区的。

> 补充1：较新版本的Java（从Java 6的某个更新开始）中，由于JIT编译器的发展和"逃逸分析"技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。
> 补充2：运行时常量池相当于Class文件常量池具有动态性，Java语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String类的intern()方法就是这样的。

- 看看下面代码的执行结果是什么并且比较一下Java 7以前和以后的运行结果是否一致。

```java
String s1 = new StringBuilder("go")
  .append("od").toString();
System.out.println(s1.intern() == s1);
String s2 = new StringBuilder("ja")
  .append("va").toString();
System.out.println(s2.intern() == s2);
```

### 10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？

Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。

### 11、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？ 

在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。

### 12、用最有效率的方法计算2乘以8？ 

2 << 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。

> 补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于(num << 5) - num，左移5位相当于乘以2的5次方再减去自身就相当于乘以31，现在的VM都能自动完成这个优化。
> 

```java
public class PhoneNumber {
  private int areaCode;
  private String prefix;
  private String lineNumber;

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + areaCode;
    result = prime * result
      + ((lineNumber == null) ? 0 : lineNumber.hashCode());
    result = prime * result + ((prefix == null) ? 0 : prefix.hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    PhoneNumber other = (PhoneNumber) obj;
    if (areaCode != other.areaCode)
      return false;
    if (lineNumber == null) {
      if (other.lineNumber != null)
        return false;
    } else if (!lineNumber.equals(other.lineNumber))
      return false;
    if (prefix == null) {
      if (other.prefix != null)
        return false;
    } else if (!prefix.equals(other.prefix))
      return false;
    return true;
  }

}
```

### 13、数组有没有length()方法？String有没有length()方法？ 

数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。

### 14、在Java中，如何跳出当前的多重嵌套循环？ 

在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）

### 15、构造器（constructor）是否可被重写（override）？

构造器不能被继承，因此不能被重写，但可以被重载。

### 16、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？

- 不对，如果两个对象x和y满足`x.equals(y) == true`，它们的哈希码（hash code）应当相同。
- Java对于eqauls方法和hashCode方法是这样规定的：
  1. 如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同
  2. 如果两个对象的hashCode相同，它们并不一定相同。
- 当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。

> 补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》）中是这样介绍equals方法的：
>
> - 首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。
> - 实现高质量的equals方法的诀窍包括：
>   1. 使用==操作符检查"参数是否为这个对象的引用"
>   2. 使用instanceof操作符检查"参数是否为正确的类型"
>   3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配
>   4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性
>   5. 重写equals时总是要重写hashCode
>   6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。

### 17、是否可以继承String类？ 

String 类是final类，不可以被继承。

> 补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。

### 18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？ 

是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。在C#中可以编写如下所示的代码，但是在Java中却做不到。

```java
using System;

namespace CS01 {

  class Program {
    public static void swap(ref int x, ref int y) {
      int temp = x;
      x = y;
      y = temp;
    }

    public static void Main (string[] args) {
      int a = 5, b = 10;
      swap (ref a, ref b);
      // a = 10, b = 5;
      Console.WriteLine ("a = {0}, b = {1}", a, b);
    }
  }
}
```

> 说明：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。
> 

### 19、String和StringBuilder、StringBuffer的区别？ 

Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。

> - **面试题1** - 什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？
> - **面试题2** - 请说出下面程序的输出。

```java
class StringEqualTest {

  public static void main(String[] args) {
    String s1 = "Programming";
    String s2 = new String("Programming");
    String s3 = "Program";
    String s4 = "ming";
    String s5 = "Program" + "ming";
    String s6 = s3 + s4;
    System.out.println(s1 == s2);// false
    System.out.println(s1 == s5);// true
    System.out.println(s1 == s6);// false
    System.out.println(s1 == s6.intern());// true
    System.out.println(s2 == s2.intern());// false
  }
}
```

> 补充：解答上面的面试题需要清楚两点：1. String对象的intern方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；2. 字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象，这一点可以用javap -c StringEqualTest.class命令获得class文件对应的JVM字节码指令就可以看出来。

### 20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？

- 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。
- 重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载
- 重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。

> **面试题：**华为的面试题中曾经问过这样一个问题 - “为什么不能根据返回类型来区分重载”，快说出你的答案吧！
>
>  
>
> - 因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。 
>
> ```java
> float max(int a, int b);
> int max(int a, int b);
> ```
>
> - 当调用`max(1,2);`时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的。
> - 再比如对下面这两个方法来说，虽然它们有同样的名字和自变量，但其实是很容易区分的：
>
> ```java
> void f() {} 
> int f() {} 
> ```
>
>  
>
> - 若编译器可根据上下文（语境）明确判断出含义，比如在int x = f（）中，那么这样做完全没有问题。然而，
>   我们也可能调用一个方法，同时忽略返回值;我们通常把这称为“为它的副作用去调用一个方法”，我因为
>   们关心的不是报道查看值，而是方法调用的其他效果所以假如我们象下面这样调用方法：
>
> ```java
> f();
> ```
>
> - Java怎样判断`f();`的具体调用方式呢？而且别人如何识别并理解代码呢？由于存在这一类的问题，所以不能根据返回值类型来区分过载的方法。
> - 函数的返回值只是作为函数运行之后的一个“状态”,他是保持方法的调用者与被调用者进行通信的关键。 ,并不能作为某个方法的“标识” 

### 21、描述一下JVM加载class文件的原理机制？

- JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 
- 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。 
- 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的

> **说明**：
>
> Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）
> Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap
> System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。

### 22、char 型变量中能不能存贮一个中文汉字，为什么？ 

char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。

> 补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。

### 23、抽象类（abstract class）和接口（interface）有什么异同？ 

- 抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。
  - 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。
- 接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。
- 抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。 

### 24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？

Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。

```java
/**
 * 扑克类（一副扑克）
 *
 */
public class Poker {
  private static String[] suites = {"黑桃", "红桃", "草花", "方块"};
  private static int[] faces = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};

  private Card[] cards;

  /**
     * 构造器
     * 
     */
  public Poker() {
    cards = new Card[52];
    for(int i = 0; i < suites.length; i++) {
      for(int j = 0; j < faces.length; j++) {
        cards[i * 13 + j] = new Card(suites[i], faces[j]);
      }
    }
  }

  /**
     * 洗牌 （随机乱序）
     * 
     */
  public void shuffle() {
    for(int i = 0, len = cards.length; i < len; i++) {
      int index = (int) (Math.random() * len);
      Card temp = cards[index];
      cards[index] = cards[i];
      cards[i] = temp;
    }
  }

  /**
     * 发牌
     * @param index 发牌的位置
     * 
     */
  public Card deal(int index) {
    return cards[index];
  }

  /**
     * 卡片类（一张扑克）
     * [内部类]
     *
     */
  public class Card {
    private String suite;   // 花色
    private int face;       // 点数

    public Card(String suite, int face) {
      this.suite = suite;
      this.face = face;
    }

    @Override
    public String toString() {
      String faceStr = "";
      switch(face) {
        case 1: faceStr = "A"; break;
        case 11: faceStr = "J"; break;
        case 12: faceStr = "Q"; break;
        case 13: faceStr = "K"; break;
        default: faceStr = String.valueOf(face);
      }
      return suite + faceStr;
    } 
  }
}
```

- 测试代码

```java
class PokerTest {

  public static void main(String[] args) {
    Poker poker = new Poker();
    poker.shuffle();                // 洗牌
    Poker.Card c1 = poker.deal(0);  // 发第一张牌
    // 对于非静态内部类Card
    // 只有通过其外部类Poker对象才能创建Card对象
    Poker.Card c2 = poker.new Card("红心", 1);    // 自己创建一张牌

    System.out.println(c1);     // 洗牌后的第一张
    System.out.println(c2);     // 打印: 红心A
  }
}
```

- 面试题 - 下面的代码哪些地方会产生编译错误？

```java
class Outer {

  class Inner {}

  public static void foo() { new Inner(); }

  public void bar() { new Inner(); }

  public static void main(String[] args) {
    new Inner();
  }
}
```

- 注意：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做：

```java
new Outer().new Inner();
```

### 25、Java 中会存在内存泄漏吗，请简单描述。 

理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。

```java
import java.util.Arrays;
import java.util.EmptyStackException;

public class MyStack<T> {
  private T[] elements;
  private int size = 0;

  private static final int INIT_CAPACITY = 16;

  public MyStack() {
    elements = (T[]) new Object[INIT_CAPACITY];
  }

  public void push(T elem) {
    ensureCapacity();
    elements[size++] = elem;
  }

  public T pop() {
    if(size == 0) 
      throw new EmptyStackException();
    return elements[--size];
  }

  private void ensureCapacity() {
    if(elements.length == size) {
      elements = Arrays.copyOf(elements, 2 * size + 1);
    }
  }
}
```

上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。

### 26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？ 

都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。

### 27、阐述静态变量和实例变量的区别。

静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。

**补充**：在Java开发中，上下文类和工具类中通常会有大量的静态成员。

### 28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？

不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。

### 29、如何实现对象克隆？ 

- 有两种方式： 
  1. 实现Cloneable接口并重写Object类中的clone()方法；
  2. 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。

```java
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class MyUtil {

  private MyUtil() {
    throw new AssertionError();
  }

  @SuppressWarnings("unchecked")
  public static <T extends Serializable> T clone(T obj) throws Exception {
    ByteArrayOutputStream bout = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(bout);
    oos.writeObject(obj);

    ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());
    ObjectInputStream ois = new ObjectInputStream(bin);
    return (T) ois.readObject();

    // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义
    // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放
  }
}
```

- 下面是测试代码：

```java
import java.io.Serializable;

/**
 * 人类
 *
 */
class Person implements Serializable {
  private static final long serialVersionUID = -9102017020286042305L;

  private String name;    // 姓名
  private int age;        // 年龄
  private Car car;        // 座驾

  public Person(String name, int age, Car car) {
    this.name = name;
    this.age = age;
    this.car = car;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  public Car getCar() {
    return car;
  }

  public void setCar(Car car) {
    this.car = car;
  }

  @Override
  public String toString() {
    return "Person [name=" + name + ", age=" + age + ", car=" + car + "]";
  }

}
```

```java
/**
 * 小汽车类
 *
 */
class Car implements Serializable {
  private static final long serialVersionUID = -5713945027627603702L;

  private String brand;       // 品牌
  private int maxSpeed;       // 最高时速

  public Car(String brand, int maxSpeed) {
    this.brand = brand;
    this.maxSpeed = maxSpeed;
  }

  public String getBrand() {
    return brand;
  }

  public void setBrand(String brand) {
    this.brand = brand;
  }

  public int getMaxSpeed() {
    return maxSpeed;
  }

  public void setMaxSpeed(int maxSpeed) {
    this.maxSpeed = maxSpeed;
  }

  @Override
  public String toString() {
    return "Car [brand=" + brand + ", maxSpeed=" + maxSpeed + "]";
  }

}
```

```java
class CloneTest {

    public static void main(String[] args) {
        try {
            Person p1 = new Person("Hao LUO", 33, new Car("Benz", 300));
            Person p2 = MyUtil.clone(p1);   // 深度克隆
            p2.getCar().setBrand("BYD");
            // 修改克隆的Person对象p2关联的汽车对象的品牌属性
            // 原来的Person对象p1关联的汽车不会受到任何影响
            // 因为在克隆Person对象时其关联的汽车对象也被克隆了
            System.out.println(p1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

##### 30、GC是什么？为什么要有GC？ 

- GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。 
- 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。

> **补充**：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域： 
>
> - 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。 
> - 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。 
> - 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。
>

- 与垃圾回收相关的JVM参数：

> -Xms / -Xmx — 堆的初始大小 / 堆的最大大小
>
> -Xmn — 堆中年轻代的大小
> -XX:-DisableExplicitGC — 让System.gc()不产生任何作用
> -XX:+PrintGCDetails — 打印GC的细节
> -XX:+PrintGCDateStamps — 打印GC操作的时间戳
> -XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小
> -XX:NewRatio — 可以设置老生代和新生代的比例
> -XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布
> -XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值
> -XX:TargetSurvivorRatio：设置幸存区的目标使用率

### 31、String s = new String("xyz");创建了几个字符串对象？

两个对象，一个是静态区的"xyz"，一个是用new创建在堆上的对象。

### 32、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？ 

接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。

### 33、一个".java"源文件中是否可以包含多个类（不是内部类）？有什么限制？ 

可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。

### 34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？ 

答：可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。

### 35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？ 

一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。

### 36、Java 中的final关键字有哪些用法？ 

1. 修饰类：表示该类不能被继承
2. 修饰方法：表示方法不能被重写
3. 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）

### 37、指出下面程序的运行结果。

```java
class A {

  static {
    System.out.print("1");
  }

  public A() {
    System.out.print("2");
  }
}

class B extends A{

  static {
    System.out.print("a");
  }

  public B() {
    System.out.print("b");
  }
}

public class Hello {

  public static void main(String[] args) {
    A ab = new B();
    ab = new B();
  }

}
```

执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。

### 38、数据类型之间的转换

- 如何将字符串转换为基本数据类型？ 
  - 调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型； 
- 如何将基本数据类型转换为字符串？ 
- 一种方法是将基本数据类型与空字符串（""）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串

### 39、如何实现字符串的反转及替换？ 

方法很多，可以自己写实现也可以使用String或StringBuffer/StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示

```java
public static String reverse(String originStr) {
  if(originStr == null || originStr.length() <= 1) 
    return originStr;
  return reverse(originStr.substring(1)) + originStr.charAt(0);
}
```

### 40、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？ 

代码如下所示：

```java
String s1 = "你好";
String s2 = new String(s1.getBytes("GB2312"), "ISO-8859-1");
```

### 41、日期和时间

**如何取得年月日、小时分钟秒？** 

- 创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值。Java 8中可以使用java.time.LocalDateTimel来获取，代码如下所示。

```java
public class DateTimeTest {
  public static void main(String[] args) {
    Calendar cal = Calendar.getInstance();
    System.out.println(cal.get(Calendar.YEAR));
    System.out.println(cal.get(Calendar.MONTH));    // 0 - 11
    System.out.println(cal.get(Calendar.DATE));
    System.out.println(cal.get(Calendar.HOUR_OF_DAY));
    System.out.println(cal.get(Calendar.MINUTE));
    System.out.println(cal.get(Calendar.SECOND));

    // Java 8
    LocalDateTime dt = LocalDateTime.now();
    System.out.println(dt.getYear());
    System.out.println(dt.getMonthValue());     // 1 - 12
    System.out.println(dt.getDayOfMonth());
    System.out.println(dt.getHour());
    System.out.println(dt.getMinute());
    System.out.println(dt.getSecond());
  }
}
```

**如何取得从1970年1月1日0时0分0秒到现在的毫秒数？** 

```java
Calendar.getInstance().getTimeInMillis();
System.currentTimeMillis();
Clock.systemDefaultZone().millis(); // Java 8
```

**如何取得某月的最后一天？** 

```java
Calendar time = Calendar.getInstance();
time.getActualMaximum(Calendar.DAY_OF_MONTH);
```

**如何格式化日期？** 

- 利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。Java 8中可以用java.time.format.DateTimeFormatter来格式化时间日期，代码如下所示。

```java
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Date;

class DateFormatTest {

  public static void main(String[] args) {
    SimpleDateFormat oldFormatter = new SimpleDateFormat("yyyy/MM/dd");
    Date date1 = new Date();
    System.out.println(oldFormatter.format(date1));

    // Java 8
    DateTimeFormatter newFormatter = DateTimeFormatter.ofPattern("yyyy/MM/dd");
    LocalDate date2 = LocalDate.now();
    System.out.println(date2.format(newFormatter));
  }
}
```

### 42、打印昨天的当前时刻。 

```java
import java.util.Calendar;

class YesterdayCurrent {
  public static void main(String[] args){
    Calendar cal = Calendar.getInstance();
    cal.add(Calendar.DATE, -1);
    System.out.println(cal.getTime());
  }
}
```

在Java 8中，可以用下面的代码实现相同的功能。

```java
import java.time.LocalDateTime;

class YesterdayCurrent {

  public static void main(String[] args) {
    LocalDateTime today = LocalDateTime.now();
    LocalDateTime yesterday = today.minusDays(1);

    System.out.println(yesterday);
  }
}
```

### 43、比较一下Java和JavaSciprt。 

- JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。 
- 下面对两种语言间的异同作如下比较： 
  - 基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。 
  - 解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率） 
  - 强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。 
  - 代码格式不一样。

> **补充**：上面列出的四点是网上流传的所谓的标准答案。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民，因此JavaScript支持函数式编程，可以使用Lambda函数和闭包（closure），当然Java 8也开始支持函数式编程，提供了对Lambda表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。

### 44、什么时候用断言（assert）？ 

断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError。断言的使用如下面的代码所示：

```java
assert(a > 0); // throws an AssertionError if a <= 0
```

- 断言可以有两种形式： 
  - assert Expression1; 
  - assert Expression1 : Expression2 ; 
- Expression1 应该总是产生一个布尔值。 
- Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。
- 要在运行时启用断言，可以在启动JVM时使用-enableassertions或者-ea标记。要在运行时选择禁用断言，可以在启动JVM时使用-da或者-disableassertions标记。要在系统类中启用或禁用断言，可使用-esa或-dsa标记。还可以在包的基础上启用或者禁用断言。
- **注意**：断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。

### 45、Error和Exception有什么区别？

Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。

> 面试题：2005年摩托罗拉的面试中曾经问过这么一个问题“If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java程序在运行时也可能会遭遇StackOverflowError，这是一个无法恢复的错误，只能重新修改代码了，这个面试题的答案是c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示：
>
> ```java
> class StackOverflowErrorTest {
> 
>     public static void main(String[] args) {
>         main(null);
>     }
> }
> ```
>
> **提示**:用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再继续递归）

### 46、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后? 

- 会执行，在方法返回调用者前执行。
- **注意**：在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值,如果仅仅只是修改了值而已，但是没有再执行return语句覆盖掉原来的值的话，应该是不会返回修改后的值

### 47、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？

Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；finally为确保一段代码不管发生什么异常状况都要被执行；try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。

### 48、运行时异常与受检异常有何异同？ 

- 异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则： 
  - 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常） 
  - 对可以恢复的情况使用受检异常，对编程错误使用运行时异常 
  - 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生） 
  - 优先使用标准的异常 
  - 每个方法抛出的异常都要有文档 
  - 保持异常的原子性 
  - 不要在catch中忽略掉捕获到的异常

### 49、列出一些你常见的运行时异常？

- ArithmeticException（算术异常） 
- ClassCastException （类转换异常） 
- IllegalArgumentException （非法参数异常） 
- IndexOutOfBoundsException （下标越界异常） 
- NullPointerException （空指针异常） 
- SecurityException （安全异常）

### 50、阐述final、finally、finalize的区别。

- final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。 
- finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。 
- finalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。

### 51、类ExampleA继承Exception，类ExampleB继承ExampleA。 

有如下代码片断：

```java
try {
  throw new ExampleB("b")
} catch（ExampleA e）{
  System.out.println("ExampleA");
} catch（Exception e）{
  System.out.println("Exception");
}
```

请问执行此段代码的输出是什么？ 
输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常）

> 面试题 - 说出下面代码的运行结果。（此题的出处是《Java编程思想》一书）
>
> ```java
> class Annoyance extends Exception {}
> class Sneeze extends Annoyance {}
> 
> class Human {
> 
>   public static void main(String[] args) 
>     throws Exception {
>     try {
>       try {
>         throw new Sneeze();
>       } 
>       catch ( Annoyance a ) {
>         System.out.println("Caught Annoyance");
>         throw a;
>       }
>     } 
>     catch ( Sneeze s ) {
>       System.out.println("Caught Sneeze");
>       return ;
>     }
>     finally {
>       System.out.println("Hello World!");
>     }
>   }
> }
> ```
>

### 52、List、Set、Map是否继承自Collection接口？ 

List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。

### 53、阐述ArrayList、Vector、LinkedList的存储性能和特性。 

ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。

> **补充**：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系（关联）或Use-A关系（依赖）。同理，Stack类继承Vector也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。
>

### 54、Collection和Collections的区别？

Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。

### 55、List、Map、Set三个接口存取元素时，各有什么特点？

List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。

### 56、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？ 

TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。 

例子1：

```java
public class Student implements Comparable<Student> {
  private String name;        // 姓名
  private int age;            // 年龄

  public Student(String name, int age) {
    this.name = name;
    this.age = age;
  }

  @Override
  public String toString() {
    return "Student [name=" + name + ", age=" + age + "]";
  }

  @Override
  public int compareTo(Student o) {
    return this.age - o.age; // 比较年龄(年龄的升序)
  }

}
```

```java
import java.util.Set;
import java.util.TreeSet;

class Test01 {

  public static void main(String[] args) {
    Set<Student> set = new TreeSet<>();     // Java 7的钻石语法(构造器后面的尖括号中不需要写类型)
    set.add(new Student("Hao LUO", 33));
    set.add(new Student("XJ WANG", 32));
    set.add(new Student("Bruce LEE", 60));
    set.add(new Student("Bob YANG", 22));

    for(Student stu : set) {
      System.out.println(stu);
    }
    //      输出结果: 
    //      Student [name=Bob YANG, age=22]
    //      Student [name=XJ WANG, age=32]
    //      Student [name=Hao LUO, age=33]
    //      Student [name=Bruce LEE, age=60]
  }
}
```

例子2：

```java
public class Student {
  private String name;    // 姓名
  private int age;        // 年龄

  public Student(String name, int age) {
    this.name = name;
    this.age = age;
  }

  /**
     * 获取学生姓名
     */
  public String getName() {
    return name;
  }

  /**
     * 获取学生年龄
     */
  public int getAge() {
    return age;
  }

  @Override
  public String toString() {
    return "Student [name=" + name + ", age=" + age + "]";
  }

}
```

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

class Test02 {

  public static void main(String[] args) {
    List<Student> list = new ArrayList<>();     // Java 7的钻石语法(构造器后面的尖括号中不需要写类型)
    list.add(new Student("Hao LUO", 33));
    list.add(new Student("XJ WANG", 32));
    list.add(new Student("Bruce LEE", 60));
    list.add(new Student("Bob YANG", 22));

    // 通过sort方法的第二个参数传入一个Comparator接口对象
    // 相当于是传入一个比较对象大小的算法到sort方法中
    // 由于Java中没有函数指针、仿函数、委托这样的概念
    // 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调
    Collections.sort(list, new Comparator<Student> () {

      @Override
      public int compare(Student o1, Student o2) {
        return o1.getName().compareTo(o2.getName());    // 比较学生姓名
      }
    });

    for(Student stu : list) {
      System.out.println(stu);
    }
    //      输出结果: 
    //      Student [name=Bob YANG, age=22]
    //      Student [name=Bruce LEE, age=60]
    //      Student [name=Hao LUO, age=33]
    //      Student [name=XJ WANG, age=32]
  }
}
```

### 57、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别? 

答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

补充：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的Node.js就采用了单线程异步I/O的工作模式。

### 58、线程的sleep()方法和yield()方法有什么区别？ 

- sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会
- 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态
- sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常
- sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性

### 59、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？ 

不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。

### 60、请说出与线程同步以及线程调度相关的方法。 

- wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁
- sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常
- notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关
- notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状

> **提示**：关于Java多线程和并发编程的问题，建议大家看我的另一篇文章《关于Java并发编程的总结和思考》。
> 补充：Java 5通过Lock接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。
>

下面的例子演示了100个线程同时向一个银行账户中存入1元钱，在没有使用同步机制和使用同步机制情况下的执行情况。

- 银行账户类：

```java
/**
 * 银行账户
 *
 */
public class Account {
  private double balance;     // 账户余额

  /**
     * 存款
     * @param money 存入金额
     */
  public void deposit(double money) {
    double newBalance = balance + money;
    try {
      Thread.sleep(10);   // 模拟此业务需要一段处理时间
    }
    catch(InterruptedException ex) {
      ex.printStackTrace();
    }
    balance = newBalance;
  }

  /**
     * 获得账户余额
     */
  public double getBalance() {
    return balance;
  }
}
```

- 存钱线程类

```java
/**
 * 存钱线程
 *
 */
public class AddMoneyThread implements Runnable {
  private Account account;    // 存入账户
  private double money;       // 存入金额

  public AddMoneyThread(Account account, double money) {
    this.account = account;
    this.money = money;
  }

  @Override
  public void run() {
    account.deposit(money);
  }

}
```

- 测试类

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Test01 {

  public static void main(String[] args) {
    Account account = new Account();
    ExecutorService service = Executors.newFixedThreadPool(100);

    for(int i = 1; i <= 100; i++) {
      service.execute(new AddMoneyThread(account, 1));
    }

    service.shutdown();

    while(!service.isTerminated()) {}

    System.out.println("账户余额: " + account.getBalance());
  }
}
```

在没有同步的情况下，执行结果通常是显示账户余额在10元以下，出现这种状况的原因是，当一个线程A试图存入1元的时候，另外一个线程B也能够进入存款的方法中，线程B读取到的账户余额仍然是线程A存入1元钱之前的账户余额，因此也是在原来的余额0上面做了加1元的操作，同理线程C也会做类似的事情，所以最后100个线程执行结束时，本来期望账户余额为100元，但实际得到的通常在10元以下（很可能是1元哦）。解决这个问题的办法就是同步，当一个线程对银行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行操作，代码有如下几种调整方案：

- 在银行账户的存款（deposit）方法上同步（synchronized）关键字

```java
/**
 * 银行账户
 *
 */
public class Account {
  private double balance;     // 账户余额

  /**
     * 存款
     * @param money 存入金额
     */
  public synchronized void deposit(double money) {
    double newBalance = balance + money;
    try {
      Thread.sleep(10);   // 模拟此业务需要一段处理时间
    }
    catch(InterruptedException ex) {
      ex.printStackTrace();
    }
    balance = newBalance;
  }

  /**
     * 获得账户余额
     */
  public double getBalance() {
    return balance;
  }
}
```

- 在线程调用存款方法时对银行账户进行同步

```java
/**
 * 银行账户
 *
 */
public class Account {
  private double balance;     // 账户余额

  /**
     * 存款
     * @param money 存入金额
     */
  public void deposit(double money) {
    double newBalance = balance + money;
    try {
      Thread.sleep(10);   // 模拟此业务需要一段处理时间
    }
    catch(InterruptedException ex) {
      ex.printStackTrace();
    }
    balance = newBalance;
  }

  /**
     * 获得账户余额
     */
  public double getBalance() {
    return balance;
  }
}
```

- 通过Java 5显示的锁机制，为每个银行账户创建一个锁对象，在存款操作进行加锁和解锁的操作

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 银行账户
 * 
 *
 */
public class Account {
  private Lock accountLock = new ReentrantLock();
  private double balance; // 账户余额

  /**
     * 存款
     * 
     * @param money
     *            存入金额
     */
  public void deposit(double money) {
    accountLock.lock();
    try {
      double newBalance = balance + money;
      try {
        Thread.sleep(10); // 模拟此业务需要一段处理时间
      }
      catch (InterruptedException ex) {
        ex.printStackTrace();
      }
      balance = newBalance;
    }
    finally {
      accountLock.unlock();
    }
  }

  /**
     * 获得账户余额
     */
  public double getBalance() {
    return balance;
  }
}
```

- 按照上述三种方式对代码进行修改后，重写执行测试代码Test01，将看到最终的账户余额为100元。当然也可以使用Semaphore或CountdownLatch来实现同步。

### 61、编写多线程程序有几种实现方式？ 

Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。

> **补充**：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示：
>
> ```java
> import java.util.ArrayList;
> import java.util.List;
> import java.util.concurrent.Callable;
> import java.util.concurrent.ExecutorService;
> import java.util.concurrent.Executors;
> import java.util.concurrent.Future;
> 
> 
> class MyTask implements Callable<Integer> {
>   private int upperBounds;
> 
>   public MyTask(int upperBounds) {
>     this.upperBounds = upperBounds;
>   }
> 
>   @Override
>   public Integer call() throws Exception {
>     int sum = 0; 
>     for(int i = 1; i <= upperBounds; i++) {
>       sum += i;
>     }
>     return sum;
>   }
> 
> }
> 
> class Test {
> 
>   public static void main(String[] args) throws Exception {
>     List<Future<Integer>> list = new ArrayList<>();
>     ExecutorService service = Executors.newFixedThreadPool(10);
>     for(int i = 0; i < 10; i++) {
>       list.add(service.submit(new MyTask((int) (Math.random() * 100))));
>     }
> 
>     int sum = 0;
>     for(Future<Integer> future : list) {
>       // while(!future.isDone()) ;
>       sum += future.get();
>     }
> 
>     System.out.println(sum);
>   }
> }
> ```
>

### 62、synchronized关键字的用法？ 

synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。在第60题的例子中已经展示了synchronized关键字的用法。

### 63、举例说明同步和异步。 

如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。

### 64、启动一个线程是调用run()还是start()方法？ 

答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。

### 65、什么是线程池（thread pool）？ 

- 在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。 
- Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示： 
  - newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 
  - newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 
  - newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 
  - newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 
  - newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。
- 第60题的例子中演示了通过Executors工具类创建线程池并使用线程池执行线程的代码。如果希望在服务器上使用线程池，强烈建议使用newFixedThreadPool方法来创建线程池，这样能获得更好的性能。

### 66、线程的基本状态以及状态之间的关系？ 

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-04-10-20150408002007838.png)

> **说明**：其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。

### 67、简述synchronized 和java.util.concurrent.locks.Lock的异同？ 

Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成synchronized所实现的所有功能；主要不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。

### 68、Java中如何实现序列化，有什么意义？

- 序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。 
- 要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第29题）。
  

### 69、Java中有几种类型的流？ 

字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于Java的I/O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外Java中的流不同于C#的是它只有一个维度一个方向。

> **面试题** - 编程实现文件拷贝。（这个题目在笔试的时候经常出现，下面的代码给出了两种实现方案）
>
> ```java
> import java.io.FileInputStream;
> import java.io.FileOutputStream;
> import java.io.IOException;
> import java.io.InputStream;
> import java.io.OutputStream;
> import java.nio.ByteBuffer;
> import java.nio.channels.FileChannel;
> 
> public final class MyUtil {
> 
>   private MyUtil() {
>     throw new AssertionError();
>   }
> 
>   public static void fileCopy(String source, String target) throws IOException {
>     try (InputStream in = new FileInputStream(source)) {
>       try (OutputStream out = new FileOutputStream(target)) {
>         byte[] buffer = new byte[4096];
>         int bytesToRead;
>         while((bytesToRead = in.read(buffer)) != -1) {
>           out.write(buffer, 0, bytesToRead);
>         }
>       }
>     }
>   }
> 
>   public static void fileCopyNIO(String source, String target) throws IOException {
>     try (FileInputStream in = new FileInputStream(source)) {
>       try (FileOutputStream out = new FileOutputStream(target)) {
>         FileChannel inChannel = in.getChannel();
>         FileChannel outChannel = out.getChannel();
>         ByteBuffer buffer = ByteBuffer.allocate(4096);
>         while(inChannel.read(buffer) != -1) {
>           buffer.flip();
>           outChannel.write(buffer);
>           buffer.clear();
>         }
>       }
>     }
>   }
> }
> ```

### 70、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。 

代码如下：

```java
import java.io.BufferedReader;
import java.io.FileReader;

public final class MyUtil {

  // 工具类中的方法都是静态方式访问的因此将构造器私有不允许创建对象(绝对好习惯)
  private MyUtil() {
    throw new AssertionError();
  }

  /**
     * 统计给定文件中给定字符串的出现次数
     * 
     * @param filename  文件名
     * @param word 字符串
     * @return 字符串在文件中出现的次数
     */
  public static int countWordInFile(String filename, String word) {
    int counter = 0;
    try (FileReader fr = new FileReader(filename)) {
      try (BufferedReader br = new BufferedReader(fr)) {
        String line = null;
        while ((line = br.readLine()) != null) {
          int index = -1;
          while (line.length() >= word.length() && (index = line.indexOf(word)) >= 0) {
            counter++;
            line = line.substring(index + word.length());
          }
        }
      }
    } catch (Exception ex) {
      ex.printStackTrace();
    }
    return counter;
  }

}
```

### 71、如何用Java代码列出一个目录下所有的文件？ 

如果只要求列出当前文件夹下的文件，代码如下所示：

```java
import java.io.File;

class Test12 {

  public static void main(String[] args) {
    File f = new File("/Users/Hao/Downloads");
    for(File temp : f.listFiles()) {
      if(temp.isFile()) {
        System.out.println(temp.getName());
      }
    }
  }
}
```

如果需要对文件夹继续展开，代码如下所示：

```java
import java.io.File;

class Test12 {

  public static void main(String[] args) {
    showDirectory(new File("/Users/Hao/Downloads"));
  }

  public static void showDirectory(File f) {
    _walkDirectory(f, 0);
  }

  private static void _walkDirectory(File f, int level) {
    if(f.isDirectory()) {
      for(File temp : f.listFiles()) {
        _walkDirectory(temp, level + 1);
      }
    }
    else {
      for(int i = 0; i < level - 1; i++) {
        System.out.print("\t");
      }
      System.out.println(f.getName());
    }
  }
}
```

在Java 7中可以使用NIO.2的API来做同样的事情，代码如下所示：

```java
class ShowFileTest {

  public static void main(String[] args) throws IOException {
    Path initPath = Paths.get("/Users/Hao/Downloads");
    Files.walkFileTree(initPath, new SimpleFileVisitor<Path>() {

      @Override
      public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) 
        throws IOException {
        System.out.println(file.getFileName().toString());
        return FileVisitResult.CONTINUE;
      }
    });
  }
}
```

### 72、用Java的套接字编程实现一个多线程的回显（echo）服务器。 

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

public class EchoServer {

  private static final int ECHO_SERVER_PORT = 6789;

  public static void main(String[] args) {        
    try(ServerSocket server = new ServerSocket(ECHO_SERVER_PORT)) {
      System.out.println("服务器已经启动...");
      while(true) {
        Socket client = server.accept();
        new Thread(new ClientHandler(client)).start();
      }
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  private static class ClientHandler implements Runnable {
    private Socket client;

    public ClientHandler(Socket client) {
      this.client = client;
    }

    @Override
    public void run() {
      try(BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));
          PrintWriter pw = new PrintWriter(client.getOutputStream())) {
        String msg = br.readLine();
        System.out.println("收到" + client.getInetAddress() + "发送的: " + msg);
        pw.println(msg);
        pw.flush();
      } catch(Exception ex) {
        ex.printStackTrace();
      } finally {
        try {
          client.close();
        } catch (IOException e) {
          e.printStackTrace();
        }
      }
    }
  }

}
```

> **注意**：上面的代码使用了Java 7的TWR语法，由于很多外部资源类都间接的实现了AutoCloseable接口（单方法回调接口），因此可以利用TWR语法在try结束的时候通过回调的方式自动调用外部资源类的close()方法，避免书写冗长的finally代码块。此外，上面的代码用一个静态内部类实现线程的功能，使用多线程可以避免一个用户I/O操作所产生的中断影响其他用户对服务器的访问，简单的说就是一个用户的输入操作不会造成其他用户的阻塞。当然，上面的代码使用线程池可以获得更好的性能，因为频繁的创建和销毁线程所造成的开销也是不可忽视的。

下面是一段回显客户端测试代码：

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;

public class EchoClient {

  public static void main(String[] args) throws Exception {
    Socket client = new Socket("localhost", 6789);
    Scanner sc = new Scanner(System.in);
    System.out.print("请输入内容: ");
    String msg = sc.nextLine();
    sc.close();
    PrintWriter pw = new PrintWriter(client.getOutputStream());
    pw.println(msg);
    pw.flush();
    BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));
    System.out.println(br.readLine());
    client.close();
  }
}
```

如果希望用NIO的多路复用套接字实现服务器，代码如下所示。NIO的操作虽然带来了更好的性能，但是有些操作是比较底层的，对于初学者来说还是有些难于理解。

```java
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;

public class EchoServerNIO {

  private static final int ECHO_SERVER_PORT = 6789;
  private static final int ECHO_SERVER_TIMEOUT = 5000;
  private static final int BUFFER_SIZE = 1024;

  private static ServerSocketChannel serverChannel = null;
  private static Selector selector = null;    // 多路复用选择器
  private static ByteBuffer buffer = null;    // 缓冲区

  public static void main(String[] args) {
    init();
    listen();
  }

  private static void init() {
    try {
      serverChannel = ServerSocketChannel.open();
      buffer = ByteBuffer.allocate(BUFFER_SIZE);
      serverChannel.socket().bind(new InetSocketAddress(ECHO_SERVER_PORT));
      serverChannel.configureBlocking(false);
      selector = Selector.open();
      serverChannel.register(selector, SelectionKey.OP_ACCEPT);
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  private static void listen() {
    while (true) {
      try {
        if (selector.select(ECHO_SERVER_TIMEOUT) != 0) {
          Iterator<SelectionKey> it = selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key = it.next();
            it.remove();
            handleKey(key);
          }
        }
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }

  private static void handleKey(SelectionKey key) throws IOException {
    SocketChannel channel = null;

    try {
      if (key.isAcceptable()) {
        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
        channel = serverChannel.accept();
        channel.configureBlocking(false);
        channel.register(selector, SelectionKey.OP_READ);
      } else if (key.isReadable()) {
        channel = (SocketChannel) key.channel();
        buffer.clear();
        if (channel.read(buffer) > 0) {
          buffer.flip();
          CharBuffer charBuffer = CharsetHelper.decode(buffer);
          String msg = charBuffer.toString();
          System.out.println("收到" + channel.getRemoteAddress() + "的消息：" + msg);
          channel.write(CharsetHelper.encode(CharBuffer.wrap(msg)));
        } else {
          channel.close();
        }
      }
    } catch (Exception e) {
      e.printStackTrace();
      if (channel != null) {
        channel.close();
      }
    }
  }

}
```

```java
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;

public final class CharsetHelper {
  private static final String UTF_8 = "UTF-8";
  private static CharsetEncoder encoder = Charset.forName(UTF_8).newEncoder();
  private static CharsetDecoder decoder = Charset.forName(UTF_8).newDecoder();

  private CharsetHelper() {
  }

  public static ByteBuffer encode(CharBuffer in) throws CharacterCodingException{
    return encoder.encode(in);
  }

  public static CharBuffer decode(ByteBuffer in) throws CharacterCodingException{
    return decoder.decode(in);
  }
}
```

### 73、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？ 

XML文档定义分为DTD和Schema两种形式，二者都是对XML语法的约束，其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析，而且可以为XML承载的数据定义类型，约束能力较之DTD更强大。对XML的解析主要有DOM（文档对象模型，Document Object Model）、SAX（Simple API for XML）和StAX（Java 6中引入的新的解析XML的方式，Streaming API for XML），其中DOM处理大型文件时其性能下降的非常厉害，这个问题是由DOM树结构占用的内存较多造成的，而且DOM解析方式必须在解析文件之前把整个文档装入内存，适合对XML的随机访问（典型的用空间换取时间的策略）；SAX是事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理XML文件，适合对XML的顺序访问；顾名思义，StAX把重点放在流上，实际上StAX与其他解析方式的本质区别就在于应用程序能够把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖（SAX就是这样做的），但不同之处在于StAX允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。

### 74、你在项目中哪些地方用到了XML？ 

XML的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML将数据用标签组装成起来，然后压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再从XML文件中还原相关信息进行处理，XML曾经是异构系统间交换数据的事实标准，但此项功能几乎已经被JSON（JavaScript Object Notation）取而代之。当然，目前很多软件仍然使用XML来存储配置信息，我们在很多项目中通常也会将作为配置信息的硬代码写在XML文件中，Java的很多框架也是这么做的，而且这些框架都选择了dom4j作为处理XML的工具，因为Sun公司的官方API实在不怎么好用。

> **补充**：现在有很多时髦的软件（如Sublime）已经开始将配置文件书写成JSON格式，我们已经强烈的感受到XML的另一项功能也将逐渐被业界抛弃。

### 75、阐述JDBC操作数据库的步骤。 

下面的代码以连接本机的Oracle数据库为例，演示JDBC操作数据库的步骤。

- 加载驱动

```java
Class.forName("oracle.jdbc.driver.OracleDriver");
```

- 创建连接

```java
Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:orcl", "scott", "tiger");
```

- 创建语句

```java
PreparedStatement ps = con.prepareStatement("select * from emp where sal between ? and ?");
ps.setInt(1, 1000);
ps.setInt(2, 3000);
```

- 执行语句

```java
ResultSet rs = ps.executeQuery();
```

- 处理结果

```java
while(rs.next()) {
  System.out.println(rs.getInt("empno") + " - " + rs.getString("ename"));
}
```

- 关闭资源

```java
finally {
  if(con != null) {
    try {
      con.close();
    } catch (SQLException e) {
      e.printStackTrace();
    }
  }
}
```

> **提示**：关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭ResultSet、再关闭Statement、在关闭Connection。上面的代码只关闭了Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在JDBC 4.0中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。

### 76、Statement和PreparedStatement有什么区别？哪个性能更好？ 

- PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）
- PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全
- 当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。

> **补充**：为了提供对存储过程的调用，JDBC API中还提供了CallableStatement接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的SQL语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。

### 77、使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？ 

- 要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的setFetchSize()方法指定每次抓取的记录数（典型的空间换时间策略）
- 要提升更新数据的性能可以使用PreparedStatement语句构建批处理，将若干SQL语句置于一个批处理中执行

### 78、在进行数据库编程时，连接池有什么作用？ 

由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid等。

> **补充**：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。

### 79、什么是DAO模式？

DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。

### 80、事务的ACID是指什么？ 

- 原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败
- 一致性(Consistent)：事务结束后系统状态是一致的
- 隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态
- 持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据

> **补充**：关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在5类问题，包括3类数据读取问题（脏读、不可重复读和幻读）和2类数据更新问题（第1类丢失更新和第2类丢失更新）。
>

脏读（Dirty Read）：A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。

| 时间 | 转账事务A                   | 取款事务B                |
| ---- | --------------------------- | ------------------------ |
| T1   |                             | 开始事务                 |
| T2   | 开始事务                    |                          |
| T3   |                             | 查询账户余额为1000元     |
| T4   |                             | 取出500元余额修改为500元 |
| T5   | 查询账户余额为500元（脏读） |                          |
| T6   |                             | 撤销事务余额恢复为1000元 |
| T7   | 汇入100元把余额修改为600元  |                          |
| T8   | 提交事务                    |                          |

不可重复读（Unrepeatable Read）：事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了。

| 时间 | 转账事务A                         | 取款事务B                |
| ---- | --------------------------------- | ------------------------ |
| T1   |                                   | 开始事务                 |
| T2   | 开始事务                          |                          |
| T3   |                                   | 查询账户余额为1000元     |
| T4   | 查询账户余额为1000元              |                          |
| T5   |                                   | 取出100元修改余额为900元 |
| T6   |                                   | 提交事务                 |
| T7   | 查询账户余额为900元（不可重复读） |                          |

幻读（Phantom Read）：事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务B提交的行。

| 时间 | 统计金额事务A                   | 转账事务B                 |
| ---- | ------------------------------- | ------------------------- |
| T1   |                                 | 开始事务                  |
| T2   | 开始事务                        |                           |
| T3   | 统计总存款为10000元             |                           |
| T4   |                                 | 新增一个存款账户存入100元 |
| T5   |                                 | 提交事务                  |
| T6   | 再次统计总存款为10100元（幻读） |                           |

第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。

| 时间 | 取款事务A                    | 转账事务B                 |
| ---- | ---------------------------- | ------------------------- |
| T1   | 开始事务                     |                           |
| T2   |                              | 开始事务                  |
| T3   | 查询账户余额为1000元         |                           |
| T4   |                              | 查询账户余额为1000元      |
| T5   |                              | 汇入100元修改余额为1100元 |
| T6   |                              | 提交事务                  |
| T7   | 取出100元将余额修改为900元   |                           |
| T8   | 撤销事务                     |                           |
| T9   | 余额恢复为1000元（丢失更新） |                           |

第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。

| 时间 | 转账事务A                        | 取款事务B                  |
| ---- | -------------------------------- | -------------------------- |
| T1   |                                  | 开始事务                   |
| T2   | 开始事务                         |                            |
| T3   |                                  | 查询账户余额为1000元       |
| T4   | 查询账户余额为1000元             |                            |
| T5   |                                  | 取出100元将余额修改为900元 |
| T6   |                                  | 提交事务                   |
| T7   | 汇入100元将余额修改为1100元      |                            |
| T8   | 提交事务                         |                            |
| T9   | 查询账户余额为1100元（丢失更新） |                            |

- 数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，按锁定对象不同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁，具体的内容大家可以自行查阅资料进行了解。 
- 直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定会话的事务隔离级别，数据库就会通过分析SQL语句然后为事务访问的资源加上合适的锁，此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的（就是说你不用理解，事实上我确实也不知道）。ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别，如下表所示：

| 隔离级别        | 脏读   | 不可重复读 | 幻读   | 第一类丢失更新 | 第二类丢失更新 |
| --------------- | ------ | ---------- | ------ | -------------- | -------------- |
| READ UNCOMMITED | 允许   | 允许       | 允许   | 不允许         | 允许           |
| READ COMMITTED  | 不允许 | 允许       | 允许   | 不允许         | 允许           |
| REPEATABLE READ | 不允许 | 不允许     | 允许   | 不允许         | 不允许         |
| SERIALIZABLE    | 不允许 | 不允许     | 不允许 | 不允许         | 不允许         |

需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。

### 81、JDBC中如何进行事务处理？ 

Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC 3.0中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。 

![这里写图片描述](https://img-blog.csdn.net/20150408174308284)

### 82、JDBC能否处理Blob和Clob？ 

- Blob是指二进制大对象（Binary Large Object），而Clob是指大字符对象（Character Large Objec），因此其中Blob是为存储大的二进制数据而设计的，而Clob是为存储大的文本数据而设计的。JDBC的PreparedStatement和ResultSet都提供了相应的方法来支持Blob和Clob操作。
- 下面的代码展示了如何使用JDBC操作LOB： 
  下面以MySQL数据库为例，创建一个张有三个字段的用户表，包括编号（id）、姓名（name）和照片（photo），建表语句如下：

```sql
create table tb_user
  (
    id int primary key auto_increment,
    name varchar(20) unique not null,
    photo longblob
  );
```

下面的Java代码向数据库中插入一条记录：

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

class JdbcLobTest {

  public static void main(String[] args) {
    Connection con = null;
    try {
      // 1. 加载驱动（Java6以上版本可以省略）
      Class.forName("com.mysql.jdbc.Driver");
      // 2. 建立连接
      con = DriverManager.getConnection("jdbc:mysql://localhost:3306/test", "root", "123456");
      // 3. 创建语句对象
      PreparedStatement ps = con.prepareStatement("insert into tb_user values (default, ?, ?)");
      ps.setString(1, "Test");              // 将SQL语句中第一个占位符换成字符串
      try (InputStream in = new FileInputStream("test.jpg")) {    // Java 7的TWR
        ps.setBinaryStream(2, in);      // 将SQL语句中第二个占位符换成二进制流
        // 4. 发出SQL语句获得受影响行数
        System.out.println(ps.executeUpdate() == 1 ? "插入成功" : "插入失败");
      } catch(IOException e) {
        System.out.println("读取照片失败!");
      }
    } catch (ClassNotFoundException | SQLException e) {     // Java 7的多异常捕获
      e.printStackTrace();
    } finally { // 释放外部资源的代码都应当放在finally中保证其能够得到执行
      try {
        if(con != null && !con.isClosed()) {
          con.close();    // 5. 释放数据库连接 
          con = null;     // 指示垃圾回收器可以回收该对象
        }
      } catch (SQLException e) {
        e.printStackTrace();
      }
    }
  }
}
```

### 83、简述正则表达式及其用途

在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。

> **说明**：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。
>

### 84、Java中是如何支持正则表达式操作的？ 

Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，请参考下面面试题的代码。

> **面试题**:如果要从字符串中截取第一个英文左括号之前的字符串，例如：北京市(朝阳区)(西城区)(海淀区)，截取结果为：北京市，那么正则表达式怎么写？
>
> ```java
> import java.util.regex.Matcher;
> import java.util.regex.Pattern;
> 
> class RegExpTest {
> 
>   public static void main(String[] args) {
>     String str = "北京市(朝阳区)(西城区)(海淀区)";
>     Pattern p = Pattern.compile(".*?(?=\\()");
>     Matcher m = p.matcher(str);
>     if(m.find()) {
>       System.out.println(m.group());
>     }
>   }
> }
> ```

### 85、获得一个类的类对象有哪些方式？ 

1. 类型.class，例如：String.class 
2. 对象.getClass()，例如："hello".getClass() 
3. Class.forName()，例如：Class.forName("java.lang.String")

### 86、如何通过反射创建对象？ 

1. 通过类对象调用newInstance()方法，例如：String.class.newInstance() 
2. 通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance("Hello");

### 87、如何通过反射获取和设置对象私有字段的值？ 

- 可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。
- 下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如ReflectionUtil.get(dog, "owner.car.engine.id");可以获得dog对象的主人的汽车的引擎的ID号。

```java
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;

/**
 * 反射工具类
 *
 */
public class ReflectionUtil {

  private ReflectionUtil() {
    throw new AssertionError();
  }

  /**
     * 通过反射取对象指定字段(属性)的值
     * @param target 目标对象
     * @param fieldName 字段的名字
     * @throws 如果取不到对象指定字段的值则抛出异常
     * @return 字段的值
     */
  public static Object getValue(Object target, String fieldName) {
    Class<?> clazz = target.getClass();
    String[] fs = fieldName.split("\\.");

    try {
      for(int i = 0; i < fs.length - 1; i++) {
        Field f = clazz.getDeclaredField(fs[i]);
        f.setAccessible(true);
        target = f.get(target);
        clazz = target.getClass();
      }

      Field f = clazz.getDeclaredField(fs[fs.length - 1]);
      f.setAccessible(true);
      return f.get(target);
    }
    catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  /**
     * 通过反射给对象的指定字段赋值
     * @param target 目标对象
     * @param fieldName 字段的名称
     * @param value 值
     */
  public static void setValue(Object target, String fieldName, Object value) {
    Class<?> clazz = target.getClass();
    String[] fs = fieldName.split("\\.");
    try {
      for(int i = 0; i < fs.length - 1; i++) {
        Field f = clazz.getDeclaredField(fs[i]);
        f.setAccessible(true);
        Object val = f.get(target);
        if(val == null) {
          Constructor<?> c = f.getType().getDeclaredConstructor();
          c.setAccessible(true);
          val = c.newInstance();
          f.set(target, val);
        }
        target = val;
        clazz = target.getClass();
      }

      Field f = clazz.getDeclaredField(fs[fs.length - 1]);
      f.setAccessible(true);
      f.set(target, value);
    }
    catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

}
```

### 88、如何通过反射调用对象的方法？ 

```java
import java.lang.reflect.Method;

class MethodInvokeTest {

  public static void main(String[] args) throws Exception {
    String str = "hello";
    Method m = str.getClass().getMethod("toUpperCase");
    System.out.println(m.invoke(str));  // HELLO
  }
}
```

### 89、简述一下面向对象的"六原则一法则"

- 单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是"高内聚"，写代码最终极的原则只有六个字"高内聚、低耦合"，就如同葵花宝典或辟邪剑谱的中心思想就八个字"欲练此功必先自宫"，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。我们都知道一句话叫"因为专注，所以专业"，一个对象如果承担太多的职责，那么注定它什么都做不好。这个世界上任何好的东西都有两个特征，一个是功能单一，好的相机绝对不是电视购物里面卖的那种一个机器有一百多种功能的，它基本上只能照相；另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。） 
- 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。） 
- 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。） 
- 里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。） 
- 接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） 
- 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。） 
- 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。（迪米特法则简单的说就是如何做到"低耦合"，门面模式和调停者模式就是对迪米特法则的践行。对于门面模式可以举一个简单的例子，你去一家公司洽谈业务，你不需要了解这个公司内部是如何运作的，你甚至可以对这个公司一无所知，去的时候只需要找到公司入口处的前台美女，告诉她们你要做什么，她们会找到合适的人跟你接洽，前台的美女就是公司这个系统的门面。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度，如下图所示。迪米特法则用通俗的话来将就是不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。）

### 90、简述一下你了解的设计模式

- 所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。 
- 在GoF的《Design Patterns: Elements of Reusable Object-Oriented Software》中给出了三类（创建型[对类的实例化过程的抽象化]、结构型[描述如何将类或对象结合在一起形成更大的结构]、行为型[对在不同的对象之间划分责任和算法的抽象化]）共23种设计模式，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。 
  面试被问到关于设计模式的知识时，可以拣最常用的作答，例如： 
  - 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 
  - 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。 
  - 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 
  - 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。 
  - 除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections工具类和I/O系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。

### 91、用Java写一个单例类

- 饿汉式单例

```java
public class Singleton {
  private Singleton(){}
  private static Singleton instance = new Singleton();
  public static Singleton getInstance(){
    return instance;
  }
}
```

- 懒汉式单例

```java
public class Singleton {
  private static Singleton instance = null;
  private Singleton() {}
  public static synchronized Singleton getInstance(){
    if (instance == null) instance ＝ new Singleton();
    return instance;
  }
}
```

> **注意**实现一个单例有两点注意事项，①将构造器私有，不允许外界通过构造器创建对象；②通过公开的静态方法向外界返回类的唯一实例。这里有一个问题可以思考：Spring的IoC容器可以为普通的类创建单例，它是怎么做到的呢？

### 92、什么是UML？

UML是统一建模语言（Unified Modeling Language）的缩写，它发表于1997年，综合了当时已经存在的面向对象的建模语言、方法和过程，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。使用UML可以帮助沟通与交流，辅助应用设计和文档的生成，还能够阐释系统的结构和行为。

### 93、UML中有哪些常用的图？ 

UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。 

用例图： 

![这里写图片描述](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-04-10-20150408151744237.png)

类图： 

![这里写图片描述](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-04-10-20150408151843748.png)

时序图： 

![这里写图片描述](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-04-10-20150408153230144-20210410171217894.png)

### 94、用Java写一个冒泡排序

冒泡排序几乎是个程序员都写得出来，但是面试的时候如何写一个逼格高的冒泡排序却不是每个人都能做到，下面提供一个参考代码：

```java
import java.util.Comparator;

/**
 * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换)
 *
 */
public interface Sorter {

   /**
    * 排序
    * @param list 待排序的数组
    */
   public <T extends Comparable<T>> void sort(T[] list);

   /**
    * 排序
    * @param list 待排序的数组
    * @param comp 比较两个对象的比较器
    */
   public <T> void sort(T[] list, Comparator<T> comp);
}
```

```java
import java.util.Comparator;

/**
 * 冒泡排序
 * 
 * @author骆昊
 *
 */
public class BubbleSorter implements Sorter {

  @Override
  public <T extends Comparable<T>> void sort(T[] list) {
    boolean swapped = true;
    for (int i = 1, len = list.length; i < len && swapped; ++i) {
      swapped = false;
      for (int j = 0; j < len - i; ++j) {
        if (list[j].compareTo(list[j + 1]) > 0) {
          T temp = list[j];
          list[j] = list[j + 1];
          list[j + 1] = temp;
          swapped = true;
        }
      }
    }
  }

  @Override
  public <T> void sort(T[] list, Comparator<T> comp) {
    boolean swapped = true;
    for (int i = 1, len = list.length; i < len && swapped; ++i) {
      swapped = false;
      for (int j = 0; j < len - i; ++j) {
        if (comp.compare(list[j], list[j + 1]) > 0) {
          T temp = list[j];
          list[j] = list[j + 1];
          list[j + 1] = temp;
          swapped = true;
        }
      }
    }
  }
}
```

### 95、用Java写一个折半查找

折半查找，也称二分查找、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组已经为空，则表示找不到指定的元素。这种搜索算法每一次比较都使搜索范围缩小一半，其时间复杂度是O(logN)。

```java
import java.util.Comparator;

public class MyUtil {

  public static <T extends Comparable<T>> int binarySearch(T[] x, T key) {
    return binarySearch(x, 0, x.length- 1, key);
  }

  // 使用循环实现的二分查找
  public static <T> int binarySearch(T[] x, T key, Comparator<T> comp) {
    int low = 0;
    int high = x.length - 1;
    while (low <= high) {
      int mid = (low + high) >>> 1;
      int cmp = comp.compare(x[mid], key);
      if (cmp < 0) {
        low= mid + 1;
      }
      else if (cmp > 0) {
        high= mid - 1;
      }
      else {
        return mid;
      }
    }
    return -1;
  }

  // 使用递归实现的二分查找
  private static<T extends Comparable<T>> int binarySearch(T[] x, int low, int high, T key) {
    if(low <= high) {
      int mid = low + ((high -low) >> 1);
      if(key.compareTo(x[mid])== 0) {
        return mid;
      }
      else if(key.compareTo(x[mid])< 0) {
        return binarySearch(x,low, mid - 1, key);
      }
      else {
        return binarySearch(x,mid + 1, high, key);
      }
    }
    return -1;
  }
}
```

> **说明**：上面的代码中给出了折半查找的两个版本，一个用递归实现，一个用循环实现。需要注意的是计算中间位置时不应该使用(high+ low) / 2的方式，因为加法运算可能导致整数越界，这里应该使用以下三种方式之一：low + (high - low) / 2或low + (high – low) >> 1或(low + high) >>> 1（>>>是逻辑右移，是不带符号位的右移）

## JVM

### 说一下垃圾回收机制？

- Java 语言中一个显著的特点就是引入了垃圾回收机制，在编写程序的时候不再需要考虑内存管理。垃圾回收机制可以有效的防止内存泄露，提高内存的内存率。
- 垃圾回收器通常是作为一个单独的低级线程运行，不可预知的情况下对堆中已经死亡的或者长时间没有使用的对象进行清理和回收。
- 回收机制的算法有：标记清除算法、复制算法、标记压缩算法等等。

### 描述一下垃圾回收的流程？

- 首先有三个代，新生代、老年代、永久代。
- 在新生代有三个区域：一个Eden区和两个Survivor区。当一个实例被创建了，首先会被存储Eden 区中。
- 具体过程是这样的：
  - 一个对象实例化时，先去看Eden区有没有足够的空间。
  - 如果有，不进行垃圾回收，对象直接在Eden区存储。
  - 如果Eden区内存已满，会进行一次minor gc。
  - 然后再进行判断Eden区中的内存是否足够。
  - 如果不足，则去看存活区的内存是否足够。
  - 如果内存足够，把Eden区部分活跃对象保存在存活区，然后把对象保存在Eden区。
  - 如果内存不足，查询老年代的内存是否足够。
  - 如果老年代内存足够，将部分存活区的活跃对象存入老年代。然后把Eden区的活跃对象放入存活区，对象依旧保存在Eden区。
  - 如果老年代内存不足，会进行一次full gc，之后老年代会再进行判断 内存是否足够，如果足够 还是那些步骤。
  - 如果不足，会抛出OutOfMemoryError（内存溢出异常）。

### 解释一下JVM的内存模型？

- Java内存模型决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，定义了线程和主内存之间的抽象关系。
- 线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存（并不真实存在），本地内存中存储的是在主内存中共享变量的副本。
- 有两条规定：
  1. 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。
  2. 线程的工作内存是私有的，其他线程无法访问，线程变量值的传递通过主内存来完成。

### GC回收的是堆内存还是栈内存？

主要管理的是堆内存。

### 什么时候新生代会转换为老年代？

- Eden区满时，进行Minor GC时。
- 对象体积太大, 新生代无法容纳时。
- 虚拟机对每个对象定义了一个对象年龄（Age）计数器。当年龄增加到一定的临界值时，就会晋升到老年代中。
- 如果在Survivor区中相同年龄的对象的所有大小之和超过Survivor空间的一半，包括比这个年龄大的对象就都可以直接进入老年代。

### 创建占大内存的对象分配到哪一代？

如果新创建的对象占用内存很大，则直接分配到老年代

### 新生代2个Survivor区的好处？

解决了内存碎片化问题。整个过程中，永远有一个Survivor区是空的，另一个非空的Survivor区是无碎片的。

### 遇到过OOM怎么解决?

我们可以修改虚拟机的参数，获取Heap Dump的文件，后缀名是.hprof。

```
-XX:+HeapDumpOnOutOfMemoryError 
-XX:HeapDumpPath=d:\jvm
```

之后可以使用JDK自带的一个工具jvisualvm来进行排查和定位。

## Java基础

### int和Integer的区别?

- int是基本数据类型，Integer是他的包装类。
- Integer保存的是对象的引用，int保存的变量值。
- Integer默认是null，int默认是0。
- Integer变量必须实例化后才能使用，而int变量不需要。

### Java的基本数据类型和大小？

```
单位：字节
boolean(1) = byte(1) < short(2) = char(2) < int(4) = float(4) < long(8) = double(8)
```

### Java类冲突怎么解决（jar包冲突）?

1. 使用`mvn: dependency tree`查看冲突的jar
2. 然后在pom文件里边  使用`exclusion`标签排除掉这些冲突的jar包

### 接口和抽象类的区别？

1. 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
2. 类可以实现很多个接口，但是只能继承一个抽象类。
3. Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
4. Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。

### JAVA异常

异常的定义

异常就是有异于常态，和正常情况不一样，有错误出现。在java中，阻止当前方法或作用域的情况，称之为异常。

异常的分类

![img](https://img-blog.csdnimg.cn/20190612234942627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phdmFfY3hycw==,size_16,color_FFFFFF,t_70) 

Error：是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时JVM出现问题。通常有Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如说当jvm耗完可用内存时，将出现OutOfMemoryError。此类错误发生时，JVM将终止线程。非代码性错误。因此，当此类错误发生时，应用不应该去处理此类错误。

Exception：：程序本身可以捕获并且可以处理的异常。

运行时异常(不受检异常)：RuntimeException类极其子类表示JVM在运行期间可能出现的错误。编译器不会检查此类异常，并且不要求处理异常，比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。

非运行时异常(受检异常)：Exception中除RuntimeException极其子类之外的异常。编译器会检查此类异常，如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。

### transient

- 我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。
- 然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。
- 总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。

### 浅复制和深复制？怎样实现深复制？

​	在 Java 中，除了**基本数据类型**（元类型）之外，还存在 **类的实例对象** 这个引用数据类型。而一般使用 『 **=** 』号做赋值操作的时候。对于基本数据类型，实际上是拷贝的它的值，但是对于对象而言，其实赋值的只是这个对象的引用，将原对象的引用传递过去，他们实际上还是指向的同一个对象。

而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。

## 多线程

### java 线程的状态

**线程状态图综述**

[![img](https://github.com/Richard-zhang-iOS/Richard-zhang-iOS.github.io/blob/master/res/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%811.jpeg?raw=true)](https://github.com/Richard-zhang-iOS/Richard-zhang-iOS.github.io/blob/master/res/线程状态1.jpeg?raw=true)

1. **新建状态(New)** : 线程对象被创建后，就进入了新建状态。

2. **就绪状态(Runnable)**: 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程

3. **运行状态(Running)** : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。

4. **阻塞状态(Blocked)** : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：

   **等待阻塞** – 通过调用线程的wait()方法，让线程等待某工作的完成。
   **同步阻塞** – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。
   **其他阻塞** – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

5. **死亡状态(Dead)** : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

下面通过一个更具体的运行图来再次解释线程的各个状态

**JAVA中线程状态图实例**

[![img](http://static.oschina.net/uploads/space/2013/0621/174442_0BNr_182175.jpg)](http://static.oschina.net/uploads/space/2013/0621/174442_0BNr_182175.jpg)

详细解释三种**阻塞状态**

**(一). 等待阻塞**：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。

**(二). 同步阻塞：**运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。

**(三). 其他阻塞：**运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

**补充：**

**Synchronized是非公平锁。** Synchronized在进入等待列表时，等待的线程会先尝试自旋获取锁，如果获取不到就进入等待列表，这明显对于已经进入队列的线程是不公平的。

### 多线程会遇到的问题

​	和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。

### 线程池的参数有哪些，拒绝策略

​	•	主要参数有：

- - 线程池核心线程数大小
  - 最大线程数
  - 存储的队列
  - 拒绝策略
  - 空闲线程存活时长

- 当需要任务大于核心线程数时候，就开始把任务往存储任务的队列里，当存储队列满了的话，就开始增加线程池创建的线程数量，如果当线程数量也达到了最大，就开始执行拒绝策略，比如说记录日志，直接丢弃，或者丢弃最老的任务，或者交给提交任务的线程执行。

- 当一个线程完成时，它会从队列中取下一个任务来执行。当一个线程无事可做，且超过一定的时间（keepAliveTime）时，如果当前运行的线程数大于核心线程数，那么这个线程会停掉了。

### 多线程的创建方式

- 继承Thread类
- 实现Runnable接口
- 直接使用线程池

实现Runnable接口这种方式更受欢迎，已经继承别的类的情况下只能实现接口。

### Sleep(0)表示什么？

- 触发操作系统立刻重新进行一次CPU竞争，竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。
- 线程有三个状态，就绪态，运行态，等待态。Sleep(n)方法是让当前线程在n秒内不会参与CPU竞争。线程进入等待队列，n秒之后再次进入就绪队列。
- Sleep(0)是让线程直接进入就绪状态。

### Sleep与Wait区别？

- sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。
- wait是Object类的方法，对象调用wait方法导致本线程放弃对象锁，进入等待池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入锁池准备抢夺对象锁。

### Thread.Join方法

- Thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。
- 比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。

### Lock锁与synchronized的区别？

- Lock能完成synchronized的所有功能。

- Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。

- Lock可以知道是不是已经获取到锁，而synchronized无法知道。

- ​	synchronized是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。

  ​	Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。

### synchronize底层是怎么实现的

​	synchronized的底层原理是跟monitor有关，也就是视图器锁，每个对象都有一个关联的monitor，当Synchronize获得monitor对象的所有权后会进行两个指令：加锁指令跟减锁指令。

- monitor里面有个计数器，初始值是从0开始的。如果一个线程想要获取monitor的所有权，就看看它的计数器是不是0，如果是0的话，那么就说明没人获取锁，那么它就可以获取锁了，然后将计数器+1，也就是执行monitorenter加锁指令；monitorexit减锁指令是跟在程序执行结束和异常里的，如果不是0的话，就会陷入一个堵塞等待的过程，直到为0等待结束。
- 

### 线程不安全的问题在多线程怎么解决？

可以使用synchronized、lock、volatile来实现同步。

### CAS是一种什么样的同步机制？

-  CAS，是Compare and Swap的简称，在这个机制中有三个核心的参数：
- 主内存中存放的共享变量的值：V（一般情况下这个V是内存的地址值，通过这个地址可以获得内存中的值）
- 工作内存中共享变量的副本值，也叫预期值：A
- 需要将共享变量更新到的最新值：B

### volatile的底层如何实现，怎么就能保住可见性了？

​	volatile关键字是用来保证有序性和可见性的。这跟Java内存模型有关。比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高CPU的执行效率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有happens-before规则，其中有条就是volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先Java内存模型分为，主内存，工作内存。比如线程A从主内存把变量从主内存读到了自己的工作内存中，做了加1的操作，但是此时没有将i的最新值刷新会主内存中，线程B此时读到的还是i的旧值。加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。Lock指令对Intel平台的CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多核之间数据不一致性问题。

volatile是轻量级的synchronized，比它的执行成本更低,因为它不会引起线程的上下文切换，它保证了共享变量的`可见性`，`可见性`的意思是当一个线程修改一个变量时，另外一个线程能读到这个修改的值。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。还有就是它通过添加内存屏障的方式禁止指令的重排序。

### 如何实现主线程等待子线程执行完后再继续执行？

1. 我们可以使用join方法，在主线程内部调用子线程.join方法。
2. CountDownLatch实现
   - 这是一个属于JUC的工具类，从1.5开始。主要用到方法是countDown() 和 await()。
   - await()方法阻塞当前线程，直到计数器等于0。
   - countDown()方法将计数器减一。
   - 思路：我们可以在创建CountDownLatch对象，然后将此对象通过构造参数传递给子线程，在开启子线程后主线程调用await()方法阻塞主线程，子线程调用countDown()方法计数器减一。

### 简单说一下synchronize

synchronize是java中的关键字，可以用来修饰实例方法、静态方法、还有代码块；主要有三种作用：可以确保原子性、可见性、有序性。

- 原子性就是能够保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等该线程处理完数据后才能进行。
- 可见性就是当一个线程在修改共享数据时，其他线程能够看到。
- 有序性就是，被synchronize锁住后的线程相当于单线程，在单线程环境jvm的重排序是不会改变程序运行结果的，可以防止重排序对多线程的影响。

### synchronried的底层原理

- synchronized的底层原理是跟monitor有关，也就是视图器锁，每个对象都有一个关联的monitor，当Synchronize获得monitor对象的所有权后会进行两个指令：加锁指令跟减锁指令。
- monitor里面有个计数器，初始值是从0开始的。如果一个线程想要获取monitor的所有权，就看看它的计数器是不是0，如果是0的话，那么就说明没人获取锁，那么它就可以获取锁了，然后将计数器+1，也就是执行monitorenter加锁指令；monitorexit减锁指令是跟在程序执行结束和异常里的，如果不是0的话，就会陷入一个堵塞等待的过程，直到为0等待结束。

### 有几种线程池？并且详细描述一下线程池的实现过程

1. newFixedThreadPool创建一个指定大小的线程池。每当提交一个任务就创建一个线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到等待队列中。

2. newCachedThreadPool创建一个可缓存的线程池。这种类型的线程池特点是：

3. - 工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。
   - 如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。

4. newSingleThreadExecutor创建一个单线程的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。

5. newScheduleThreadPool创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。(这种线程池原理暂还没完全了解透彻)

### 线程池的主要参数和处理流程

- 主要参数有：
  - 线程池核心线程数大小
  - 最大线程数
  - 存储的队列
  - 拒绝策略
  - 空闲线程存活时长
- 当需要任务大于核心线程数时候，就开始把任务往存储任务的队列里，当存储队列满了的话，就开始增加线程池创建的线程数量，如果当线程数量也达到了最大，就开始执行拒绝策略，比如说记录日志，直接丢弃，或者丢弃最老的任务，或者交给提交任务的线程执行。
- 当一个线程完成时，它会从队列中取下一个任务来执行。当一个线程无事可做，且超过一定的时间（keepAliveTime）时，如果当前运行的线程数大于核心线程数，那么这个线程会停掉了。

### 线程的6种状态




## 集合

### List，Set，Map的区别？

- `List`是一个有序的集合，里面可以存储重复的元素。
- `Set`是一个不能存储相同元素的集合。
- `Map`是一个通过键值对的方式存储元素的，键不能重复。

### HashMap具体如何实现的？

- HashMap底层是基于数组+链表实现的，通过添加键的hashcode与上数组的长度来得到这个元素在数组中的位置，如果这个位置没有数据，那么就把这个数据当做第一个节点。如果这个位置有了链表，那么在JDK1.7的时候使用的是头插法，在JDK1.8的时候使用尾插法。
- HashMap在JDK1.8的版本中引入了红黑树结构做优化，当链表元素个数大于等于8时，链表转换成树结构；链表元素个数小于等于6时，树结构还原成链表。
- Hashmap基于数组实现的，通过对key的hashcode & 数组的长度得到在数组中位置，如当前数组有元素，则数组当前元素next指向要插入的元素，这样来解决hash冲突的，形成了拉链式的结构。put时在多线程情况下，会形成环从而导致死循环。数组长度一般是2n，从0开始编号，所以hashcode & （2n-1），（2n-1）每一位都是1，这样会让散列均匀。需要注意的是，HashMap在JDK1.8的版本中引入了红黑树结构做优化，当链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。

### JDK1.8的时候为什么选择8和6作为转换点？

- 因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，显然树的效率更高一些。
- 链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是树和链表相互转换的时间也不会太短。还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。

### HashMap的扩容机制？

- HashMap底层是数组，在第一次put的时候会初始化，发生第一次扩容到16。它有一个负载因子是0.75，下一次扩容的时候就是当前数组大小*0.75。扩大容量为原来的2倍。

### concurrentmap为什么是线程安全的？

- ConcurrentHashMap大部分的逻辑代码和HashMap是一样的，主要通过synchronized和来保证节点在插入扩容的时候是线程安全的。
- ConcurrentHashMap的扩容核心逻辑主要是给不同的线程分配不同的数组下标，然后每个线程处理各自下表区间的节点。同时处理节点复用了hashMap的逻辑，通过位运行，可以知道节点扩容后的位置，要么在原位置，要么在原位置+oldlength位置,最后直接赋值即可。

### ConcurrentHashMap的原理？

ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。

在ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。 由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。

Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。

ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成的。HashEntry封装的就是每一个键值对。每一个Segment元素存储的是HashEntry数组 + 链表。Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，Segment本身可以充当锁的角色。ConcurrentHashMap在put的时候需要进行两次hash，第一次需要确定在Segment数组的位置，第二次hash是确定在HashEntry数组中的位置。同样在get的时候也需要经过两次hash。

## 设计模式

### DCL为什么要用volatile关键字？

先看一下DCL(双重检查锁模式)的示例代码：

```java
public class Singleton {
  //Singleton对象属性,加上volatile关键字是为了防止指定重排序,要知道singleton = new Singleton()拆分成cpu指令的话，有足足3个步骤
  private volatile static Singleton singleton;

  //对外提供的获取实例的方法
  public static Singleton getInstance() {
    if (singleton == null) {
      synchronized (Singleton.class) {
        if (singleton == null) {
          singleton = new Singleton();
        }
      }
    }
    return singleton;
  }
}
```

从代码里可以看到，做了两重的singleton == null的判断，中间还用了synchronized关键字，第一个singleton == null的判断是为了避免线程串行化，如果为空，就进入synchronized代码块中，获取锁后再操作，如果不为空，直接就返回singleton对象了，无需再进行锁竞争和等待了。而第二个singleton == null的判断是为了防止有多个线程同时跳过第一个singleton == null的判断，比如线程一先获取到锁，进入同步代码块中，发现singleton实例还是null，就会做new操作，然后退出同步代码块并释放锁，这时一起跳过第一层singleton == null的判断的还有线程二，这时线程一释放了锁，线程二就会获取到锁，如果没有第二层的singleton == null这个判断挡着，那就会再创建一个singleton实例，就违反了单例的约束了。

那为什么要加volatile关键字呢

synchronized在一定程度上可以保证有序性博主说的是一方面还有就是在 进入synchronized代码块会先添加一个 acquire barrier 在最后添加一个release barrier 保证同步代码块中的代码不能和同步代码块外面的代码进行指令重排，在其内部还是会发生指令重排但基本不会影响结果

了解下singleton = new Singleton()这段代码其实不是原子性的操作，它至少分为以下3个步骤：

给singleton对象分配内存空间
调用Singleton类的构造函数等，初始化singleton对象
将singleton对象指向分配的内存空间，这步一旦执行了，那singleton对象就不等于null了
这里还需要知道一点，就是有时候JVM会为了优化，而做指令重排序的操作，这里的指令，指的是CPU层面的。

正常情况下，singleton = new Singleton()的步骤是按照1->2->3这种步骤进行的，但是一旦JVM做了指令重排序，那么顺序很可能编程1->3->2，如果是这种顺序，可以发现，在3步骤执行完singleton对象就不等于null，但是它其实还没做步骤二的初始化工作，但是另一个线程进来时发现，singleton不等于null了，就这样把半成品的实例返回去，调用是会报错的。

可以画个出现指令重排序的图加深下理解：

<img src="https://img-blog.csdnimg.cn/20200425180018774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODEwNjMyMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;" />

出现了指令重排序后，按照上图的流程逻辑，很可能会返回还没完成初始化的singleton对象，导致使用这个对象时报错，而volatile关键字的作用之一就是禁止指令重排序。

**总结**

DCL使用volatile关键字，是为了禁止指令重排序，避免返回还没完成初始化的singleton对象，导致调用报错，也保证了线程的安全。

## SSM

### Springmvc的执行流程


![img](https://upload-images.jianshu.io/upload_images/5220087-3c0f59d3c39a12dd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1002)

2. 用户发送请求至前端控制器DispatcherServlet

2. DispatcherServlet收到请求调用处理器映射器HandlerMapping

3. 处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet

4. DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作

5. 执行处理器Handler(Controller，也叫页面控制器)

6. Handler执行完成返回ModelAndView

7. HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet

8. DispatcherServlet将ModelAndView传给ViewReslover视图解析器

9. ViewReslover解析后返回具体View

10. DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）

11. DispatcherServlet响应用户。

    

### SpringMVC的常用注解

- `@Component`： 会被spring容器识别，并转为bean。
- `@Repository`： 对Dao实现类进行注解。
- `@Service`： 对业务逻辑层进行注解。
- `@Controller`： 表明这个类是Spring MVC里的Controller，将其声明为Spring的一个Bean，Dispatch Servlet会自动扫描注解了此注解的类，并将Web请求映射到注解了@RequestMapping的方法上。
- `@RequestMapping`： 用来映射Web请求（访问路径和参数）、处理类和方法的。它可以注解在类和方法上。注解在方法上的@RequestMapping路径会继承注解在类上的路径。
- `@RequestBody`： 可以将整个返回结果以某种格式返回，如json或xml格式。
- `@PathVariable`： 用来接收路径参数，如/news/001,可接收001作为参数，此注解放置在参数前。
- `@RequestParam`：用于获取传入参数的值。
- `@RestController`：是一个组合注解，组合了@Controller和@ResponseBody，意味着当只开发一个和页面交互数据的控制的时候，需要使用此注解。

### Spring MVC怎么将数据存储到session中？

我一般都是使用Servlet-Api，在处理请求的方法参数列表中，添加一个HTTPSession对象，之后SpringMVC就可以自动注入进来了。在方法体中调用session.setAttribute就可以了。

### 过滤器和拦截器的区别？

1. 拦截器是基于java的反射机制的，而过滤器是基于函数回调。
2. 拦截器不依赖servlet容器，过滤器依赖servlet容器。
3. 拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。
4. 拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。
5. 在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。
6. 拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。

### 请简要说明一下IOC和AOP是什么？

- 依赖注入的三种方式：
  - 接口注入
  - Construct注入
  - Setter注入
- 控制反转与依赖注入是同一个概念，引入IOC的目的：
  - 脱开、降低类之间的耦合
  - 倡导面向接口编程、实施依赖倒换原则
  - 提高系统可插入、可测试、可修改等特性。
- 具体做法：
  - 将bean之间的依赖关系尽可能地抓换为关联关系
  - 将对具体类的关联尽可能地转换为对Java interface的关联，而不是与具体的服务对象相关联
  - Bean实例具体关联相关Java interface的哪个实现类的实例，在配置信息的元数据中描述
  - 由IoC组件（或称容器）根据配置信息，实例化具体bean类、将bean之间的依赖关系注入进来。
- AOP是面向切面编程，可以说是面向对象编程的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，但是这些都是纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，但是这与核心的业务代码确没有关系。
- AOP利用"横切"的技术，把那些与业务无关，但是却为业务模块所共同调用的逻辑部分封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并提高了系统的维护性。
- AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如日志还有事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。

### Spring拦截器的执行顺序

Springmvc的拦截器实现HandlerInterceptor接口后，会有三个抽象方法需要实现，分别为方法前执行preHandle，方法后postHandle，页面渲染后afterCompletion。

1. 当俩个拦截器都实现放行操作时，顺序为preHandle 1，preHandle 2，postHandle 2，postHandle 1，afterCompletion 2，afterCompletion 1
2. 当第一个拦截器preHandle返回false，也就是对其进行拦截时，第二个拦截器是完全不执行的，第一个拦截器只执行preHandle部分。
3. 当第一个拦截器preHandle返回true，第二个拦截器preHandle返回false，顺序为preHandle 1，preHandle 2 ，afterCompletion 1

总结：

```
preHandle 按拦截器定义顺序调用
postHandler 按拦截器定义逆序调用
afterCompletion 按拦截器定义逆序调用
postHandler 在拦截器链内所有拦截器返成功调用
afterCompletion 只有preHandle返回true才调用
```

### Spring 核心功能

- spring 框架中核心组件有三个：Core、Context 和 Beans。其中最核心的组件就是Beans, Spring提供的最核心的功能就是Bean Factory。
- Spring 解决了的最核心的问题就是把对象之间的依赖关系转为用配置文件来管理，也就是Spring的依赖注入机制。这个注入机制是在Ioc 容器中进行管理的。

### @Autowired 和@Resource区别是什么？

- 共同点：两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。
- @Autowired注解是按照类型（byType）装配依赖对象。当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。
- @Resource默认按照ByName自动注入。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。

### SpringBootApplication是怎么加载的？

### SpringBoot配置多套环境

可以定义多个配置文件，比如开发，测试，上线。 我们可以在SpringBoot中定义多个application.properties。 我一般都用-名字做区别，比如：

```
application-dev.properties
application-test.properties
application-prod.properties
```

之后我们需要在默认的配置文件里面声明一下激活哪些配置文件。

```
spring.profiles.active=test
```

使用java -jar 方式启动的时候也可以添加参数指定配置文件启动

```
java -jar mm.jar --spring.profiles.active=dev
```

### SpringBoot的启动方式

1. 运行带有main方法类。
3. 通过spring-boot-plugin的方式，这种方式需要安装Maven的插件，然后通过命令`mvn spring-boot:run`启动项目。
3. 前台启动命令：`java -jar XXX.jar`
4. 后台启动命令：`java -jar xxx.jar &`，后台启动同时也可以制定控制台的输出标准，将日志输出到制定文件
5. 使用Docker的方式启动SpringBoot应用，需要将jar制作成docker镜像。

### MyBatis核心类

### Mybatis中dao层和xml配置怎么建立关系的

### Mybatis常用标签

### `#{ }` 和`${ }`的区别？

- `#{}`：这种方式是使用的预编译的方式，一个#{}就是一个占位符。相当于jdbc的占位符PrepareStatement。设置值的时候会加上引号。
- `${}`：这种方式是直接拼接的方式，不对数值做预编译。存在sql注入的现象。设置值的时候不会加上引号。

### MyBatis的二级缓存

- MyBatis一级缓存最大的共享范围就是一个SqlSession内部，那么如果多个SqlSession需要共享缓存，则需要开启二级缓存，开启二级缓存后，会使用CachingExecutor装饰Executor进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询。
- 当二级缓存开启后，同一个命名空间(namespace) 所有的操作语句，都影响着一个共同的 cache，也就是二级缓存被多个 SqlSession 共享，是一个全局的变量。当开启缓存后，数据的查询执行的流程就是 二级缓存 -> 一级缓存 -> 数据库。默认二级缓存不开启，需要在MyBatis的全局配置文件中进行配置。

### druid连接池优点

​	1.强大的监控特性，通过Druid提供的监控功能，可以清楚知道连接池和SQL的工作情况。

​	a. 监控SQL的执行时间、ResultSet持有时间、返回行数、更新行数、错误次数、错误堆栈信息;

​	b. SQL执行的耗时区间分布。什么是耗时区间分布呢？比如说，某个SQL执行了1000次，其中0~1毫秒区间50次，1~10毫秒800次，10~100毫秒100次，100~1000毫秒30次，1~10秒15次，10秒以上5次。通过耗时区间分布，能够非常清楚知道SQL的执行耗时情况

​	c. 监控连接池的物理连接创建和销毁次数、逻辑连接的申请和关闭次数、非空等待次数、PSCache命中率等。

​	2.其次，方便扩展。Druid提供了Filter-Chain模式的扩展API，可以自己编写Filter拦截JDBC中的任何方法，可以在上面做任何事情，比如说性能监控、SQL审计、用户名密码加密、日志等等。

​	3.Druid集合了开源和商业数据库连接池的优秀特性，并结合阿里巴巴大规模苛刻生产环境的使用经验进行优化

### Spring ApplicationContext 容器

*Application Context* 是 spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。 另外，它增加了企业所需要的功能，比如，从属性文件从解析文本信息和将事件传递给所指定的监听器。这个容器在 *org.springframework.context.ApplicationContext interface* 接口中定义。

*ApplicationContext* 包含 *BeanFactory* 所有的功能，一般情况下，相对于 *BeanFactory*，*ApplicationContext* 会被推荐使用。*BeanFactory* 仍然可以在轻量级应用中使用，比如移动设备或者基于 applet 的应用程序。

最常被使用的 ApplicationContext 接口实现：

- **FileSystemXmlApplicationContext**：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径
- **ClassPathXmlApplicationContext**：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。
- **WebXmlApplicationContext**：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。

我们已经在 *Spring Hello World Example*章节中看到过 ClassPathXmlApplicationContext 容器，并且，在基于 spring 的 web 应用程序这个独立的章节中，我们讨论了很多关于 XmlWebApplicationContext。所以，接下来，让我们看一个关于 FileSystemXmlApplicationContext 的例子。

假设我们已经安装 Eclipse IDE，按照下面的步骤，我们可以创建一个 Spring 应用程序。

| 步骤 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| 1    | 创建一个名为 *SpringExample* 的工程， 在 **src** 下新建一个名为 *com.tutorialspoint* 的文件夹**src** |
| 2    | 点击右键，选择 *Add External JARs* 选项，导入 Spring 的库文件，正如我们在 *Spring Hello World Example* 章节中提到的导入方式。 |
| 3    | 在 *com.tutorialspoint* 文件夹下创建 *HelloWorld.java* 和 *MainApp.java* 两个类文件。 |
| 4    | 文件夹下创建 Bean 的配置文件 *Beans.xml*。                   |
| 5    | 最后的步骤是编辑所有 JAVA 文件的内容和 Bean 的配置文件,按照以前我们讲的那样去运行应用程序。 |

下面是文件 **HelloWorld.java** 的内容：

```
package com.tutorialspoint;
public class HelloWorld {
   private String message;
   public void setMessage(String message){
      this.message  = message;
   }
   public void getMessage(){
      System.out.println("Your Message : " + message);
   }
}
```

下面是文件 **MainApp.java** 的内容：

```
package com.tutorialspoint;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;
public class MainApp {
   public static void main(String[] args) {
      ApplicationContext context = new FileSystemXmlApplicationContext
            ("C:/Users/ZARA/workspace/HelloSpring/src/Beans.xml");
      HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
      obj.getMessage();
   }
}
```

在主程序当中，我们需要注意以下两点：

- 第一步生成工厂对象。加载完指定路径下 bean 配置文件后，利用框架提供的 **FileSystemXmlApplicationContext** API 去生成工厂 bean。**FileSystemXmlApplicationContext**负责生成和初始化所有的对象，比如，所有在 XML bean 配置文件中的 bean。
- 第二步利用第一步生成的上下文中的 **getBean()** 方法得到所需要的 bean。 这个方法通过配置文件中的 bean ID 来返回一个真正的对象。一旦得到这个对象，就可以利用这个对象来调用任何方法。

下面是配置文件 **Beans.xml** 中的内容：

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <bean id="helloWorld" class="com.tutorialspoint.HelloWorld">
       <property name="message" value="Hello World!"/>
   </bean>

</beans>
```

如果你已经完成上面的内容，接下来，让我们运行这个应用程序。如果程序没有错误，你将从控制台看到以下信息：

```
Your Message : Hello World!
```

### Spring Security 原理

**过滤器**

- Spring Security 基本都是通过过滤器来完成配置的身份认证、权限认证以及登出。
- Spring Security 在 Servlet 的过滤链（filter chain）中注册了一个过滤器 `FilterChainProxy`，它会把请求代理到 Spring Security 自己维护的多个过滤链，每个过滤链会匹配一些 URL，如果匹配则执行对应的过滤器。过滤链是有顺序的，一个请求只会执行第一条匹配的过滤链。Spring Security 的配置本质上就是新增、删除、修改过滤器。
- 默认情况下系统帮我们注入的这 15 个过滤器，分别对应配置不同的需求。接下来我们重点是分析下 `UsernamePasswordAuthenticationFilter` 这个过滤器，他是用来使用用户名和密码登录认证的过滤器，但是很多情况下我们的登录不止是简单的用户名和密码，又可能是用到第三方授权登录，这个时候我们就需要使用自定义过滤器，当然这里不做详细说明，只是说下自定义过滤器怎么注入。

```java
@Override
protected void configure(HttpSecurity http) throws Exception {

  http.addFilterAfter(...);
  ...
}
```

**身份认证流程**

在开始身份认证流程之前我们需要了解下几个基本概念

**SecurityContextHolder**

`SecurityContextHolder` 存储 `SecurityContext` 对象。`SecurityContextHolder` 是一个存储代理，有三种存储模式分别是：

- MODE_THREADLOCAL：SecurityContext 存储在线程中。
- MODE_INHERITABLETHREADLOCAL：`SecurityContext` 存储在线程中，但子线程可以获取到父线程中的 `SecurityContext`。
- MODE_GLOBAL：`SecurityContext` 在所有线程中都相同。

`SecurityContextHolder` 默认使用 MODE_THREADLOCAL 模式，`SecurityContext` 存储在当前线程中。调用 `SecurityContextHolder` 时不需要显示的参数传递，在当前线程中可以直接获取到 `SecurityContextHolder` 对象。

```java
//获取当前线程里面认证的对象
SecurityContext context = SecurityContextHolder.getContext();
Authentication authentication = context.getAuthentication();

//保存认证对象 (一般用于自定义认证成功保存认证对象)
SecurityContextHolder.getContext().setAuthentication(authResult);

//清空认证对象 (一般用于自定义登出清空认证对象)
SecurityContextHolder.clearContext();
```

**2.Authentication**

`Authentication` 即验证，表明当前用户是谁。什么是验证，比如一组用户名和密码就是验证，当然错误的用户名和密码也是验证，只不过 Spring Security 会校验失败。

`Authentication` 接口

```java
public interface Authentication extends Principal, Serializable {
  //获取用户权限，一般情况下获取到的是用户的角色信息
  Collection<? extends GrantedAuthority> getAuthorities();
  //获取证明用户认证的信息，通常情况下获取到的是密码等信息，不过登录成功就会被移除
  Object getCredentials();
  //获取用户的额外信息，比如 IP 地址、经纬度等
  Object getDetails();
  //获取用户身份信息，在未认证的情况下获取到的是用户名，在已认证的情况下获取到的是 UserDetails (暂时理解为，当前应用用户对象的扩展)
  Object getPrincipal();
  //获取当前 Authentication 是否已认证
  boolean isAuthenticated();
  //设置当前 Authentication 是否已认证
  void setAuthenticated(boolean isAuthenticated);
}
```

**3.AuthenticationManager ProviderManager AuthenticationProvider**

其实这三者很好区分，`AuthenticationManager` 主要就是为了完成身份认证流程，`ProviderManager`是 `AuthenticationManager` 接口的具体实现类，`ProviderManager` 里面有个记录 `AuthenticationProvider` 对象的集合属性 `providers`，`AuthenticationProvider` 接口类里有两个方法

```java
public interface AuthenticationProvider {
  //实现具体的身份认证逻辑，认证失败抛出对应的异常
  Authentication authenticate(Authentication authentication)
    throws AuthenticationException;
  //该认证类是否支持该 Authentication 的认证
  boolean supports(Class<?> authentication);
}
```

接下来就是遍历 `ProviderManager` 里面的 `providers` 集合，找到和合适的 `AuthenticationProvider`完成身份认证。

**4.UserDetailsService UserDetails**

在 `UserDetailsService` 接口中只有一个简单的方法

```java
public interface UserDetailsService {
  //根据用户名查到对应的 UserDetails 对象
  UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
```

**5.流程**

对于上面概念有什么不明白的地方，在们在接下来的流程中慢慢分析

在运行到 `UsernamePasswordAuthenticationFilter` 过滤器的时候首先是进入其父类 `AbstractAuthenticationProcessingFilter` 的 `doFilter()` 方法中

```java
public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
  throws IOException, ServletException {
  ...
    //首先配对是不是配置的身份认证的URI,是则执行下面的认证,不是则跳过
    if (!requiresAuthentication(request, response)) {
      chain.doFilter(request, response);

      return;
    }
  ...
    Authentication authResult;

  try {
    //关键方法, 实现认证逻辑并返回 Authentication, 由其子类 UsernamePasswordAuthenticationFilter 实现, 由下面 5.3 详解
    authResult = attemptAuthentication(request, response);
    if (authResult == null) {
      // return immediately as subclass has indicated that it hasn't completed
      // authentication
      return;
    }
    sessionStrategy.onAuthentication(authResult, request, response);
  }
  catch (InternalAuthenticationServiceException failed) {
    //认证失败调用...由下面 5.1 详解
    unsuccessfulAuthentication(request, response, failed);

    return;
  }
  catch (AuthenticationException failed) {
    //认证失败调用...由下面 5.1 详解
    unsuccessfulAuthentication(request, response, failed);

    return;
  }

  // Authentication success
  if (continueChainBeforeSuccessfulAuthentication) {
    chain.doFilter(request, response);
  }
  //认证成功调用...由下面 5.2 详解
  successfulAuthentication(request, response, chain, authResult);
}
```

**5.1 认证失败处理逻辑**

```java
protected void unsuccessfulAuthentication(HttpServletRequest request,
                                          HttpServletResponse response, AuthenticationException failed)
  throws IOException, ServletException {
  SecurityContextHolder.clearContext();
  ...
    rememberMeServices.loginFail(request, response);
  //该 handler 处理失败界面跳转和响应逻辑
  failureHandler.onAuthenticationFailure(request, response, failed);
}
```

这里默认配置的失败处理 handler 是 `SimpleUrlAuthenticationFailureHandler`，**可自定义**。

```java
public class SimpleUrlAuthenticationFailureHandler implements
        AuthenticationFailureHandler {
    ...

    public void onAuthenticationFailure(HttpServletRequest request,
            HttpServletResponse response, AuthenticationException exception)
            throws IOException, ServletException {
        //没有配置失败跳转的URL则直接响应错误
        if (defaultFailureUrl == null) {
            logger.debug("No failure URL set, sending 401 Unauthorized error");

            response.sendError(HttpStatus.UNAUTHORIZED.value(),
                HttpStatus.UNAUTHORIZED.getReasonPhrase());
        }
        else {
            //否则
            //缓存异常
            saveException(request, exception);
            //根据配置的异常页面是重定向还是转发进行不同方式跳转
            if (forwardToDestination) {
                logger.debug("Forwarding to " + defaultFailureUrl);

                request.getRequestDispatcher(defaultFailureUrl)
                        .forward(request, response);
            }
            else {
                logger.debug("Redirecting to " + defaultFailureUrl);
                redirectStrategy.sendRedirect(request, response, defaultFailureUrl);
            }
        }
    }
    //缓存异常,转发则保存在request里面,重定向则保存在session里面
    protected final void saveException(HttpServletRequest request,
            AuthenticationException exception) {
        if (forwardToDestination) {
            request.setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);
        }
        else {
            HttpSession session = request.getSession(false);

            if (session != null || allowSessionCreation) {
                request.getSession().setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION,
                        exception);
            }
        }
    }
}
```

**这里做下小拓展：用系统的错误处理handler，指定认证失败跳转的URL，在MVC里面对应的URL方法里面可以通过key从`request`或`session`里面拿到错误信息，反馈给前端**

**5.2 认证成功处理逻辑**

```java
protected void successfulAuthentication(HttpServletRequest request,
                                        HttpServletResponse response, FilterChain chain, Authentication authResult)
  throws IOException, ServletException {
  ...
    //这里要注意很重要，将认证完成返回的 Authentication 保存到线程对应的 `SecurityContext` 中
    SecurityContextHolder.getContext().setAuthentication(authResult);

  rememberMeServices.loginSuccess(request, response, authResult);

  // Fire event
  if (this.eventPublisher != null) {
    eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(
      authResult, this.getClass()));
  }
  //该 handler 就是为了完成页面跳转
  successHandler.onAuthenticationSuccess(request, response, authResult);
}
```

这里默认配置的成功处理 handler 是 `SavedRequestAwareAuthenticationSuccessHandler`，里面的代码就不做具体展开了，反正是跳转到指定的认证成功之后的界面，**可自定义**。

**5.3 身份认证详情**

```java
public class UsernamePasswordAuthenticationFilter extends
  AbstractAuthenticationProcessingFilter {
  ...
    public static final String SPRING_SECURITY_FORM_USERNAME_KEY = "username";
  public static final String SPRING_SECURITY_FORM_PASSWORD_KEY = "password";

  private String usernameParameter = SPRING_SECURITY_FORM_USERNAME_KEY;
  private String passwordParameter = SPRING_SECURITY_FORM_PASSWORD_KEY;
  private boolean postOnly = true;

  ...
    //开始身份认证逻辑
    public Authentication attemptAuthentication(HttpServletRequest request,
                                                HttpServletResponse response) throws AuthenticationException {
    if (postOnly && !request.getMethod().equals("POST")) {
      throw new AuthenticationServiceException(
        "Authentication method not supported: " + request.getMethod());
    }

    String username = obtainUsername(request);
    String password = obtainPassword(request);

    if (username == null) {
      username = "";
    }

    if (password == null) {
      password = "";
    }

    username = username.trim();
    //先用前端提交过来的 username 和 password 封装一个简易的 AuthenticationToken
    UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(
      username, password);

    // Allow subclasses to set the "details" property
    setDetails(request, authRequest);
    //具体的认证逻辑还是交给 AuthenticationManager 对象的 authenticate(..) 方法完成,接着往下看
    return this.getAuthenticationManager().authenticate(authRequest);
  }
}
```

由源码断点跟踪得知，最终解析是由 `AuthenticationManager` 接口实现类 `ProviderManager` 来完成

```java
public class ProviderManager implements AuthenticationManager, MessageSourceAware,
InitializingBean {
  ...
    private List<AuthenticationProvider> providers = Collections.emptyList();
  ...

    public Authentication authenticate(Authentication authentication)
    throws AuthenticationException {
    ....
      //遍历所有的 AuthenticationProvider, 找到合适的完成身份验证
      for (AuthenticationProvider provider : getProviders()) {
        if (!provider.supports(toTest)) {
          continue;
        }
        ...
          try {
            //进行具体的身份验证逻辑, 这里使用到的是 DaoAuthenticationProvider, 具体逻辑记着往下看
            result = provider.authenticate(authentication);

            if (result != null) {
              copyDetails(authentication, result);
              break;
            }
          }
        catch 
          ...
      }
    ...
      throw lastException;
  }
}
```

`DaoAuthenticationProvider` 继承自 `AbstractUserDetailsAuthenticationProvider` 实现了 `AuthenticationProvider` 接口

```java
public abstract class AbstractUserDetailsAuthenticationProvider implements
  AuthenticationProvider, InitializingBean, MessageSourceAware {
  ...
    private UserDetailsChecker preAuthenticationChecks = new DefaultPreAuthenticationChecks();
  private UserDetailsChecker postAuthenticationChecks = new DefaultPostAuthenticationChecks();
  ...

    public Authentication authenticate(Authentication authentication)
    throws AuthenticationException {
    ...
      // 获得提交过来的用户名
      String username = (authentication.getPrincipal() == null) ? "NONE_PROVIDED"
      : authentication.getName();
    //根据用户名从缓存中查找 UserDetails
    boolean cacheWasUsed = true;
    UserDetails user = this.userCache.getUserFromCache(username);

    if (user == null) {
      cacheWasUsed = false;

      try {
        //缓存中没有则通过 retrieveUser(..) 方法查找 (看下面 DaoAuthenticationProvider 的实现)
        user = retrieveUser(username,
                            (UsernamePasswordAuthenticationToken) authentication);
      }
      catch 
        ...
    }

    try {
      //比对前的检查,例如账户以一些状态信息(是否锁定, 过期...)
      preAuthenticationChecks.check(user);
      //子类实现比对规则 (看下面 DaoAuthenticationProvider 的实现)
      additionalAuthenticationChecks(user,
                                     (UsernamePasswordAuthenticationToken) authentication);
    }
    catch (AuthenticationException exception) {
      if (cacheWasUsed) {
        // There was a problem, so try again after checking
        // we're using latest data (i.e. not from the cache)
        cacheWasUsed = false;
        user = retrieveUser(username,
                            (UsernamePasswordAuthenticationToken) authentication);
        preAuthenticationChecks.check(user);
        additionalAuthenticationChecks(user,
                                       (UsernamePasswordAuthenticationToken) authentication);
      }
      else {
        throw exception;
      }
    }

    postAuthenticationChecks.check(user);

    if (!cacheWasUsed) {
      this.userCache.putUserInCache(user);
    }

    Object principalToReturn = user;

    if (forcePrincipalAsString) {
      principalToReturn = user.getUsername();
    }
    //根据最终user的一些信息重新生成具体详细的 Authentication 对象并返回 
    return createSuccessAuthentication(principalToReturn, authentication, user);
  }
  //具体生成还是看子类实现
  protected Authentication createSuccessAuthentication(Object principal,
                                                       Authentication authentication, UserDetails user) {
    // Ensure we return the original credentials the user supplied,
    // so subsequent attempts are successful even with encoded passwords.
    // Also ensure we return the original getDetails(), so that future
    // authentication events after cache expiry contain the details
    UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken(
      principal, authentication.getCredentials(),
      authoritiesMapper.mapAuthorities(user.getAuthorities()));
    result.setDetails(authentication.getDetails());

    return result;
  }
}
```

接下来我们来看下 `DaoAuthenticationProvider` 里面的三个重要的方法，比对方式、获取需要比对的 `UserDetails` 对象以及生产最终返回 `Authentication` 的方法。

```java
public class DaoAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider {
  ...
    //密码比对
    @SuppressWarnings("deprecation")
    protected void additionalAuthenticationChecks(UserDetails userDetails,
                                                  UsernamePasswordAuthenticationToken authentication)
    throws AuthenticationException {
    if (authentication.getCredentials() == null) {
      logger.debug("Authentication failed: no credentials provided");

      throw new BadCredentialsException(messages.getMessage(
        "AbstractUserDetailsAuthenticationProvider.badCredentials",
        "Bad credentials"));
    }

    String presentedPassword = authentication.getCredentials().toString();
    //通过 PasswordEncoder 进行密码比对, 注: 可自定义
    if (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {
      logger.debug("Authentication failed: password does not match stored value");

      throw new BadCredentialsException(messages.getMessage(
        "AbstractUserDetailsAuthenticationProvider.badCredentials",
        "Bad credentials"));
    }
  }

  //通过 UserDetailsService 获取 UserDetails
  protected final UserDetails retrieveUser(String username,
                                           UsernamePasswordAuthenticationToken authentication)
    throws AuthenticationException {
    prepareTimingAttackProtection();
    try {
      //通过 UserDetailsService 获取 UserDetails
      UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);
      if (loadedUser == null) {
        throw new InternalAuthenticationServiceException(
          "UserDetailsService returned null, which is an interface contract violation");
      }
      return loadedUser;
    }
    catch (UsernameNotFoundException ex) {
      mitigateAgainstTimingAttack(authentication);
      throw ex;
    }
    catch (InternalAuthenticationServiceException ex) {
      throw ex;
    }
    catch (Exception ex) {
      throw new InternalAuthenticationServiceException(ex.getMessage(), ex);
    }
  }

  //生成身份认证通过后最终返回的 Authentication, 记录认证的身份信息
  @Override
  protected Authentication createSuccessAuthentication(Object principal,
                                                       Authentication authentication, UserDetails user) {
    boolean upgradeEncoding = this.userDetailsPasswordService != null
      && this.passwordEncoder.upgradeEncoding(user.getPassword());
    if (upgradeEncoding) {
      String presentedPassword = authentication.getCredentials().toString();
      String newPassword = this.passwordEncoder.encode(presentedPassword);
      user = this.userDetailsPasswordService.updatePassword(user, newPassword);
    }
    return super.createSuccessAuthentication(principal, authentication, user);
  }
}
```

## MySQL

### Mysql的存储引擎

- MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 SHOW ENGINES 语句来显示可用的数据库引擎和默认引擎。
- MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。
- MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。

### InnoDB和MyISAM的区别

- InnoDB支持事务，MyISAM不支持
- InnoDB支持行级锁而MyISAM仅仅支持表锁。但是InnoDB可能出现死锁。
- InnoDB的关注点在于：并发写、事务、更大资源。而MyISAM的关注点在于：节省资源、消耗少、简单业务
- InnoDB比MyISAM更安全，但是MyISAM的效率要比InnoDB高
- 在MySQL5.7的时候，默认就是InnoDb作为默认的存储引擎了

### Sql执行计划

- 使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析查询语句或是表结构的性能瓶颈。

```
Explain + SQL语句
```

- 通过Explain，我们可以获取以下信息：
  - 表的读取顺序
  - 哪些索引可以使用
  - 数据读取操作的操作类型
  - **哪些索引被实际使用**
  - 表之间的引用
  - **每张表有多少行被物理查询**

```
EXPLAIN SELECT * FROM USER;
```

![Image](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-04-11-640.png)

显示的结果一般不会全部去关注，比较关注的有：

- `id`是查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序。
  - id相同，执行顺序由上至下。
  - 如果是子查询，id的序号会递增。id越大优先级越高，越先被执行。
  - id如果相同，可以认为是一组，从上往下顺序执行。在所有组中，id值越大，优先级越高，越先执行。
  - **id号每个号码，表示一趟独立的查询。一个sql的查询趟数越少越好。**
- 第二个是`type`，显示的是访问类型。如果是`All`就代表是全表扫描。需要进行优化。一般来说，得保证查询至少达到range级别，最好能达到ref。
- 然后是`possible_keys`：sql所用到的索引
- 还有一个就是`key`，这个就是实际使用的索引。如果为NULL，则没有使用索引。
- 然后`key_len`表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。key_len字段能够帮你检查where条件是否充分的利用上了索引。key_len越长，查询效率越高。
- `rows`列显示MySQL认为它执行查询时必须检查的行数。行数越少，效率越高！

### 数据库优化

- 选取最适用的字段属性
- 使用连接查询代替子查询
- 为合适的字段创建索引

### 在上线后数据库要增加几个字段，你们是怎么做的

可以使用alter添加列，这样原有的数据不会改变，新增的字段值是null。 还可以使用Navicat或者SQLyog这些可视化工具修改表的结构，效果和上面的一样

### 数据库索引的优化建议以及有哪些注意点

- 使用复合索引的效果会大于使用单个字段索引（但是要注意顺序）
- 查询条件时要按照索引中的定义顺序进行匹配。如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。
- 不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描
- 存储引擎不能使用索引中范围条件右边的列，范围查询的列在定义索引的时候，应该放在最后面。
- mysql 在使用不等于(!= 或者<>)的时候无法使用索引会导致全表扫描
- is not null 也无法使用索引,但是is null是可以使用索引的
- like以通配符开头('%abc...')mysql索引失效会变成全表扫描的操作
- 字符串不加单引号索引失效（类型转换导致索引失效）

### MySQL锁

MyISAM支持表锁，InnoDB支持表锁和行锁，默认行锁。

- 表级锁：开锁小，加锁快，不会出现死锁。锁的粒度大，发生锁冲突的概率最高。并发量最低。
- 行级锁：开销大，加锁慢，会出现死锁，锁的粒度小，容易发生冲突的概率小，并发度最高

### 并发事务处理带来的问题

- 更新丢失：多个事务对同一行数据进行更新，最后提交的更新会覆盖其他事务的更新。
- 脏读：事务A读取到事务B已经修改但未提交的数据，还在这个数据基础上做了修改。此时，如果事务B回滚了，事务A的数据无效，不符合一致性要求。
- 不可重读：事务A读取到了事务B已经提交的修改数据，不符合隔离性。
- 幻读：事务A读取了事务B提交的新增数据，不符合隔离性。

### 事务的特性

- 原子性（atomicity）：

  一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

​	2.一致性（consistency）：

  数据库总是从一个一致性的状态转换到另一个一致性的状态。在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，前面执行的语句也不会生效。因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。

​	3.隔离性（isolation）：

  通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。当执行完第三条语句、第四条语句还未开始时，此时有另外一个程序开始运行，则看不到第三条语句做出的改变。

​	4.持久性（durability）：

   一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能有能做到100%的持久性保证策略。

### 事务的隔离级别

![Image](https://mmbiz.qpic.cn/sz_mmbiz_png/XMiaVKe3CRtiaCmJGKtPMVh5mLYuMUTXCQOVXjN5SR88ibnqTblbbo82udBYDPgU8JYHEHuJ7bS3WMwqh1r50khdg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### MySQL的事务隔离级别

## Redis

### Redis雪崩，穿透产生原因及怎么解决

- 一般的缓存系统，都是按照 key 去缓存查询，如果不存在对应的 value，就应该去后端数据库查。一些恶意的请求会故意查询不存在的 key,请求量很大，就会对后端系统造成很大的压力。 解决穿透的一种办法是对接口做校验,然后也可以对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后清理缓存。
- 缓存雪崩就是当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。我们可以做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。或者我们对不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

### Redis的数据类型

- String字符串：字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的，我们常使用的 set key value 命令就是字符串。常用在缓存、计数、共享Session、限速等。
- Hash哈希：在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可以用来存放用户信息，比如实现购物车。
- List列表（双向链表）：列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。
- Set集合：集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
- Sorted Set有序集合（跳表实现）：Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。

### Redis的持久化

- Redis为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。
- Redis的持久化策略有两种：
  1. RDB：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略。当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。 当子进程完成写临时文件后，将原来的RDB替换掉。
  2. AOF：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合。使用AOF做持久化，每一个写命令都通过write函数追加到appendonly.aof中。aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。 缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB。Redis默认是快照RDB的持久化方式。对于主从同步来说，主从刚刚连接的时候，进行全量同步（RDB）；全同步结束后，进行增量同步(AOF)。

### redis是单线程,但为什么快

1. 纯内存操作
2. 单线程操作，避免了频繁的上下文切换
3. 合理高效的数据结构
4. 采用了非阻塞I/O多路复用机制（有一个文件描述符同时监听多个文件描述符是否有数据到来）

### redis存的数据过期了，数据会立即删除吗

不会，其实有三种不同的删除策略：

1. 立即删除。在设置键的过期时间时，创建一个定时器，当过期时间达到时，立即执行删除操作。
2. 惰性删除。key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。
3. 定时删除。每隔一段时间，对全部的键进行检查，删除里面的过期键。

### Redis 和 Mysql 数据库数据如何保持一致性

先更新数据库，再删缓存。数据库的读操作的速度远快于写操作的，所以脏数据很难出现。可以对异步延时删除策略，保证读请求完成以后，再进行删除操作。

### Redis的应用场景

- 缓存
- 共享Session
- 消息队列系统
- 分布式锁

### redis里的hash类型怎么模糊查询

可以使用Java连接Redis，获得指定hash的所有值，然后做正则验证。

### Redis常用命令

```
key
    keys * 获取所有的key
    select 0 选择第一个库
    move myString 1 将当前的数据库key移动到某个数据库,目标库有，则不能移动
    flush db      清除指定库
    randomkey     随机key
    type key      类型
    
    set key1 value1 设置key
    get key1    获取key
    mset key1 value1 key2 value2 key3 value3
    mget key1 key2 key3
    del key1   删除key
    exists key      判断是否存在key
    expire key 10   10过期
    pexpire key 1000 毫秒
    persist key     删除过期时间

string
    set name cxx
    get name
    getrange name 0 -1        字符串分段
    getset name new_cxx       设置值，返回旧值
    mset key1 key2            批量设置
    mget key1 key2            批量获取
    setnx key value           不存在就插入（not exists）
    setex key time value      过期时间（expire）
    setrange key index value  从index开始替换value
    incr age        递增
    incrby age 10   递增
    decr age        递减
    decrby age 10   递减
    incrbyfloat     增减浮点数
    append          追加
    strlen          长度
    getbit/setbit/bitcount/bitop    位操作
    
hash
    hset myhash name cxx
    hget myhash name
    hmset myhash name cxx age 25 note "i am notes"
    hmget myhash name age note   
    hgetall myhash               获取所有的
    hexists myhash name          是否存在
    hsetnx myhash score 100      设置不存在的
    hincrby myhash id 1          递增
    hdel myhash name             删除
    hkeys myhash                 只取key
    hvals myhash                 只取value
    hlen myhash                  长度

list
    lpush mylist a b c  左插入
    rpush mylist x y z  右插入
    lrange mylist 0 -1  数据集合
    lpop mylist  弹出元素
    rpop mylist  弹出元素
    llen mylist  长度
    lrem mylist count value  删除
    lindex mylist 2          指定索引的值
    lset mylist 2 n          索引设值
    ltrim mylist 0 4         删除key
    linsert mylist before a  插入
    linsert mylist after a   插入
    rpoplpush list list2     转移列表的数据
    
set
    sadd myset redis 
    smembers myset       数据集合
    srem myset set1         删除
    sismember myset set1 判断元素是否在集合中
    scard key_name       个数
    sdiff | sinter | sunion 操作：集合间运算：差集 | 交集 | 并集
    srandmember          随机获取集合中的元素
    spop                 从集合中弹出一个元素
    
zset
    zadd zset 1 one
    zadd zset 2 two
    zadd zset 3 three
    zincrby zset 1 one              增长分数
    zscore zset two                 获取分数
    zrange zset 0 -1 withscores     范围值
    zrangebyscore zset 10 25 withscores 指定范围的值
    zrangebyscore zset 10 25 withscores limit 1 2 分页
    Zrevrangebyscore zset 10 25 withscores  指定范围的值
    zcard zset  元素数量
    Zcount zset 获得指定分数范围内的元素个数
    Zrem zset one two        删除一个或多个元素
    Zremrangebyrank zset 0 1  按照排名范围删除元素
    Zremrangebyscore zset 0 1 按照分数范围删除元素
    Zrank zset 0 -1    分数最小的元素排名为0
    Zrevrank zset 0 -1  分数最大的元素排名为0
    Zinterstore
    zunionstore rank:last_week 7 rank:20150323 rank:20150324 rank:20150325  weights 1 1 1 1 1 1 1
    
    
排序：
    sort mylist  排序
    sort mylist alpha desc limit 0 2 字母排序
    sort list by it:* desc           by命令
    sort list by it:* desc get it:*  get参数
    sort list by it:* desc get it:* store sorc:result  sort命令之store参数：表示把sort查询的结果集保存起来
```

## RabbitMq

### 怎么防止重复消费

- 可能因为各种原因，导致了生产端发送了多条一样的消息给消费端，但是，消费端也只能消费一条，不会多消费。可以使用`唯一ID + 指纹码机制`防止消息被重复消费。
- 指纹码(就是时间戳 + 业务的一些规则， 来保证id + 指纹码在同一时刻是唯一的，不会出现重复)。
  1. 唯一ID + 指纹码机制，利用数据库主键去重
  2. select count(1) from t_order where id = 唯一ID + 指纹码
     - 如果不存在，则正常消费，消费完毕后将【唯一ID + 指纹码】 写入数据库
     - 如果存在，则证明消息被消费过，直接丢弃。

### Rabbitmq怎么防止消息丢失

将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。 一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一ID）。

### 为什么选择使用MQ来实现同步

通过使用消息队列，我们可以异步处理请求，从而缓解系统的压力。同样可以达到解耦的效果。

## ElasticSearch

### 高亮你们是怎么做的

- SpringBoot整合ElasticSearch有一个searchSourceBuilder，通过链式调用一个highlighter方法，传入一个HighlightBuilder对象并设置好查询的列和高亮的标签。
- 之后调用RestHighLevelClient对象的Search方法之后返回一个SearchResponse对象，之后可以调用response.getHits().getHits();获得击中的结果数组，数组中每一个对象除了包含原始内容还包含了一个高亮结果集，是一个Map集合。

### SpringBoot怎么集成ElasticSearch

首先需要导入`spring-boot-starter-data-elasticsearch`，在Spring官网的data项目里面有详细的文档介绍，官方强烈建议使用  High Level REST Client来操作ES。之后需要添加一个配置类，在官方文档有介绍。之后我们就可以通过Spring容器来管理获取HighLevelRESTClient对象了。

## 其他

### Maven的声明周期？

- Maven有三套生命周期,分别是clean、default、site，每个生命周期都包含了一些阶段（phase）。三套生命周期相互独立，但各个生命周期中的phase却是有顺序的，且后面的phase依赖于前面的phase。执行某个phase时，其前面的phase会依顺序执行，但不会触发另外两套生命周期中的任何phase。
- clean的生命周期：

```
pre-clean：执行清理前的工作；
clean：清理上一次构建生成的所有文件；
post-clean：执行清理后的工作
```

- default的生命周期：default生命周期是最核心的，它包含了构建项目时真正需要执行的所有步骤。

```
validate
initialize
generate-sources
process-sources
generate-resources
process-resources    ：复制和处理资源文件到target目录，准备打包；
compile    ：编译项目的源代码；
process-classes
generate-test-sources
process-test-sources
generate-test-resources
process-test-resources
test-compile    ：编译测试源代码；
process-test-classes
test    ：运行测试代码；
prepare-package
package    ：打包成jar或者war或者其他格式的分发包；
pre-integration-test
integration-test
post-integration-test
verify
install    ：将打好的包安装到本地仓库，供其他项目使用；
deploy    ：将打好的包安装到远程仓库，供其他项目使用；
```

- site的生命周期：

```
pre-site
site    ：生成项目的站点文档；
post-site
site-deploy    ：发布生成的站点文档
```

### cookie和session区别

1. cookie数据存放在客户的浏览器上，session数据放在服务器上。
2. cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。
4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
5. 可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。

## 数据结构

### 红黑树

​	根节点是黑色 

​	每个节点都只能是红色或者黑色

​	每个叶节点（NIL节点，空节点）是黑色的。 

​	如果一个节点是红色的，则它两个子节点都是黑色的，也就是说在一条路径上不能出现两个红色的节点。

​	从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

## 算法

### 排序算法

排序算法是最经典的算法知识。因为其实现代码短，应该广，在面试中经常会问到排序算法及其相关的问题。一般在面试中最常考的是快速排序和归并排序等基本的排序算法，并且经常要求现场手写基本的排序算法。如果这些问题回答不好，估计面试就凉凉了。所以熟练掌握排序算法思想及其特点并能够熟练地手写代码至关重要。

下面介绍几种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序的思想，其代码均采用Java实现。

#### 1. 冒泡排序

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

**算法描述**

1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3. 针对所有的元素重复以上的步骤，除了最后一个；
4. 重复步骤1~3，直到排序完成。

**动图演示**



![img](https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.jpg)



**算法实现**

```java
public static void bubbleSort(int[] arr) {
    int temp = 0;
    for (int i = arr.length - 1; i > 0; i--) { // 每次需要排序的长度
        for (int j = 0; j < i; j++) { // 从第一个元素到第i个元素
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }//loop j
    }//loop i
}// method bubbleSort
```

**稳定性**

在相邻元素相等时，它们并不会交换位置，所以，冒泡排序是稳定排序。

**适用场景**

冒泡排序思路简单，代码也简单，特别适合小数据的排序。但是，由于算法复杂度较高，在数据量大的时候不适合使用。

**代码优化**

在数据完全有序的时候展现出最优时间复杂度，为O(n)。其他情况下，几乎总是O( n2 )。因此，算法在数据基本有序的情况下，性能最好。
要使算法在最佳情况下有O(n)复杂度，需要做一些改进，增加一个`swap`的标志，当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接退出。

```java
public static void bubbleSort(int[] arr) {
    int temp = 0;
    boolean swap;
    for (int i = arr.length - 1; i > 0; i--) { // 每次需要排序的长度
        swap=false;
        for (int j = 0; j < i; j++) { // 从第一个元素到第i个元素
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swap=true;
            }
        }//loop j
        if (swap==false){
            break;
        }
    }//loop i
}// method bubbleSort
```

#### 2. 选择排序

选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。

**算法描述**

1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
2. 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3. 重复第二步，直到所有元素均排序完毕。

**动图演示**



![img](https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.jpg)



**算法实现**

```java
public static void selectionSort(int[] arr) {
    int temp, min = 0;
    for (int i = 0; i < arr.length - 1; i++) {
        min = i;
        // 循环查找最小值
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[min] > arr[j]) {
                min = j;
            }
        }
        if (min != i) {
            temp = arr[i];
            arr[i] = arr[min];
            arr[min] = temp;
        }
    }
}
```

**稳定性**

用数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的。
不过，一般提到排序算法时，大家往往会默认是数组实现，所以选择排序是不稳定的。

**适用场景**

选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的O(n2)复杂度，选择排序在海量数据面前显得力不从心。因此，它适用于简单数据排序。

#### 3. 插入排序

插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

**算法描述**

1. 把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的。
2. 从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置。
3. 重复上述过程直到最后一个元素被插入有序子数组中。

**动图演示**



![img](https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.jpg)

**算法实现**

```java
public static void insertionSort(int[] arr){
    for (int i=1; i<arr.length; ++i){
        int value = arr[i];
        int position=i;
        while (position>0 && arr[position-1]>value){
            arr[position] = arr[position-1];
            position--;
        }
        arr[position] = value;
    }//loop i
}
```

**稳定性**

由于只需要找到不大于当前数的位置而并不需要交换，因此，直接插入排序是稳定的排序方法。

**适用场景**

插入排序由于O( n2 )的复杂度，在数组较大的时候不适用。但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。例如，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序。又如，在JDK 7 java.util.Arrays所用的sort方法的实现中，当待排数组长度小于47时，会使用插入排序。

#### 4. 归并排序

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 

**算法描述**

两种方法

- 递归法（Top-down）

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针到达序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾

- 迭代法（Bottom-up）

原理如下（假设序列共有n个元素）：

1. 将序列每相邻两个数字进行归并操作，形成ceil(n/2)个序列，排序后每个序列包含两/一个元素
2. 若此时序列数不是1个则将上述序列再次归并，形成ceil(n/4)个序列，每个序列包含四/三个元素
3. 重复步骤2，直到所有元素排序完毕，即序列数为1

**动图演示**



![img](https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.jpg)



**算法实现**

```java
public static void mergeSort(int[] arr){
    int[] temp =new int[arr.length];
    internalMergeSort(arr, temp, 0, arr.length-1);
}
private static void internalMergeSort(int[] arr, int[] temp, int left, int right){
    //当left==right的时，已经不需要再划分了
    if (left<right){
        int middle = (left+right)/2;
        internalMergeSort(arr, temp, left, middle);          //左子数组
        internalMergeSort(arr, temp, middle+1, right);       //右子数组
        mergeSortedArray(arr, temp, left, middle, right);    //合并两个子数组
    }
}
// 合并两个有序子序列
private static void mergeSortedArray(int arr[], int temp[], int left, int middle, int right){
    int i=left;      
    int j=middle+1;
    int k=0;
    while (i<=middle && j<=right){
        temp[k++] = arr[i] <= arr[j] ? arr[i++] : arr[j++];
    }
    while (i <=middle){
        temp[k++] = arr[i++];
    }
    while ( j<=right){
        temp[k++] = arr[j++];
    }
    //把数据复制回原数组
    for (i=0; i<k; ++i){
        arr[left+i] = temp[i];
    }
}
```

**稳定性**

因为我们在遇到相等的数据的时候必然是按顺序“抄写”到辅助数组上的，所以，归并排序同样是稳定算法。

**适用场景**

归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。

#### **5. 快速排序**

快速排序是一个知名度极高的排序算法，其对于大数据的优秀排序性能和相同复杂度算法中相对简单的实现使它注定得到比其他算法更多的宠爱。

**算法描述**

1. 从数列中挑出一个元素，称为"基准"（pivot），
2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。

**动图演示**



![img](https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.jpg)



**算法实现**

```java
public static void quickSort(int[] arr){
    qsort(arr, 0, arr.length-1);
}
private static void qsort(int[] arr, int low, int high){
    if (low >= high)
        return;
    int pivot = partition(arr, low, high);        //将数组分为两部分
    qsort(arr, low, pivot-1);                   //递归排序左子数组
    qsort(arr, pivot+1, high);                  //递归排序右子数组
}
private static int partition(int[] arr, int low, int high){
    int pivot = arr[low];     //基准
    while (low < high){
        while (low < high && arr[high] >= pivot) --high;
        arr[low]=arr[high];             //交换比基准大的记录到左端
        while (low < high && arr[low] <= pivot) ++low;
        arr[high] = arr[low];           //交换比基准小的记录到右端
    }
    //扫描完成，基准到位
    arr[low] = pivot;
    //返回的是基准的位置
    return low;
}
```

**稳定性**

快速排序并不是稳定的。这是因为我们无法保证相等的数据按顺序被扫描到和按顺序存放。

**适用场景**

快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。

#### **6. 堆排序**

堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。

**树的概念**

关于树的概念请参考：[[算法总结\] 二叉树](https://zhuanlan.zhihu.com/write)

**堆的概念**

堆是一种特殊的完全二叉树（complete binary tree）。完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。
如下图，是一个堆和数组的相互关系：

![img](https://pic3.zhimg.com/80/v2-ee5361924b3a5d942045f0455989b496_720w.jpg)


对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标：

- Parent(i) = floor(i/2)，i 的父节点下标
- Left(i) = 2i，i 的左子节点下标
- Right(i) = 2i + 1，i 的右子节点下标

二叉堆一般分为两种：最大堆和最小堆。
**最大堆：**
最大堆中的最大元素值出现在根结点（堆顶）
堆中每个父节点的元素值都大于等于其孩子结点（如果存在）

![img](https://pic3.zhimg.com/80/v2-03738a5cbdc36e179153de3c1c444a86_720w.jpg)


**最小堆：**
最小堆中的最小元素值出现在根结点（堆顶）
堆中每个父节点的元素值都小于等于其孩子结点（如果存在）

![img](https://pic4.zhimg.com/80/v2-7706ecb76bb194619d8c996281ba96c3_720w.jpg)



**堆排序原理**

堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：

- 最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点
- 创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆
- 堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 继续进行下面的讨论前，需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变



![img](https://pic2.zhimg.com/80/v2-c701eeb7741b66f7cc23aa1834c8e539_720w.jpg)


相应的，几个计算公式也要作出相应调整：

- Parent(i) = floor((i-1)/2)，i 的父节点下标
- Left(i) = 2i + 1，i 的左子节点下标
- Right(i) = 2(i + 1)，i 的右子节点下标

**堆的建立和维护**

堆可以支持多种操作，但现在我们关心的只有两个问题：

1. 给定一个无序数组，如何建立为堆？
2. 删除堆顶元素后，如何调整数组成为新堆？

先看第二个问题。假定我们已经有一个现成的大根堆。现在我们删除了根元素，但并没有移动别的元素。想想发生了什么：根元素空了，但其它元素还保持着堆的性质。我们可以把**最后一个元素**（代号A）移动到根元素的位置。如果不是特殊情况，则堆的性质被破坏。但这仅仅是由于A小于其某个子元素。于是，我们可以把A和这个子元素调换位置。如果A大于其所有子元素，则堆调整好了；否则，重复上述过程，A元素在树形结构中不断“下沉”，直到合适的位置，数组重新恢复堆的性质。上述过程一般称为“筛选”，方向显然是自上而下。

> 删除后的调整，是把最后一个元素放到堆顶，自上而下比较

删除一个元素是如此，插入一个新元素也是如此。不同的是，我们把新元素放在**末尾**，然后和其父节点做比较，即自下而上筛选。

> 插入是把新元素放在末尾，自下而上比较

那么，第一个问题怎么解决呢？

常规方法是从第一个非叶子结点向下筛选，直到根元素筛选完毕。这个方法叫“筛选法”，需要循环筛选n/2个元素。

但我们还可以借鉴“插入排序”的思路。我们可以视第一个元素为一个堆，然后不断向其中添加新元素。这个方法叫做“插入法”，需要循环插入(n-1)个元素。

由于筛选法和插入法的方式不同，所以，相同的数据，它们建立的堆一般不同。大致了解堆之后，堆排序就是水到渠成的事情了。

**动图演示**

![img](https://pic3.zhimg.com/v2-c66a7e83189427b6a5a5c378f73c17ca_b.jpg)



**算法描述**

我们需要一个升序的序列，怎么办呢？我们可以建立一个最小堆，然后每次输出根元素。但是，这个方法需要额外的空间（否则将造成大量的元素移动，其复杂度会飙升到O(n2) ）。如果我们需要就地排序（即不允许有O(n)空间复杂度），怎么办？

有办法。我们可以建立最大堆，然后我们倒着输出，在最后一个位置输出最大值，次末位置输出次大值……由于每次输出的最大元素会腾出第一个空间，因此，我们恰好可以放置这样的元素而不需要额外空间。很漂亮的想法，是不是？

**算法实现**

```java
public class ArrayHeap {
    private int[] arr;
    public ArrayHeap(int[] arr) {
        this.arr = arr;
    }
    private int getParentIndex(int child) {
        return (child - 1) / 2;
    }
    private int getLeftChildIndex(int parent) {
        return 2 * parent + 1;
    }
    private void swap(int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    /**
     * 调整堆。
     */
    private void adjustHeap(int i, int len) {
        int left, right, j;
        left = getLeftChildIndex(i);
        while (left <= len) {
            right = left + 1;
            j = left;
            if (j < len && arr[left] < arr[right]) {
                j++;
            }
            if (arr[i] < arr[j]) {
                swap(array, i, j);
                i = j;
                left = getLeftChildIndex(i);
            } else {
                break; // 停止筛选
            }
        }
    }
    /**
     * 堆排序。
     * */
    public void sort() {
        int last = arr.length - 1;
        // 初始化最大堆
        for (int i = getParentIndex(last); i >= 0; --i) {
            adjustHeap(i, last);
        }
        // 堆调整
        while (last >= 0) {
            swap(0, last--);
            adjustHeap(0, last);
        }
    }

}
```

**稳定性**

堆排序存在大量的筛选和移动过程，属于不稳定的排序算法。

**适用场景**

堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。

#### **7. 希尔排序（插入排序的改良版）**

在希尔排序出现之前，计算机界普遍存在“排序算法不可能突破O(n2)”的观点。希尔排序是第一个突破O(n2)的排序算法，它是简单插入排序的改进版。希尔排序的提出，主要基于以下两点：

1. 插入排序算法在数组基本有序的情况下，可以近似达到O(n)复杂度，效率极高。
2. 但插入排序每次只能将数据移动一位，在数组较大且基本无序的情况下性能会迅速恶化。

**算法描述**

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

- 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
- 按增量序列个数k，对序列进行 k 趟排序；
- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

**动图演示**



![img](https://pic3.zhimg.com/v2-f14e4169ff39bad42c3dd6c385ad9c72_b.jpg)



**算法实现**

Donald Shell增量

```java
public static void shellSort(int[] arr){
    int temp;
    for (int delta = arr.length/2; delta>=1; delta/=2){                              //对每个增量进行一次排序
        for (int i=delta; i<arr.length; i++){              
            for (int j=i; j>=delta && arr[j]<arr[j-delta]; j-=delta){ //注意每个地方增量和差值都是delta
                temp = arr[j-delta];
                arr[j-delta] = arr[j];
                arr[j] = temp;
            }
        }//loop i
    }//loop delta
}
```

O(n3/2) by Knuth

```java
public static void shellSort2(int[] arr){
    int delta = 1;
    while (delta < arr.length/3){//generate delta
        delta=delta*3+1;    // <O(n^(3/2)) by Knuth,1973>: 1, 4, 13, 40, 121, ...
    }         
    int temp;
    for (; delta>=1; delta/=3){
        for (int i=delta; i<arr.length; i++){              
            for (int j=i; j>=delta && arr[j]<arr[j-delta]; j-=delta){
                temp = arr[j-delta];
                arr[j-delta] = arr[j];
                arr[j] = temp;
            }
        }//loop i
    }//loop delta
}
```

**希尔排序的增量**

希尔排序的增量数列可以任取，需要的唯一条件是最后一个一定为1（因为要保证按1有序）。但是，不同的数列选取会对算法的性能造成极大的影响。上面的代码演示了两种增量。
切记：增量序列中每两个元素最好不要出现1以外的公因子！（很显然，按4有序的数列再去按2排序意义并不大）。
下面是一些常见的增量序列。
\- 第一种增量是最初Donald Shell提出的增量，即折半降低直到1。据研究，使用希尔增量，其时间复杂度还是O(n2)。

第二种增量Hibbard：{1, 3, ..., 2k-1}。该增量序列的时间复杂度大约是O(n1.5)。

第三种增量Sedgewick增量：(1, 5, 19, 41, 109,...)，其生成序列或者是9*4i* *- 9*2i + 1或者是4i - 3*2i + 1。

**稳定性**

我们都知道插入排序是稳定算法。但是，Shell排序是一个多次插入的过程。在一次插入中我们能确保不移动相同元素的顺序，但在多次的插入中，相同元素完全有可能在不同的插入轮次被移动，最后稳定性被破坏，因此，Shell排序不是一个稳定的算法。

**适用场景**

Shell排序虽然快，但是毕竟是插入排序，其数量级并没有后起之秀--快速排序O(n㏒n)快。在大量数据面前，Shell排序不是一个好的算法。但是，中小型规模的数据完全可以使用它。

#### **计数排序**

计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

**算法描述**

1. 找出待排序的数组中最大和最小的元素；
2. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
3. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
4. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。

**动图演示**



![img](https://pic4.zhimg.com/v2-3c7ddb59df2d21b287e42a7b908409cb_b.jpg)



**算法实现**

```java
public static void countSort(int[] a, int max, int min) {
     int[] b = new int[a.length];//存储数组
     int[] count = new int[max - min + 1];//计数数组

     for (int num = min; num <= max; num++) {
        //初始化各元素值为0，数组下标从0开始因此减min
        count[num - min] = 0;
     }

     for (int i = 0; i < a.length; i++) {
        int num = a[i];
        count[num - min]++;//每出现一个值，计数数组对应元素的值+1
     }

     for (int num = min + 1; num <= max; num++) {
        //加总数组元素的值为计数数组对应元素及左边所有元素的值的总和
        count[num - min] += sum[num - min - 1]
     }

     for (int i = 0; i < a.length; i++) {
          int num = a[i];//源数组第i位的值
          int index = count[num - min] - 1;//加总数组中对应元素的下标
          b[index] = num;//将该值存入存储数组对应下标中
          count[num - min]--;//加总数组中，该值的总和减少1。
     }

     //将存储数组的值一一替换给源数组
     for(int i=0;i<a.length;i++){
         a[i] = b[i];
     }
}
```

**稳定性**

最后给 b 数组赋值是倒着遍历的，而且放进去一个就将C数组对应的值（表示前面有多少元素小于或等于A[i]）减去一。如果有相同的数x1,x2，那么相对位置后面那个元素x2放在（比如下标为4的位置），相对位置前面那个元素x1下次进循环就会被放在x2前面的位置3。从而保证了稳定性。

**适用场景**

排序目标要能够映射到整数域，其最大值最小值应当容易辨别。例如高中生考试的总分数，显然用0-750就OK啦；又比如一群人的年龄，用个0-150应该就可以了，再不济就用0-200喽。另外，计数排序需要占用大量空间，它比较适用于数据比较集中的情况。

#### **桶排序**

桶排序又叫箱排序，是计数排序的升级版，它的工作原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。

> 计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。网络中很多博文写的桶排序实际上都是计数排序，并非标准的桶排序，要注意辨别。

**算法描述**

1. 找出待排序数组中的最大值max、最小值min
2. 我们使用 动态数组ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max-min)/arr.length+1
3. 遍历数组 arr，计算每个元素 arr[i] 放的桶
4. 每个桶各自排序
5. 遍历桶数组，把排序好的元素放进输出数组

**图片演示**



![img](https://pic1.zhimg.com/80/v2-465190477b7fb90d17aef27c2a213368_720w.jpg)



**算法实现**

```java
public static void bucketSort(int[] arr){
    int max = Integer.MIN_VALUE;
    int min = Integer.MAX_VALUE;
    for(int i = 0; i < arr.length; i++){
        max = Math.max(max, arr[i]);
        min = Math.min(min, arr[i]);
    }
    //桶数
    int bucketNum = (max - min) / arr.length + 1;
    ArrayList<ArrayList<Integer>> bucketArr = new ArrayList<>(bucketNum);
    for(int i = 0; i < bucketNum; i++){
        bucketArr.add(new ArrayList<Integer>());
    }
    //将每个元素放入桶
    for(int i = 0; i < arr.length; i++){
        int num = (arr[i] - min) / (arr.length);
        bucketArr.get(num).add(arr[i]);
    }
    //对每个桶进行排序
    for(int i = 0; i < bucketArr.size(); i++){
        Collections.sort(bucketArr.get(i));
    }
    System.out.println(bucketArr.toString());
}
```

**稳定性**

可以看出，在分桶和从桶依次输出的过程是稳定的。但是，由于我们在对每个桶进行排序时使用了其他算法，所以，桶排序的稳定性依赖于这一步。如果我们使用了快排，显然，算法是不稳定的。

**适用场景**

桶排序可用于最大最小值相差较大的数据情况，但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。

#### **基数排序**

基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。
排序过程：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

**算法描述**

1. 取得数组中的最大数，并取得位数；
2. arr为原始数组，从最低位开始取每个位组成radix数组；
3. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；

**动图**

![img](https://pic3.zhimg.com/v2-3a6f1e5059386523ed941f0d6c3a136e_b.jpg)

**算法实现**

```java
public abstract class Sorter {
     public abstract void sort(int[] array);
}
 
public class RadixSorter extends Sorter {
     
     private int radix;
     
     public RadixSorter() {
          radix = 10;
     }
     
     @Override
     public void sort(int[] array) {
          // 数组的第一维表示可能的余数0-radix，第二维表示array中的等于该余数的元素
          // 如：十进制123的个位为3，则bucket[3][] = {123}
          int[][] bucket = new int[radix][array.length];
          int distance = getDistance(array); // 表示最大的数有多少位
          int temp = 1;
          int round = 1; // 控制键值排序依据在哪一位
          while (round <= distance) {
               // 用来计数：数组counter[i]用来表示该位是i的数的个数
               int[] counter = new int[radix];
               // 将array中元素分布填充到bucket中，并进行计数
               for (int i = 0; i < array.length; i++) {
                    int which = (array[i] / temp) % radix;
                    bucket[which][counter[which]] = array[i];
                    counter[which]++;
               }
               int index = 0;
               // 根据bucket中收集到的array中的元素，根据统计计数，在array中重新排列
               for (int i = 0; i < radix; i++) {
                    if (counter[i] != 0)
                         for (int j = 0; j < counter[i]; j++) {
                              array[index] = bucket[i][j];
                              index++;
                         }
                    counter[i] = 0;
               }
               temp *= radix;
               round++;
          }
     }
     
     private int getDistance(int[] array) {
          int max = computeMax(array);
          int digits = 0;
          int temp = max / radix;
          while(temp != 0) {
               digits++;
               temp = temp / radix;
          }
          return digits + 1;
     }
     
     private int computeMax(int[] array) {
          int max = array[0];
          for(int i=1; i<array.length; i++) {
               if(array[i]>max) {
                    max = array[i];
               }
          }
          return max;
     }
}
```

**稳定性**

通过上面的排序过程，我们可以看到，每一轮映射和收集操作，都保持从左到右的顺序进行，如果出现相同的元素，则保持他们在原始数组中的顺序。可见，基数排序是一种稳定的排序。

**适用场景**

基数排序要求较高，元素必须是整数，整数时长度10W以上，最大值100W以下效率较好，但是基数排序比其他排序好在可以适用字符串，或者其他需要根据多个条件进行排序的场景，例如日期，先排序日，再排序月，最后排序年 ，其它排序算法可是做不了的。

#### **总结**

![img](https://raw.githubusercontent.com/LuShan123888/Files/main/Pictures/2021-04-14-v2-f718f6b01ad35a60b9d4f02330f81439_720w.jpg)

### 二叉树遍历

二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆了。所以，对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。

四种主要的遍历思想为：

前序遍历：根结点 ---> 左子树 ---> 右子树

中序遍历：左子树---> 根结点 ---> 右子树

后序遍历：左子树 ---> 右子树 ---> 根结点

层次遍历：只需按层次遍历即可

例如，求下面二叉树的各种遍历





前序遍历：1  2  4  5  7  8  3  6 

中序遍历：4  2  7  5  8  1  3  6

后序遍历：4  7  8  5  2  6  3  1

层次遍历：1  2  3  4  5  6  7  8

一、前序遍历

1）根据上文提到的遍历思路：根结点 ---> 左子树 ---> 右子树，很容易写出递归版本：

```
public void preOrderTraverse1(TreeNode root) {
		if (root != null) {
			System.out.print(root.val+"  ");
			preOrderTraverse1(root.left);
			preOrderTraverse1(root.right);
		}
	}
```


2）现在讨论非递归的版本：
根据前序遍历的顺序，优先访问根结点，然后在访问左子树和右子树。所以，对于任意结点node，第一部分即直接访问之，之后在判断左子树是否为空，不为空时即重复上面的步骤，直到其为空。若为空，则需要访问右子树。注意，在访问过左孩子之后，需要反过来访问其右孩子，所以，需要栈这种数据结构的支持。对于任意一个结点node，具体步骤如下：

a)访问之，并把结点node入栈，当前结点置为左孩子；

b)判断结点node是否为空，若为空，则取出栈顶结点并出栈，将右孩子置为当前结点；否则重复a)步直到当前结点为空或者栈为空（可以发现栈中的结点就是为了访问右孩子才存储的）

代码如下：

```
public void preOrderTraverse2(TreeNode root) {
		LinkedList<TreeNode> stack = new LinkedList<>();
		TreeNode pNode = root;
		while (pNode != null || !stack.isEmpty()) {
			if (pNode != null) {
				System.out.print(pNode.val+"  ");
				stack.push(pNode);
				pNode = pNode.left;
			} else { //pNode == null && !stack.isEmpty()
				TreeNode node = stack.pop();
				pNode = node.right;
			}
		}
	}
```

二、中序遍历
1)根据上文提到的遍历思路：左子树 ---> 根结点 ---> 右子树，很容易写出递归版本：

```
public void inOrderTraverse1(TreeNode root) {
		if (root != null) {
			inOrderTraverse1(root.left);
			System.out.print(root.val+"  ");
			inOrderTraverse1(root.right);
		}
	}
```

2）非递归实现，有了上面前序的解释，中序也就比较简单了，相同的道理。只不过访问的顺序移到出栈时。代码如下：

```
public void inOrderTraverse2(TreeNode root) {
		LinkedList<TreeNode> stack = new LinkedList<>();
		TreeNode pNode = root;
		while (pNode != null || !stack.isEmpty()) {
			if (pNode != null) {
				stack.push(pNode);
				pNode = pNode.left;
			} else { //pNode == null && !stack.isEmpty()
				TreeNode node = stack.pop();
				System.out.print(node.val+"  ");
				pNode = node.right;
			}
		}
	}
```

三、后序遍历

1）根据上文提到的遍历思路：左子树 ---> 右子树 ---> 根结点，很容易写出递归版本：

```
public void postOrderTraverse1(TreeNode root) {
		if (root != null) {
			postOrderTraverse1(root.left);
			postOrderTraverse1(root.right);
			System.out.print(root.val+"  ");
		}
	}
```


2）非递归的代码，暂且不写
四、层次遍历

层次遍历的代码比较简单，只需要一个队列即可，先在队列中加入根结点。之后对于任意一个结点来说，在其出队列的时候，访问之。同时如果左孩子和右孩子有不为空的，入队列。代码如下：

```
public void levelTraverse(TreeNode root) {
		if (root == null) {
			return;
		}
		LinkedList<TreeNode> queue = new LinkedList<>();
		queue.offer(root);
		while (!queue.isEmpty()) {
			TreeNode node = queue.poll();
			System.out.print(node.val+"  ");
			if (node.left != null) {
				queue.offer(node.left);
			}
			if (node.right != null) {
				queue.offer(node.right);
			}
		}
	}
```

五、深度优先遍历
其实深度遍历就是上面的前序、中序和后序。但是为了保证与广度优先遍历相照应，也写在这。代码也比较好理解，其实就是前序遍历，代码如下：

```
public void depthOrderTraverse(TreeNode root) {
		if (root == null) {
			return;
		}
		LinkedList<TreeNode> stack = new LinkedList<>();
		stack.push(root);
		while (!stack.isEmpty()) {
			TreeNode node = stack.pop();
			System.out.print(node.val+"  ");
			if (node.right != null) {
				stack.push(node.right);
			}
			if (node.left != null) {
				stack.push(node.left);
			}
		}
	}
```

## 操作系统

### 线程与进程

### 线程的状态

进程的状态

就绪(Ready)状态

当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。

执行状态

进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。

阻塞状态

正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。致使进程阻塞的典型事件有：请求I/O，申请缓冲空间等。通常将这种处于阻塞状态的进程也排成一个队列。有的系统则根据阻塞原因的不同而把处于阻塞状态的进程排成多个队列。

**三者的转换图如下：**

![img](https:////upload-images.jianshu.io/upload_images/1485056-efde09b1217348ee.png?imageMogr2/auto-orient/strip|imageView2/2/w/852)

**挂起状态**

在不少系统中进程只有上述三种状态，但在另一些系统中，又增加了一些新状态，最重要的是挂起状态。引入挂起状态的原因有：

(1) 终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂时使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态称为挂起状态。

(2) 父进程请求。有时父进程希望挂起自己的某个子进程，以便考查和修改该子进程，或者协调各子进程间的活动。

(3) 负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。

(4) 操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。

**具有挂起状态的转换图**

![img](https:////upload-images.jianshu.io/upload_images/1485056-999cd919ddf7beac.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/927)

**创建状态**

创建一个进程一般要通过一下两个两个步骤

(1) 为一个新进程创建PCB，并填写必要的管理信息.

(2) 把该进程转入就绪状态并插入就绪队列之中。当一个新进程被创建时，系统已为其分配了PCB，填写了进程标识等信息，但由于该进程所必需的资源或其它信息，如主存资源尚未分配等，一般而言，此时的进程已拥有了自己PCB，但进程自身还未进入主存，即创建工作尚未完成，进程还不能被调度运行，其所处的状态就是创建状态。 引入创建状态，是为了保证进程的调度必须在创建工作完成后进行，以确保对进程控制块操作的完整性。同时，创建状态的引入，也增加了管理的灵活性，操作系统可以根据系统性能或主存容量的限制，推迟创建状态进程的提交。对于处于创建状态的进程，获得了其所必需的资源，以及对其PCB初始化工作完成后，进程状态便可由创建状态转入就绪状态。

终止状态

等待操作系统进行善后处理，然后将其PCB清零，并将PCB空间返还系统。当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态。进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其它进程收集。一旦其它进程完成了对终止状态进程的信息提取之后，操作系统将删除该进程。

增加了创建状态和终止状态后，进程的三种基本状态及转换图衍变为五种状态及转换关系图



![img](https:////upload-images.jianshu.io/upload_images/1485056-9d17cf698a3f0dbc.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)



### 死锁条件

-  AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。
  -   1） 互斥条件：一个资源每次只能被一个进程使用。 
  - （2） 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 
  - （3）不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
  - （4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 
- 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之
- 死锁避免
- 允许进程动态的申请资源，但系统在进行资源分配前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源你分配给进程，否则，让进程等待。
- 所谓安全状态，是指系统能按某种进程推进顺序，为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，是每个进程都可以顺序的完成。此时成P1P2P3...为安全序列，如果系统无法找到一个安全序列，则称系统处于不安全状态。
- 并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可以避免进入死锁状态。
- 银行家算法是最著名的死锁避免算法。
- 死锁解除
  - 资源剥夺法。挂起某些思索进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源时，而处于资源匮乏的状态。
  - 进程撤销法。强制撤销一个或一部分进程并剥夺这些进程的资源。撤销的原则可以按进程的优先级和撤销进程代价的高低进行。
  - 进程回退法。让一个或多个进程回退到足以回避死锁的地步，进程回退时资源释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

## 计算机网络

### TCP三次握手，4次挥手的过程描述一下

**握手过程**：

1. 主机A向主机B发送请求连接数据报，其中包括A的序列号`seq=x`，请求连接的标志位`SYN=1`
2. 主机B收到请求之后返回确认连接数据报，其中包括B的序列号`seq=y`，请求连接的标志位`SYN=1`，`ACK=1`还有一个确认号，`ack=x+1`
3. 主机A收到了B的确认报文后再次做出确认，再发送一个数据报，其中包括：`ACK=1`，`seq=x+1`，`ack=y+1`

- 至于为什么要发送第三条是因为在发送第一条的时候，可能因为网络原因导致数据报滞留，那么超过一定时间主机A会再次发送请求连接的数据报文。之后主机B返回确认连接报文，如果主机A收到确认报文之后不发送第三条报文告诉主机B自己已经收到了，那么B其实是不知道的，这时候可能A第一次发送的原本滞留的报文突然正常了，B就再次收到了请求连接的报文，但是实际上A已经连接了。

**挥手过程**：

1. 客户端向服务器发送一个请求断开连接的数据报，终止位`FIN=1`，序列号`seq=u`
2. 服务器收到请求后返回`ACK=1`，`seq=v`，`ack=u+1`。之后客户端通往服务器的单向连接就断开了。
3. 之后服务器也需要和客户端断开连接，也是发送了一个FIN
4. 客户端收到FIN后返回ACK，并将确认号设置为收到的序号+1

- 其实在客户端断开和服务器的单向连接之后，服务器仍然可以往客户端发送数据，需要处理一下事情。
- 客户端需要最后等一段时间才能进入关闭状态是因为：客户端无法保证最后发送的ACK报文会一定被对方收到，所以有时候需要重发可能丢失的ACK报文。

### Http 长连接短连接

​	Connection:keep-alive

​	**短连接**的操作步骤是：

​	建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接

​	**长连接**的操作步骤是：

​	建立连接——数据传输...（保持连接）...数据传输——关闭连接

​	**长连接**多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 

　　而像WEB网站的http服务一般都用**短链接**，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。

### TCP流量控制,拥塞控制

**一：流量控制**

什么是流量控制？流量控制的目的？

如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。

如何实现流量控制？

由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。

流量控制引发的死锁？怎么避免死锁的发生？

当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。
为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。

**二：拥塞控制和流量控制的区别**

拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。

流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。

**三：拥塞控制的算法**

我们在开始假定：1、数据是单方向传递，另一个窗口只发送确认；2、接收方的缓存足够大，因此发送方的大小的大小由网络的拥塞程度来决定。

（一）慢开始算法：

发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。

慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。

这里用报文段的个数作为拥塞窗口的大小举例说明慢开始算法，实际的拥塞窗口大小是以字节为单位的。如下图：



![img](https://pic2.zhimg.com/80/v2-54715533f093170d50f1ff1be39006e9_1440w.jpg)



从上图可以看到，一个传输轮次所经历的时间其实就是往返时间RTT，而且没经过一个传输轮次（transmission round），拥塞窗口cwnd就加倍。

为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：当cwnd<ssthresh时，使用慢开始算法。
当cwnd>ssthresh时，改用拥塞避免算法。
当cwnd=ssthresh时，慢开始与拥塞避免算法任意

注意，这里的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，然后逐渐增大，这当然比按照大的cwnd一下子把许多报文段突然注入到网络中要“慢得多”。

（二）拥塞避免算法：

拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

整个拥塞控制的流程如下图：



![img](https://pic3.zhimg.com/80/v2-f7db63b1f00cbd8170e1435616e06216_1440w.jpg)



（1）拥塞窗口cwnd初始化为1个报文段，慢开始门限初始值为16
（2）执行慢开始算法，指数规律增长到第4轮，即cwnd=16=ssthresh，改为执行拥塞避免算法，拥塞窗口按线性规律增长
（3）假定cwnd=24时，网络出现超时（拥塞），则更新后的ssthresh=12，cwnd重新设置为1，并执行慢开始算法。当cwnd=12=ssthresh时，改为执行拥塞避免算法

关于 乘法减小（Multiplicative Decrease）和加法增大（Additive Increase）：

“乘法减小”指的是无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半，并执行慢开始算法，所以当网络频繁出现拥塞时，ssthresh下降的很快，以大大减少注入到网络中的分组数。“加法增大”是指执行拥塞避免算法后，使拥塞窗口缓慢增大，以防止过早出现拥塞。常合起来成为AIMD算法。

注意：“拥塞避免”并非完全能够避免了阻塞，而是使网络比较不容易出现拥塞。

（三）快重传算法：

快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。如下图：



![img](https://pic3.zhimg.com/80/v2-c72fce5494ca8ee12244189430f12cea_1440w.jpg)



（四）快恢复算法：

- 快重传配合使用的还有快恢复算法，有以下两个要点：
- 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞）。但是接下去并不执行慢开始算法
  考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。如下图：TCP Reno版本是目前使用最广泛的版本。

![img](https://pic4.zhimg.com/80/v2-5f4034bc11c3a48a1d1a115f9ee0259b_1440w.jpg)

注意：在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用

## 场景题

### 高并发减库存

**一、防止重复**

**利用redis分布式锁**

用分布式锁，是为了防刷、防止同一个用户同一秒里面把购物车里的商品进行多次结算，防止前端代码出问题触发两次。 利用Jedis客户端编写分布式锁

```java
String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);
```

lockKey是redis的Key，为用户id+商品id+商品数量组成，这样同一秒中只能有一次处理逻辑。 requestId是redis的value，实际是当前线程id，表示有一条线程占用。

> 大家要注意这种分布式锁写法，是同时设定超时时间的。有些分布式锁的文章可能是比较旧版的redis不支持同时设置超时时间，他就一条语句先设置key value，另一条语句后设置超时时间。所以大家留意一下。

**二、扣减库存**

安全扣减库存方案有很多说法，列一下几个方案和我推荐的方案。

**方案一：分布式锁**

有的文章会用redis分布式锁来做保证扣库存数量准确的环节，让点击结算时，后端逻辑会查询库存和扣库存的update语句同时只有一条线程能够执行，以商品id为分布式锁的key，锁一个商品。但是这样，其他购买相同商品的用户将会进行等待。

- 优点：这样做虽然安全
- 缺点：但是失去的是性能问题。

**方案二：分布式锁+分段缓存**

也有文章会说借鉴ConcurrenthashMap，分段锁的机制，把100个商品，分在3个段上，key为分段名字，value为库存数量。用户下单时对用户id进行%3计算，看落在哪个redis的key上，就去取哪个。

> 如key1=product-01,value1=33;key2=product-02,value2=33;key3=product-03,value3=33;

其实会有几个问题：

- 一个是用户想买34件的时候，要去两个片查
- 一个片上卖完了为0，又要去另外一个片查
- 取余方式计算每一片数量，除不尽时，让最后一片补，如100/3=33.33。

**缺点：**

- 方案复杂
- 有遗留问题

**方案三： redis的lpush rpop**

redis队列的lpush、rpop都是只能每次进出一个，对于购买多个数量的情况下不适用，只适用于秒杀情况购买一个的场景、或者抢红包的场景，所以觉得不是很通用。

> 备注：这个抢红包场景以后再分享。

**方案四：推荐使用redis原子操作+sql乐观锁**

**利用Redis increment 的原子操作，保证库存数安全**

1. 先查询redis中是否有库存信息，如果没有就去数据库查，这样就可以减少访问数据库的次数。 获取到后把数值填入redis，以商品id为key，数量为value。 注意要设置**序列化方式为StringRedisSerializer**，不然不能把value做加减操作。 还需要设置redis对应这个key的超时时间，以防所有商品库存数据都在redis中。
2. 比较下单数量的大小，如果够就做后续逻辑。
3. 执行redis客户端的increment，参数为负数，则做减法。因为redis是**单线程处理**，并且因为**increment让key对应的value 减少后返回的是修改后的值**。 有的人会不做第一步查询直接减，其实这样不太好，因为当库存为1时，很多做减3，或者减30情况，其实都是不够，这样就白减。
4. 扣减数据库的库存，这个时候就不需要再select查询，直接乐观锁update，把库存字段值减1 。
5. 做完扣库存就在订单系统做下单。

***样例场景：***

1. 假设两个用户在第一步查询得到库存等于10，A用户走到第二步扣10件，同时一秒内B用户走到第二部扣3件。
2. 因为redis单线程处理，若A用户线程先执行redis语句，那么现在库存等于0，B就只能失败，就不会出更新数据库了。

```java
public void order(OrderReq req) {
  String key = "product:" + req.getProductId();
  // 第一步：先检查 库存是否充足
  Integer num = (Integer) redisTemplate.get(key);
  if (num == null){
    // 去查数据库的数据
    // 并且把数据库的库存set进redis，注意使用NX参数表示只有当没有redis中没有这个key的时候才set库存数量到redis
    //注意要设置序列化方式为StringRedisSerializer，不然不能把value做加减操作
    // 同时设置超时时间，因为不能让redis存着所有商品的库存数，以免占用内存。
    if (count >=0) {
      //设置有效期十分钟
      redisTemplate.expire(key, 60*10+随机数防止雪崩, TimeUnit.SECONDS);
    }
    // 减少经常访问数据库，因为磁盘比内存访问速度要慢
  }
  if (num < req.getNum()) {
    logger.info("库存不足");
  }
  // 第二步：减少库存
  long value = redisTemplate.increment(key, -req.getNum().longValue());
  // 库存充足
  if (value >= 0) {
    logger.info("成功购买");
    // update 数据库中商品库存和订单系统下单，单的状态未待支付
    // 分开两个系统处理时，可以用LCN做分布式事务，但是也是有概率会订单系统的网络超时
    // 也可以使用最终一致性的方式，更新库存成功后，发送mq，等待订单创建生成回调。
    boolean res= updateProduct(req);
    if (res)
      createOrder(req);
  } else {
    // 减了后小小于0 ，如两个人同时买这个商品，导致A人第一步时看到还有10个库存，但是B人买9个先处理完逻辑，
    // 导致B人的线程10-9=1, A人的线程1-10=-9，则现在需要增加刚刚减去的库存，让别人可以买1个
    redisTemplate.increment(key, req.getNum().longValue());
    logger.info("恢复redis库存");
  }
}
```

**update使用乐观锁**

updateProduct方法中执行的sql如下：

```
update Product set count = count - #{购买数量} where id = #{id} and count - #{购买数量} >= 0;
复制代码
```

虽然redis已经防止了超卖，但是数据库层面，为了也要防止超卖，以防redis崩溃时无法使用或者不需要redis处理时，则用乐观锁，因为不一定全部商品都用redis。

利用sql每条单条语句都是有事务的，所以两条sql同时执行，也就只会有其中一条sql先执行成功，另外一条后执行，也如上文提及到的场景一样。

**简单说一下分布式事务：**

分开两个系统处理库存和订单时，这个时候可以用LCN框架做分布式事务，但是因为是http请求的，也是有概率会订单系统的网络超时，导致未返回结果。

其实也可以使用最终一致性的方式，数据表记录一条交互流水记录，更新库存成功后，更新这个交互流水记录的库存操作字段为已处理，订单处理字段为处理中，然后发送mq，等待订单创建生成回调。也要做定时任务做主动查询订单系统的结果，以防没有结果回来。

**方案优势**

- 不需要频繁访问数据库商品库存还有多少
- 不阻塞其他用户
- 安全扣减库存量
- 内存访问库存数量，减少数据库交互

**高并发额外优化**

- 用户访问下单是，前端ui可以让用户触发结算后，把按钮置灰色，防止重复触发。
- 可以按照库存数量来选定是否要用redis，因为如果库存数量少，或者说最近下单次数少的商品，就不用放redis，因为少人看和买的情况下，不必放redis导致占用内存。
- 如果到时间点抢购时，可以使用mq队列形式，用户触发购买商品后，进入队列，让用户的页面一直在转圈圈，等轮到他买的时候再进入结算页面，结算页面的后续流程和本文一致。

### 如何保证Redis和 MySQL双写数据一致性

**1.MySQL持久化数据，Redis只读数据**

redis在启动之后，从数据库加载数据。

**读请求：**

**不要求强一致性的读请求，走redis，要求强一致性的直接从mysql读取**

**写请求：**

**数据首先都写到数据库，之后更新redis**（先写redis再写mysql，如果写入失败事务回滚会造成redis中存在脏数据）

**2.MySQL和Redis处理不同的数据类型**

- MySQL处理实时性数据，例如金融数据、交易数据
- Redis处理实时性要求不高的数据，例如网站最热贴排行榜，好友列表等

在并发不高的情况下，读操作优先读取redis，不存在的话就去访问MySQL，并把读到的数据写回Redis中；

写操作的话，直接写MySQL，成功后再写入Redis(可以在MySQL端定义CRUD触发器，在触发CRUD操作后写数据到Redis，也可以在Redis端解析binlog，再做相应的操作)

在并发高的情况下，读操作和上面一样，写操作是异步写，写入Redis后直接返回，然后定期写入MySQL

几个例子：

1.当更新数据时，如更新某商品的库存，当前商品的库存是100，现在要更新为99，先更新数据库更改成99，然后删除缓存，发现删除缓存失败了，这意味着数据库存的是99，而缓存是100，这导致数据库和缓存不一致。

解决方法：

这种情况应该是先删除缓存，然后再更新数据库，如果删除缓存失败，那就不要更新数据库，如果说删除缓存成功，而更新数据库失败，那查询的时候只是从数据库里查了旧的数据而已，这样就能保持数据库与缓存的一致性。

2.在高并发的情况下，如果当删除完缓存的时候，这时去更新数据库，但还没有更新完，另外一个请求来查询数据，发现缓存里没有，就去数据库里查，还是以上面商品库存为例，如果数据库中产品的库存是100，那么查询到的库存是100，然后插入缓存，插入完缓存后，原来那个更新数据库的线程把数据库更新为了99，导致数据库与缓存不一致的情况

解决方法：

遇到这种情况，可以用队列的去解决这个问，创建几个队列，如20个，根据商品的ID去做hash值，然后对队列个数取摸，当有数据更新请求时，先把它丢到队列里去，当更新完后再从队列里去除。如果在更新的过程中，遇到以上场景，先去缓存里看下有没有数据，如果没有，可以先去队列里看是否有相同商品ID在做更新，如果有也把查询的请求发送到队列里去，然后同步等待缓存更新完成。

这里有一个优化点，如果发现队列里有一个查询请求了，那么就不要放新的查询操作进去了，用一个while（true）循环去查询缓存，循环个200MS左右，如果缓存里还没有则直接取数据库的旧数据，一般情况下是可以取到的。

在高并发下解决场景二要注意的问题：

**1、读请求时长阻塞**

由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时间内返回，该解决方案最大的风险在于可能数据更新很频繁，导致队列中挤压了大量的更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库，像遇到这种情况，一般要做好足够的压力测试，如果压力过大，需要根据实际情况添加机器。

**2、请求并发量过高**

这里还是要做好压力测试，多模拟真实场景，并发量在最高的时候QPS多少，扛不住就要多加机器，还有就是做好读写比例是多少

**3、多服务实例部署的请求路由**

可能这个服务部署了多个实例，那么必须保证说，执行数据更新操作，以及执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务实例上

**4、热点商品的路由问题，导致请求的倾斜**

某些商品的读请求特别高，全部打到了相同的机器的相同丢列里了，可能造成某台服务器压力过大，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题的影响并不是很大，但是确实有可能某些服务器的负载会高一些。

 

![如何保证Redis和 MySQL双写数据一致性](http://p3.pstatp.com/large/pgc-image/51d30e5381ca4663aff8c97a39c9af9f)

 